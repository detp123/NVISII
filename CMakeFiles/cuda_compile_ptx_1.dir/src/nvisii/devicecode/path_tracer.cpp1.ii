# 0 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 1
# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
#pragma GCC diagnostic push


#pragma GCC diagnostic ignored "-Wunused-function"
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_config.h" 1
# 201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_config.h"
# 1 "/usr/include/features.h" 1 3 4
# 375 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 392 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 393 "/usr/include/sys/cdefs.h" 2 3 4
# 376 "/usr/include/features.h" 2 3 4
# 399 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 400 "/usr/include/features.h" 2 3 4
# 202 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_config.h" 2
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2







# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 56 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_types.h" 1
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_types.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_types.h" 2
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_types.h"
enum __attribute__((device_builtin)) cudaRoundMode
{
    cudaRoundNearest,
    cudaRoundZero,
    cudaRoundPosInf,
    cudaRoundMinInf
};
# 57 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h" 1
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_types.h" 1
# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_types.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 66 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_types.h" 2
# 100 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_types.h"
struct __attribute__((device_builtin)) char1
{
    signed char x;
};

struct __attribute__((device_builtin)) uchar1
{
    unsigned char x;
};


struct __attribute__((device_builtin)) __attribute__((aligned(2))) char2
{
    signed char x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(2))) uchar2
{
    unsigned char x, y;
};

struct __attribute__((device_builtin)) char3
{
    signed char x, y, z;
};

struct __attribute__((device_builtin)) uchar3
{
    unsigned char x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) char4
{
    signed char x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) uchar4
{
    unsigned char x, y, z, w;
};

struct __attribute__((device_builtin)) short1
{
    short x;
};

struct __attribute__((device_builtin)) ushort1
{
    unsigned short x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) short2
{
    short x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(4))) ushort2
{
    unsigned short x, y;
};

struct __attribute__((device_builtin)) short3
{
    short x, y, z;
};

struct __attribute__((device_builtin)) ushort3
{
    unsigned short x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(8))) short4 { short x; short y; short z; short w; };
struct __attribute__((device_builtin)) __attribute__((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; };

struct __attribute__((device_builtin)) int1
{
    int x;
};

struct __attribute__((device_builtin)) uint1
{
    unsigned int x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(8))) int2 { int x; int y; };
struct __attribute__((device_builtin)) __attribute__((aligned(8))) uint2 { unsigned int x; unsigned int y; };

struct __attribute__((device_builtin)) int3
{
    int x, y, z;
};

struct __attribute__((device_builtin)) uint3
{
    unsigned int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) int4
{
    int x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) uint4
{
    unsigned int x, y, z, w;
};

struct __attribute__((device_builtin)) long1
{
    long int x;
};

struct __attribute__((device_builtin)) ulong1
{
    unsigned long x;
};






struct __attribute__((device_builtin)) __attribute__((aligned(2*sizeof(long int)))) long2
{
    long int x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(2*sizeof(unsigned long int)))) ulong2
{
    unsigned long int x, y;
};



struct __attribute__((device_builtin)) long3
{
    long int x, y, z;
};

struct __attribute__((device_builtin)) ulong3
{
    unsigned long int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) long4
{
    long int x, y, z, w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulong4
{
    unsigned long int x, y, z, w;
};

struct __attribute__((device_builtin)) float1
{
    float x;
};
# 276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_types.h"
struct __attribute__((device_builtin)) __attribute__((aligned(8))) float2 { float x; float y; };




struct __attribute__((device_builtin)) float3
{
    float x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) float4
{
    float x, y, z, w;
};

struct __attribute__((device_builtin)) longlong1
{
    long long int x;
};

struct __attribute__((device_builtin)) ulonglong1
{
    unsigned long long int x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) longlong2
{
    long long int x, y;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulonglong2
{
    unsigned long long int x, y;
};

struct __attribute__((device_builtin)) longlong3
{
    long long int x, y, z;
};

struct __attribute__((device_builtin)) ulonglong3
{
    unsigned long long int x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) longlong4
{
    long long int x, y, z ,w;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) ulonglong4
{
    unsigned long long int x, y, z, w;
};

struct __attribute__((device_builtin)) double1
{
    double x;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) double2
{
    double x, y;
};

struct __attribute__((device_builtin)) double3
{
    double x, y, z;
};

struct __attribute__((device_builtin)) __attribute__((aligned(16))) double4
{
    double x, y, z, w;
};
# 363 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_types.h"
typedef __attribute__((device_builtin)) struct char1 char1;
typedef __attribute__((device_builtin)) struct uchar1 uchar1;
typedef __attribute__((device_builtin)) struct char2 char2;
typedef __attribute__((device_builtin)) struct uchar2 uchar2;
typedef __attribute__((device_builtin)) struct char3 char3;
typedef __attribute__((device_builtin)) struct uchar3 uchar3;
typedef __attribute__((device_builtin)) struct char4 char4;
typedef __attribute__((device_builtin)) struct uchar4 uchar4;
typedef __attribute__((device_builtin)) struct short1 short1;
typedef __attribute__((device_builtin)) struct ushort1 ushort1;
typedef __attribute__((device_builtin)) struct short2 short2;
typedef __attribute__((device_builtin)) struct ushort2 ushort2;
typedef __attribute__((device_builtin)) struct short3 short3;
typedef __attribute__((device_builtin)) struct ushort3 ushort3;
typedef __attribute__((device_builtin)) struct short4 short4;
typedef __attribute__((device_builtin)) struct ushort4 ushort4;
typedef __attribute__((device_builtin)) struct int1 int1;
typedef __attribute__((device_builtin)) struct uint1 uint1;
typedef __attribute__((device_builtin)) struct int2 int2;
typedef __attribute__((device_builtin)) struct uint2 uint2;
typedef __attribute__((device_builtin)) struct int3 int3;
typedef __attribute__((device_builtin)) struct uint3 uint3;
typedef __attribute__((device_builtin)) struct int4 int4;
typedef __attribute__((device_builtin)) struct uint4 uint4;
typedef __attribute__((device_builtin)) struct long1 long1;
typedef __attribute__((device_builtin)) struct ulong1 ulong1;
typedef __attribute__((device_builtin)) struct long2 long2;
typedef __attribute__((device_builtin)) struct ulong2 ulong2;
typedef __attribute__((device_builtin)) struct long3 long3;
typedef __attribute__((device_builtin)) struct ulong3 ulong3;
typedef __attribute__((device_builtin)) struct long4 long4;
typedef __attribute__((device_builtin)) struct ulong4 ulong4;
typedef __attribute__((device_builtin)) struct float1 float1;
typedef __attribute__((device_builtin)) struct float2 float2;
typedef __attribute__((device_builtin)) struct float3 float3;
typedef __attribute__((device_builtin)) struct float4 float4;
typedef __attribute__((device_builtin)) struct longlong1 longlong1;
typedef __attribute__((device_builtin)) struct ulonglong1 ulonglong1;
typedef __attribute__((device_builtin)) struct longlong2 longlong2;
typedef __attribute__((device_builtin)) struct ulonglong2 ulonglong2;
typedef __attribute__((device_builtin)) struct longlong3 longlong3;
typedef __attribute__((device_builtin)) struct ulonglong3 ulonglong3;
typedef __attribute__((device_builtin)) struct longlong4 longlong4;
typedef __attribute__((device_builtin)) struct ulonglong4 ulonglong4;
typedef __attribute__((device_builtin)) struct double1 double1;
typedef __attribute__((device_builtin)) struct double2 double2;
typedef __attribute__((device_builtin)) struct double3 double3;
typedef __attribute__((device_builtin)) struct double4 double4;







struct __attribute__((device_builtin)) dim3
{
    unsigned int x, y, z;


    __attribute__((host)) __attribute__((device)) constexpr dim3(unsigned int vx = 1, unsigned int vy = 1, unsigned int vz = 1) : x(vx), y(vy), z(vz) {}
    __attribute__((host)) __attribute__((device)) constexpr dim3(uint3 v) : x(v.x), y(v.y), z(v.z) {}
    __attribute__((host)) __attribute__((device)) constexpr operator uint3(void) const { return uint3{x, y, z}; }






};

typedef __attribute__((device_builtin)) struct dim3 dim3;
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h" 2
# 81 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 1 3 4
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/syslimits.h" 1 3 4






# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 1 3 4
# 203 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 2 3 4
# 153 "/usr/include/limits.h" 2 3 4
# 204 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 2 3 4
# 8 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/syslimits.h" 2 3 4
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 2 3 4
# 82 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 143 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 3 4

# 143 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h" 2
# 204 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"

# 204 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
enum __attribute__((device_builtin)) cudaError
{





    cudaSuccess = 0,





    cudaErrorInvalidValue = 1,





    cudaErrorMemoryAllocation = 2,





    cudaErrorInitializationError = 3,






    cudaErrorCudartUnloading = 4,






    cudaErrorProfilerDisabled = 5,







    cudaErrorProfilerNotInitialized = 6,






    cudaErrorProfilerAlreadyStarted = 7,






     cudaErrorProfilerAlreadyStopped = 8,
# 274 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorInvalidConfiguration = 9,





    cudaErrorInvalidPitchValue = 12,





    cudaErrorInvalidSymbol = 13,







    cudaErrorInvalidHostPointer = 16,







    cudaErrorInvalidDevicePointer = 17,





    cudaErrorInvalidTexture = 18,





    cudaErrorInvalidTextureBinding = 19,






    cudaErrorInvalidChannelDescriptor = 20,





    cudaErrorInvalidMemcpyDirection = 21,
# 337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorAddressOfConstant = 22,
# 346 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorTextureFetchFailed = 23,
# 355 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorTextureNotBound = 24,
# 364 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorSynchronizationError = 25,





    cudaErrorInvalidFilterSetting = 26,





    cudaErrorInvalidNormSetting = 27,







    cudaErrorMixedDeviceExecution = 28,







    cudaErrorNotYetImplemented = 31,
# 401 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorMemoryValueTooLarge = 32,






    cudaErrorStubLibrary = 34,






    cudaErrorInsufficientDriver = 35,






    cudaErrorCallRequiresNewerDriver = 36,





    cudaErrorInvalidSurface = 37,





    cudaErrorDuplicateVariableName = 43,





    cudaErrorDuplicateTextureName = 44,





    cudaErrorDuplicateSurfaceName = 45,
# 456 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorDevicesUnavailable = 46,
# 469 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorIncompatibleDriverContext = 49,





    cudaErrorMissingConfiguration = 52,
# 484 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorPriorLaunchFailure = 53,






    cudaErrorLaunchMaxDepthExceeded = 65,







    cudaErrorLaunchFileScopedTex = 66,







    cudaErrorLaunchFileScopedSurf = 67,
# 522 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorSyncDepthExceeded = 68,
# 534 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorLaunchPendingCountExceeded = 69,





    cudaErrorInvalidDeviceFunction = 98,





    cudaErrorNoDevice = 100,






    cudaErrorInvalidDevice = 101,




    cudaErrorDeviceNotLicensed = 102,
# 567 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
   cudaErrorSoftwareValidityNotEstablished = 103,




    cudaErrorStartupFailure = 127,




    cudaErrorInvalidKernelImage = 200,
# 587 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorDeviceUninitialized = 201,




    cudaErrorMapBufferObjectFailed = 205,




    cudaErrorUnmapBufferObjectFailed = 206,





    cudaErrorArrayIsMapped = 207,




    cudaErrorAlreadyMapped = 208,







    cudaErrorNoKernelImageForDevice = 209,




    cudaErrorAlreadyAcquired = 210,




    cudaErrorNotMapped = 211,





    cudaErrorNotMappedAsArray = 212,





    cudaErrorNotMappedAsPointer = 213,





    cudaErrorECCUncorrectable = 214,





    cudaErrorUnsupportedLimit = 215,





    cudaErrorDeviceAlreadyInUse = 216,





    cudaErrorPeerAccessUnsupported = 217,





    cudaErrorInvalidPtx = 218,




    cudaErrorInvalidGraphicsContext = 219,





    cudaErrorNvlinkUncorrectable = 220,






    cudaErrorJitCompilerNotFound = 221,






    cudaErrorUnsupportedPtxVersion = 222,






    cudaErrorJitCompilationDisabled = 223,




    cudaErrorUnsupportedExecAffinity = 224,




    cudaErrorInvalidSource = 300,




    cudaErrorFileNotFound = 301,




    cudaErrorSharedObjectSymbolNotFound = 302,




    cudaErrorSharedObjectInitFailed = 303,




    cudaErrorOperatingSystem = 304,






    cudaErrorInvalidResourceHandle = 400,





    cudaErrorIllegalState = 401,






    cudaErrorSymbolNotFound = 500,







    cudaErrorNotReady = 600,







    cudaErrorIllegalAddress = 700,
# 775 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorLaunchOutOfResources = 701,
# 786 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorLaunchTimeout = 702,





    cudaErrorLaunchIncompatibleTexturing = 703,






    cudaErrorPeerAccessAlreadyEnabled = 704,






    cudaErrorPeerAccessNotEnabled = 705,
# 819 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorSetOnActiveProcess = 708,






    cudaErrorContextIsDestroyed = 709,






    cudaErrorAssert = 710,






    cudaErrorTooManyPeers = 711,





    cudaErrorHostMemoryAlreadyRegistered = 712,





    cudaErrorHostMemoryNotRegistered = 713,
# 861 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorHardwareStackError = 714,







    cudaErrorIllegalInstruction = 715,
# 878 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorMisalignedAddress = 716,
# 889 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorInvalidAddressSpace = 717,







    cudaErrorInvalidPc = 718,
# 908 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorLaunchFailure = 719,
# 917 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorCooperativeLaunchTooLarge = 720,




    cudaErrorNotPermitted = 800,





    cudaErrorNotSupported = 801,
# 937 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorSystemNotReady = 802,






    cudaErrorSystemDriverMismatch = 803,
# 953 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorCompatNotSupportedOnDevice = 804,




    cudaErrorMpsConnectionFailed = 805,




    cudaErrorMpsRpcFailure = 806,





    cudaErrorMpsServerNotReady = 807,




    cudaErrorMpsMaxClientsReached = 808,




    cudaErrorMpsMaxConnectionsReached = 809,




    cudaErrorStreamCaptureUnsupported = 900,





    cudaErrorStreamCaptureInvalidated = 901,





    cudaErrorStreamCaptureMerge = 902,




    cudaErrorStreamCaptureUnmatched = 903,





    cudaErrorStreamCaptureUnjoined = 904,






    cudaErrorStreamCaptureIsolation = 905,





    cudaErrorStreamCaptureImplicit = 906,





    cudaErrorCapturedEvent = 907,






    cudaErrorStreamCaptureWrongThread = 908,




    cudaErrorTimeout = 909,





    cudaErrorGraphExecUpdateFailure = 910,
# 1054 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorExternalDevice = 911,
# 1067 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaErrorUnknown = 999,







    cudaErrorApiFailureBase = 10000
};




enum __attribute__((device_builtin)) cudaChannelFormatKind
{
    cudaChannelFormatKindSigned = 0,
    cudaChannelFormatKindUnsigned = 1,
    cudaChannelFormatKindFloat = 2,
    cudaChannelFormatKindNone = 3,
    cudaChannelFormatKindNV12 = 4,
    cudaChannelFormatKindUnsignedNormalized8X1 = 5,
    cudaChannelFormatKindUnsignedNormalized8X2 = 6,
    cudaChannelFormatKindUnsignedNormalized8X4 = 7,
    cudaChannelFormatKindUnsignedNormalized16X1 = 8,
    cudaChannelFormatKindUnsignedNormalized16X2 = 9,
    cudaChannelFormatKindUnsignedNormalized16X4 = 10,
    cudaChannelFormatKindSignedNormalized8X1 = 11,
    cudaChannelFormatKindSignedNormalized8X2 = 12,
    cudaChannelFormatKindSignedNormalized8X4 = 13,
    cudaChannelFormatKindSignedNormalized16X1 = 14,
    cudaChannelFormatKindSignedNormalized16X2 = 15,
    cudaChannelFormatKindSignedNormalized16X4 = 16,
    cudaChannelFormatKindUnsignedBlockCompressed1 = 17,
    cudaChannelFormatKindUnsignedBlockCompressed1SRGB = 18,
    cudaChannelFormatKindUnsignedBlockCompressed2 = 19,
    cudaChannelFormatKindUnsignedBlockCompressed2SRGB = 20,
    cudaChannelFormatKindUnsignedBlockCompressed3 = 21,
    cudaChannelFormatKindUnsignedBlockCompressed3SRGB = 22,
    cudaChannelFormatKindUnsignedBlockCompressed4 = 23,
    cudaChannelFormatKindSignedBlockCompressed4 = 24,
    cudaChannelFormatKindUnsignedBlockCompressed5 = 25,
    cudaChannelFormatKindSignedBlockCompressed5 = 26,
    cudaChannelFormatKindUnsignedBlockCompressed6H = 27,
    cudaChannelFormatKindSignedBlockCompressed6H = 28,
    cudaChannelFormatKindUnsignedBlockCompressed7 = 29,
    cudaChannelFormatKindUnsignedBlockCompressed7SRGB = 30
};




struct __attribute__((device_builtin)) cudaChannelFormatDesc
{
    int x;
    int y;
    int z;
    int w;
    enum cudaChannelFormatKind f;
};




typedef struct cudaArray *cudaArray_t;




typedef const struct cudaArray *cudaArray_const_t;

struct cudaArray;




typedef struct cudaMipmappedArray *cudaMipmappedArray_t;




typedef const struct cudaMipmappedArray *cudaMipmappedArray_const_t;

struct cudaMipmappedArray;
# 1160 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
struct __attribute__((device_builtin)) cudaArraySparseProperties {
    struct {
        unsigned int width;
        unsigned int height;
        unsigned int depth;
    } tileExtent;
    unsigned int miptailFirstLevel;
    unsigned long long miptailSize;
    unsigned int flags;
    unsigned int reserved[4];
};





struct __attribute__((device_builtin)) cudaArrayMemoryRequirements {
    size_t size;
    size_t alignment;
    unsigned int reserved[4];
};





enum __attribute__((device_builtin)) cudaMemoryType
{
    cudaMemoryTypeUnregistered = 0,
    cudaMemoryTypeHost = 1,
    cudaMemoryTypeDevice = 2,
    cudaMemoryTypeManaged = 3
};




enum __attribute__((device_builtin)) cudaMemcpyKind
{
    cudaMemcpyHostToHost = 0,
    cudaMemcpyHostToDevice = 1,
    cudaMemcpyDeviceToHost = 2,
    cudaMemcpyDeviceToDevice = 3,
    cudaMemcpyDefault = 4
};






struct __attribute__((device_builtin)) cudaPitchedPtr
{
    void *ptr;
    size_t pitch;
    size_t xsize;
    size_t ysize;
};






struct __attribute__((device_builtin)) cudaExtent
{
    size_t width;
    size_t height;
    size_t depth;
};






struct __attribute__((device_builtin)) cudaPos
{
    size_t x;
    size_t y;
    size_t z;
};




struct __attribute__((device_builtin)) cudaMemcpy3DParms
{
    cudaArray_t srcArray;
    struct cudaPos srcPos;
    struct cudaPitchedPtr srcPtr;

    cudaArray_t dstArray;
    struct cudaPos dstPos;
    struct cudaPitchedPtr dstPtr;

    struct cudaExtent extent;
    enum cudaMemcpyKind kind;
};




struct __attribute__((device_builtin)) cudaMemcpy3DPeerParms
{
    cudaArray_t srcArray;
    struct cudaPos srcPos;
    struct cudaPitchedPtr srcPtr;
    int srcDevice;

    cudaArray_t dstArray;
    struct cudaPos dstPos;
    struct cudaPitchedPtr dstPtr;
    int dstDevice;

    struct cudaExtent extent;
};




struct __attribute__((device_builtin)) cudaMemsetParams {
    void *dst;
    size_t pitch;
    unsigned int value;
    unsigned int elementSize;
    size_t width;
    size_t height;
};




enum __attribute__((device_builtin)) cudaAccessProperty {
    cudaAccessPropertyNormal = 0,
    cudaAccessPropertyStreaming = 1,
    cudaAccessPropertyPersisting = 2
};
# 1310 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
struct __attribute__((device_builtin)) cudaAccessPolicyWindow {
    void *base_ptr;
    size_t num_bytes;
    float hitRatio;
    enum cudaAccessProperty hitProp;
    enum cudaAccessProperty missProp;
};
# 1328 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef void ( *cudaHostFn_t)(void *userData);




struct __attribute__((device_builtin)) cudaHostNodeParams {
    cudaHostFn_t fn;
    void* userData;
};




enum __attribute__((device_builtin)) cudaStreamCaptureStatus {
    cudaStreamCaptureStatusNone = 0,
    cudaStreamCaptureStatusActive = 1,
    cudaStreamCaptureStatusInvalidated = 2

};





enum __attribute__((device_builtin)) cudaStreamCaptureMode {
    cudaStreamCaptureModeGlobal = 0,
    cudaStreamCaptureModeThreadLocal = 1,
    cudaStreamCaptureModeRelaxed = 2
};

enum __attribute__((device_builtin)) cudaSynchronizationPolicy {
    cudaSyncPolicyAuto = 1,
    cudaSyncPolicySpin = 2,
    cudaSyncPolicyYield = 3,
    cudaSyncPolicyBlockingSync = 4
};
# 1379 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
enum __attribute__((device_builtin)) cudaStreamUpdateCaptureDependenciesFlags {
    cudaStreamAddCaptureDependencies = 0x0,
    cudaStreamSetCaptureDependencies = 0x1
};




enum __attribute__((device_builtin)) cudaUserObjectFlags {
    cudaUserObjectNoDestructorSync = 0x1
};




enum __attribute__((device_builtin)) cudaUserObjectRetainFlags {
    cudaGraphUserObjectMove = 0x1
};




struct cudaGraphicsResource;




enum __attribute__((device_builtin)) cudaGraphicsRegisterFlags
{
    cudaGraphicsRegisterFlagsNone = 0,
    cudaGraphicsRegisterFlagsReadOnly = 1,
    cudaGraphicsRegisterFlagsWriteDiscard = 2,
    cudaGraphicsRegisterFlagsSurfaceLoadStore = 4,
    cudaGraphicsRegisterFlagsTextureGather = 8
};




enum __attribute__((device_builtin)) cudaGraphicsMapFlags
{
    cudaGraphicsMapFlagsNone = 0,
    cudaGraphicsMapFlagsReadOnly = 1,
    cudaGraphicsMapFlagsWriteDiscard = 2
};




enum __attribute__((device_builtin)) cudaGraphicsCubeFace
{
    cudaGraphicsCubeFacePositiveX = 0x00,
    cudaGraphicsCubeFaceNegativeX = 0x01,
    cudaGraphicsCubeFacePositiveY = 0x02,
    cudaGraphicsCubeFaceNegativeY = 0x03,
    cudaGraphicsCubeFacePositiveZ = 0x04,
    cudaGraphicsCubeFaceNegativeZ = 0x05
};




enum __attribute__((device_builtin)) cudaResourceType
{
    cudaResourceTypeArray = 0x00,
    cudaResourceTypeMipmappedArray = 0x01,
    cudaResourceTypeLinear = 0x02,
    cudaResourceTypePitch2D = 0x03
};




enum __attribute__((device_builtin)) cudaResourceViewFormat
{
    cudaResViewFormatNone = 0x00,
    cudaResViewFormatUnsignedChar1 = 0x01,
    cudaResViewFormatUnsignedChar2 = 0x02,
    cudaResViewFormatUnsignedChar4 = 0x03,
    cudaResViewFormatSignedChar1 = 0x04,
    cudaResViewFormatSignedChar2 = 0x05,
    cudaResViewFormatSignedChar4 = 0x06,
    cudaResViewFormatUnsignedShort1 = 0x07,
    cudaResViewFormatUnsignedShort2 = 0x08,
    cudaResViewFormatUnsignedShort4 = 0x09,
    cudaResViewFormatSignedShort1 = 0x0a,
    cudaResViewFormatSignedShort2 = 0x0b,
    cudaResViewFormatSignedShort4 = 0x0c,
    cudaResViewFormatUnsignedInt1 = 0x0d,
    cudaResViewFormatUnsignedInt2 = 0x0e,
    cudaResViewFormatUnsignedInt4 = 0x0f,
    cudaResViewFormatSignedInt1 = 0x10,
    cudaResViewFormatSignedInt2 = 0x11,
    cudaResViewFormatSignedInt4 = 0x12,
    cudaResViewFormatHalf1 = 0x13,
    cudaResViewFormatHalf2 = 0x14,
    cudaResViewFormatHalf4 = 0x15,
    cudaResViewFormatFloat1 = 0x16,
    cudaResViewFormatFloat2 = 0x17,
    cudaResViewFormatFloat4 = 0x18,
    cudaResViewFormatUnsignedBlockCompressed1 = 0x19,
    cudaResViewFormatUnsignedBlockCompressed2 = 0x1a,
    cudaResViewFormatUnsignedBlockCompressed3 = 0x1b,
    cudaResViewFormatUnsignedBlockCompressed4 = 0x1c,
    cudaResViewFormatSignedBlockCompressed4 = 0x1d,
    cudaResViewFormatUnsignedBlockCompressed5 = 0x1e,
    cudaResViewFormatSignedBlockCompressed5 = 0x1f,
    cudaResViewFormatUnsignedBlockCompressed6H = 0x20,
    cudaResViewFormatSignedBlockCompressed6H = 0x21,
    cudaResViewFormatUnsignedBlockCompressed7 = 0x22
};




struct __attribute__((device_builtin)) cudaResourceDesc {
    enum cudaResourceType resType;

    union {
        struct {
            cudaArray_t array;
        } array;
        struct {
            cudaMipmappedArray_t mipmap;
        } mipmap;
        struct {
            void *devPtr;
            struct cudaChannelFormatDesc desc;
            size_t sizeInBytes;
        } linear;
        struct {
            void *devPtr;
            struct cudaChannelFormatDesc desc;
            size_t width;
            size_t height;
            size_t pitchInBytes;
        } pitch2D;
    } res;
};




struct __attribute__((device_builtin)) cudaResourceViewDesc
{
    enum cudaResourceViewFormat format;
    size_t width;
    size_t height;
    size_t depth;
    unsigned int firstMipmapLevel;
    unsigned int lastMipmapLevel;
    unsigned int firstLayer;
    unsigned int lastLayer;
};




struct __attribute__((device_builtin)) cudaPointerAttributes
{




    enum cudaMemoryType type;
# 1554 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    int device;





    void *devicePointer;
# 1569 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    void *hostPointer;
};




struct __attribute__((device_builtin)) cudaFuncAttributes
{





   size_t sharedSizeBytes;





   size_t constSizeBytes;




   size_t localSizeBytes;






   int maxThreadsPerBlock;




   int numRegs;






   int ptxVersion;






   int binaryVersion;





   int cacheModeCA;






   int maxDynamicSharedSizeBytes;
# 1641 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
   int preferredShmemCarveout;
# 1691 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
};




enum __attribute__((device_builtin)) cudaFuncAttribute
{
    cudaFuncAttributeMaxDynamicSharedMemorySize = 8,
    cudaFuncAttributePreferredSharedMemoryCarveout = 9,
# 1708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaFuncAttributeMax
};




enum __attribute__((device_builtin)) cudaFuncCache
{
    cudaFuncCachePreferNone = 0,
    cudaFuncCachePreferShared = 1,
    cudaFuncCachePreferL1 = 2,
    cudaFuncCachePreferEqual = 3
};





enum __attribute__((device_builtin)) cudaSharedMemConfig
{
    cudaSharedMemBankSizeDefault = 0,
    cudaSharedMemBankSizeFourByte = 1,
    cudaSharedMemBankSizeEightByte = 2
};




enum __attribute__((device_builtin)) cudaSharedCarveout {
    cudaSharedmemCarveoutDefault = -1,
    cudaSharedmemCarveoutMaxShared = 100,
    cudaSharedmemCarveoutMaxL1 = 0
};




enum __attribute__((device_builtin)) cudaComputeMode
{
    cudaComputeModeDefault = 0,
    cudaComputeModeExclusive = 1,
    cudaComputeModeProhibited = 2,
    cudaComputeModeExclusiveProcess = 3
};




enum __attribute__((device_builtin)) cudaLimit
{
    cudaLimitStackSize = 0x00,
    cudaLimitPrintfFifoSize = 0x01,
    cudaLimitMallocHeapSize = 0x02,
    cudaLimitDevRuntimeSyncDepth = 0x03,
    cudaLimitDevRuntimePendingLaunchCount = 0x04,
    cudaLimitMaxL2FetchGranularity = 0x05,
    cudaLimitPersistingL2CacheSize = 0x06
};




enum __attribute__((device_builtin)) cudaMemoryAdvise
{
    cudaMemAdviseSetReadMostly = 1,
    cudaMemAdviseUnsetReadMostly = 2,
    cudaMemAdviseSetPreferredLocation = 3,
    cudaMemAdviseUnsetPreferredLocation = 4,
    cudaMemAdviseSetAccessedBy = 5,
    cudaMemAdviseUnsetAccessedBy = 6
};




enum __attribute__((device_builtin)) cudaMemRangeAttribute
{
    cudaMemRangeAttributeReadMostly = 1,
    cudaMemRangeAttributePreferredLocation = 2,
    cudaMemRangeAttributeAccessedBy = 3,
    cudaMemRangeAttributeLastPrefetchLocation = 4
};




enum __attribute__((device_builtin)) cudaOutputMode
{
    cudaKeyValuePair = 0x00,
    cudaCSV = 0x01
};




enum __attribute__((device_builtin)) cudaFlushGPUDirectRDMAWritesOptions {
    cudaFlushGPUDirectRDMAWritesOptionHost = 1<<0,
    cudaFlushGPUDirectRDMAWritesOptionMemOps = 1<<1
};




enum __attribute__((device_builtin)) cudaGPUDirectRDMAWritesOrdering {
    cudaGPUDirectRDMAWritesOrderingNone = 0,
    cudaGPUDirectRDMAWritesOrderingOwner = 100,
    cudaGPUDirectRDMAWritesOrderingAllDevices = 200
};




enum __attribute__((device_builtin)) cudaFlushGPUDirectRDMAWritesScope {
    cudaFlushGPUDirectRDMAWritesToOwner = 100,
    cudaFlushGPUDirectRDMAWritesToAllDevices = 200
};




enum __attribute__((device_builtin)) cudaFlushGPUDirectRDMAWritesTarget {
    cudaFlushGPUDirectRDMAWritesTargetCurrentDevice
};





enum __attribute__((device_builtin)) cudaDeviceAttr
{
    cudaDevAttrMaxThreadsPerBlock = 1,
    cudaDevAttrMaxBlockDimX = 2,
    cudaDevAttrMaxBlockDimY = 3,
    cudaDevAttrMaxBlockDimZ = 4,
    cudaDevAttrMaxGridDimX = 5,
    cudaDevAttrMaxGridDimY = 6,
    cudaDevAttrMaxGridDimZ = 7,
    cudaDevAttrMaxSharedMemoryPerBlock = 8,
    cudaDevAttrTotalConstantMemory = 9,
    cudaDevAttrWarpSize = 10,
    cudaDevAttrMaxPitch = 11,
    cudaDevAttrMaxRegistersPerBlock = 12,
    cudaDevAttrClockRate = 13,
    cudaDevAttrTextureAlignment = 14,
    cudaDevAttrGpuOverlap = 15,
    cudaDevAttrMultiProcessorCount = 16,
    cudaDevAttrKernelExecTimeout = 17,
    cudaDevAttrIntegrated = 18,
    cudaDevAttrCanMapHostMemory = 19,
    cudaDevAttrComputeMode = 20,
    cudaDevAttrMaxTexture1DWidth = 21,
    cudaDevAttrMaxTexture2DWidth = 22,
    cudaDevAttrMaxTexture2DHeight = 23,
    cudaDevAttrMaxTexture3DWidth = 24,
    cudaDevAttrMaxTexture3DHeight = 25,
    cudaDevAttrMaxTexture3DDepth = 26,
    cudaDevAttrMaxTexture2DLayeredWidth = 27,
    cudaDevAttrMaxTexture2DLayeredHeight = 28,
    cudaDevAttrMaxTexture2DLayeredLayers = 29,
    cudaDevAttrSurfaceAlignment = 30,
    cudaDevAttrConcurrentKernels = 31,
    cudaDevAttrEccEnabled = 32,
    cudaDevAttrPciBusId = 33,
    cudaDevAttrPciDeviceId = 34,
    cudaDevAttrTccDriver = 35,
    cudaDevAttrMemoryClockRate = 36,
    cudaDevAttrGlobalMemoryBusWidth = 37,
    cudaDevAttrL2CacheSize = 38,
    cudaDevAttrMaxThreadsPerMultiProcessor = 39,
    cudaDevAttrAsyncEngineCount = 40,
    cudaDevAttrUnifiedAddressing = 41,
    cudaDevAttrMaxTexture1DLayeredWidth = 42,
    cudaDevAttrMaxTexture1DLayeredLayers = 43,
    cudaDevAttrMaxTexture2DGatherWidth = 45,
    cudaDevAttrMaxTexture2DGatherHeight = 46,
    cudaDevAttrMaxTexture3DWidthAlt = 47,
    cudaDevAttrMaxTexture3DHeightAlt = 48,
    cudaDevAttrMaxTexture3DDepthAlt = 49,
    cudaDevAttrPciDomainId = 50,
    cudaDevAttrTexturePitchAlignment = 51,
    cudaDevAttrMaxTextureCubemapWidth = 52,
    cudaDevAttrMaxTextureCubemapLayeredWidth = 53,
    cudaDevAttrMaxTextureCubemapLayeredLayers = 54,
    cudaDevAttrMaxSurface1DWidth = 55,
    cudaDevAttrMaxSurface2DWidth = 56,
    cudaDevAttrMaxSurface2DHeight = 57,
    cudaDevAttrMaxSurface3DWidth = 58,
    cudaDevAttrMaxSurface3DHeight = 59,
    cudaDevAttrMaxSurface3DDepth = 60,
    cudaDevAttrMaxSurface1DLayeredWidth = 61,
    cudaDevAttrMaxSurface1DLayeredLayers = 62,
    cudaDevAttrMaxSurface2DLayeredWidth = 63,
    cudaDevAttrMaxSurface2DLayeredHeight = 64,
    cudaDevAttrMaxSurface2DLayeredLayers = 65,
    cudaDevAttrMaxSurfaceCubemapWidth = 66,
    cudaDevAttrMaxSurfaceCubemapLayeredWidth = 67,
    cudaDevAttrMaxSurfaceCubemapLayeredLayers = 68,
    cudaDevAttrMaxTexture1DLinearWidth = 69,
    cudaDevAttrMaxTexture2DLinearWidth = 70,
    cudaDevAttrMaxTexture2DLinearHeight = 71,
    cudaDevAttrMaxTexture2DLinearPitch = 72,
    cudaDevAttrMaxTexture2DMipmappedWidth = 73,
    cudaDevAttrMaxTexture2DMipmappedHeight = 74,
    cudaDevAttrComputeCapabilityMajor = 75,
    cudaDevAttrComputeCapabilityMinor = 76,
    cudaDevAttrMaxTexture1DMipmappedWidth = 77,
    cudaDevAttrStreamPrioritiesSupported = 78,
    cudaDevAttrGlobalL1CacheSupported = 79,
    cudaDevAttrLocalL1CacheSupported = 80,
    cudaDevAttrMaxSharedMemoryPerMultiprocessor = 81,
    cudaDevAttrMaxRegistersPerMultiprocessor = 82,
    cudaDevAttrManagedMemory = 83,
    cudaDevAttrIsMultiGpuBoard = 84,
    cudaDevAttrMultiGpuBoardGroupID = 85,
    cudaDevAttrHostNativeAtomicSupported = 86,
    cudaDevAttrSingleToDoublePrecisionPerfRatio = 87,
    cudaDevAttrPageableMemoryAccess = 88,
    cudaDevAttrConcurrentManagedAccess = 89,
    cudaDevAttrComputePreemptionSupported = 90,
    cudaDevAttrCanUseHostPointerForRegisteredMem = 91,
    cudaDevAttrReserved92 = 92,
    cudaDevAttrReserved93 = 93,
    cudaDevAttrReserved94 = 94,
    cudaDevAttrCooperativeLaunch = 95,
    cudaDevAttrCooperativeMultiDeviceLaunch = 96,
    cudaDevAttrMaxSharedMemoryPerBlockOptin = 97,
    cudaDevAttrCanFlushRemoteWrites = 98,
    cudaDevAttrHostRegisterSupported = 99,
    cudaDevAttrPageableMemoryAccessUsesHostPageTables = 100,
    cudaDevAttrDirectManagedMemAccessFromHost = 101,
    cudaDevAttrMaxBlocksPerMultiprocessor = 106,
    cudaDevAttrMaxPersistingL2CacheSize = 108,
    cudaDevAttrMaxAccessPolicyWindowSize = 109,
    cudaDevAttrReservedSharedMemoryPerBlock = 111,
    cudaDevAttrSparseCudaArraySupported = 112,
    cudaDevAttrHostRegisterReadOnlySupported = 113,
    cudaDevAttrTimelineSemaphoreInteropSupported = 114,
    cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114,
    cudaDevAttrMemoryPoolsSupported = 115,
    cudaDevAttrGPUDirectRDMASupported = 116,
    cudaDevAttrGPUDirectRDMAFlushWritesOptions = 117,
    cudaDevAttrGPUDirectRDMAWritesOrdering = 118,
    cudaDevAttrMemoryPoolSupportedHandleTypes = 119,




    cudaDevAttrDeferredMappingCudaArraySupported = 121,

    cudaDevAttrMax
};




enum __attribute__((device_builtin)) cudaMemPoolAttr
{
# 1973 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaMemPoolReuseFollowEventDependencies = 0x1,






    cudaMemPoolReuseAllowOpportunistic = 0x2,







    cudaMemPoolReuseAllowInternalDependencies = 0x3,
# 1999 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    cudaMemPoolAttrReleaseThreshold = 0x4,





    cudaMemPoolAttrReservedMemCurrent = 0x5,






    cudaMemPoolAttrReservedMemHigh = 0x6,





    cudaMemPoolAttrUsedMemCurrent = 0x7,






    cudaMemPoolAttrUsedMemHigh = 0x8
};




enum __attribute__((device_builtin)) cudaMemLocationType {
    cudaMemLocationTypeInvalid = 0,
    cudaMemLocationTypeDevice = 1
};






struct __attribute__((device_builtin)) cudaMemLocation {
    enum cudaMemLocationType type;
    int id;
};




enum __attribute__((device_builtin)) cudaMemAccessFlags {
    cudaMemAccessFlagsProtNone = 0,
    cudaMemAccessFlagsProtRead = 1,
    cudaMemAccessFlagsProtReadWrite = 3
};




struct __attribute__((device_builtin)) cudaMemAccessDesc {
    struct cudaMemLocation location;
    enum cudaMemAccessFlags flags;
};




enum __attribute__((device_builtin)) cudaMemAllocationType {
    cudaMemAllocationTypeInvalid = 0x0,



    cudaMemAllocationTypePinned = 0x1,
    cudaMemAllocationTypeMax = 0x7FFFFFFF
};




enum __attribute__((device_builtin)) cudaMemAllocationHandleType {
    cudaMemHandleTypeNone = 0x0,
    cudaMemHandleTypePosixFileDescriptor = 0x1,
    cudaMemHandleTypeWin32 = 0x2,
    cudaMemHandleTypeWin32Kmt = 0x4
};




struct __attribute__((device_builtin)) cudaMemPoolProps {
    enum cudaMemAllocationType allocType;
    enum cudaMemAllocationHandleType handleTypes;
    struct cudaMemLocation location;






    void *win32SecurityAttributes;
    unsigned char reserved[64];
};




struct __attribute__((device_builtin)) cudaMemPoolPtrExportData {
    unsigned char reserved[64];
};




struct __attribute__((device_builtin)) cudaMemAllocNodeParams {




    struct cudaMemPoolProps poolProps;
    const struct cudaMemAccessDesc *accessDescs;
    size_t accessDescCount;
    size_t bytesize;
    void *dptr;
};




enum __attribute__((device_builtin)) cudaGraphMemAttributeType {




    cudaGraphMemAttrUsedMemCurrent = 0x0,






    cudaGraphMemAttrUsedMemHigh = 0x1,






    cudaGraphMemAttrReservedMemCurrent = 0x2,






    cudaGraphMemAttrReservedMemHigh = 0x3
};





enum __attribute__((device_builtin)) cudaDeviceP2PAttr {
    cudaDevP2PAttrPerformanceRank = 1,
    cudaDevP2PAttrAccessSupported = 2,
    cudaDevP2PAttrNativeAtomicSupported = 3,
    cudaDevP2PAttrCudaArrayAccessSupported = 4
};






struct __attribute__((device_builtin)) CUuuid_st {
    char bytes[16];
};
typedef __attribute__((device_builtin)) struct CUuuid_st CUuuid;

typedef __attribute__((device_builtin)) struct CUuuid_st cudaUUID_t;




struct __attribute__((device_builtin)) cudaDeviceProp
{
    char name[256];
    cudaUUID_t uuid;
    char luid[8];
    unsigned int luidDeviceNodeMask;
    size_t totalGlobalMem;
    size_t sharedMemPerBlock;
    int regsPerBlock;
    int warpSize;
    size_t memPitch;
    int maxThreadsPerBlock;
    int maxThreadsDim[3];
    int maxGridSize[3];
    int clockRate;
    size_t totalConstMem;
    int major;
    int minor;
    size_t textureAlignment;
    size_t texturePitchAlignment;
    int deviceOverlap;
    int multiProcessorCount;
    int kernelExecTimeoutEnabled;
    int integrated;
    int canMapHostMemory;
    int computeMode;
    int maxTexture1D;
    int maxTexture1DMipmap;
    int maxTexture1DLinear;
    int maxTexture2D[2];
    int maxTexture2DMipmap[2];
    int maxTexture2DLinear[3];
    int maxTexture2DGather[2];
    int maxTexture3D[3];
    int maxTexture3DAlt[3];
    int maxTextureCubemap;
    int maxTexture1DLayered[2];
    int maxTexture2DLayered[3];
    int maxTextureCubemapLayered[2];
    int maxSurface1D;
    int maxSurface2D[2];
    int maxSurface3D[3];
    int maxSurface1DLayered[2];
    int maxSurface2DLayered[3];
    int maxSurfaceCubemap;
    int maxSurfaceCubemapLayered[2];
    size_t surfaceAlignment;
    int concurrentKernels;
    int ECCEnabled;
    int pciBusID;
    int pciDeviceID;
    int pciDomainID;
    int tccDriver;
    int asyncEngineCount;
    int unifiedAddressing;
    int memoryClockRate;
    int memoryBusWidth;
    int l2CacheSize;
    int persistingL2CacheMaxSize;
    int maxThreadsPerMultiProcessor;
    int streamPrioritiesSupported;
    int globalL1CacheSupported;
    int localL1CacheSupported;
    size_t sharedMemPerMultiprocessor;
    int regsPerMultiprocessor;
    int managedMemory;
    int isMultiGpuBoard;
    int multiGpuBoardGroupID;
    int hostNativeAtomicSupported;
    int singleToDoublePrecisionPerfRatio;
    int pageableMemoryAccess;
    int concurrentManagedAccess;
    int computePreemptionSupported;
    int canUseHostPointerForRegisteredMem;
    int cooperativeLaunch;
    int cooperativeMultiDeviceLaunch;
    size_t sharedMemPerBlockOptin;
    int pageableMemoryAccessUsesHostPageTables;
    int directManagedMemAccessFromHost;
    int maxBlocksPerMultiProcessor;
    int accessPolicyMaxWindowSize;
    size_t reservedSharedMemPerBlock;
};
# 2362 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef __attribute__((device_builtin)) struct __attribute__((device_builtin)) cudaIpcEventHandle_st
{
    char reserved[64];
}cudaIpcEventHandle_t;




typedef __attribute__((device_builtin)) struct __attribute__((device_builtin)) cudaIpcMemHandle_st
{
    char reserved[64];
}cudaIpcMemHandle_t;




enum __attribute__((device_builtin)) cudaExternalMemoryHandleType {



    cudaExternalMemoryHandleTypeOpaqueFd = 1,



    cudaExternalMemoryHandleTypeOpaqueWin32 = 2,



    cudaExternalMemoryHandleTypeOpaqueWin32Kmt = 3,



    cudaExternalMemoryHandleTypeD3D12Heap = 4,



    cudaExternalMemoryHandleTypeD3D12Resource = 5,



    cudaExternalMemoryHandleTypeD3D11Resource = 6,



    cudaExternalMemoryHandleTypeD3D11ResourceKmt = 7,



    cudaExternalMemoryHandleTypeNvSciBuf = 8
};
# 2453 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
struct __attribute__((device_builtin)) cudaExternalMemoryHandleDesc {



    enum cudaExternalMemoryHandleType type;
    union {





        int fd;
# 2480 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
        struct {



            void *handle;




            const void *name;
        } win32;




        const void *nvSciBufObject;
    } handle;



    unsigned long long size;



    unsigned int flags;
};




struct __attribute__((device_builtin)) cudaExternalMemoryBufferDesc {



    unsigned long long offset;



    unsigned long long size;



    unsigned int flags;
};




struct __attribute__((device_builtin)) cudaExternalMemoryMipmappedArrayDesc {




    unsigned long long offset;



    struct cudaChannelFormatDesc formatDesc;



    struct cudaExtent extent;




    unsigned int flags;



    unsigned int numLevels;
};




enum __attribute__((device_builtin)) cudaExternalSemaphoreHandleType {



    cudaExternalSemaphoreHandleTypeOpaqueFd = 1,



    cudaExternalSemaphoreHandleTypeOpaqueWin32 = 2,



    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,



    cudaExternalSemaphoreHandleTypeD3D12Fence = 4,



    cudaExternalSemaphoreHandleTypeD3D11Fence = 5,



     cudaExternalSemaphoreHandleTypeNvSciSync = 6,



    cudaExternalSemaphoreHandleTypeKeyedMutex = 7,



    cudaExternalSemaphoreHandleTypeKeyedMutexKmt = 8,



    cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,



    cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreHandleDesc {



    enum cudaExternalSemaphoreHandleType type;
    union {






        int fd;
# 2630 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
        struct {



            void *handle;




            const void *name;
        } win32;



        const void* nvSciSyncObj;
    } handle;



    unsigned int flags;
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreSignalParams_v1 {
    struct {



        struct {



            unsigned long long value;
        } fence;
        union {




            void *fence;
            unsigned long long reserved;
        } nvSciSync;



        struct {



            unsigned long long key;
        } keyedMutex;
    } params;
# 2694 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    unsigned int flags;
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreWaitParams_v1 {
    struct {



        struct {



            unsigned long long value;
        } fence;
        union {




            void *fence;
            unsigned long long reserved;
        } nvSciSync;



        struct {



            unsigned long long key;



            unsigned int timeoutMs;
        } keyedMutex;
    } params;
# 2743 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    unsigned int flags;
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreSignalParams{
    struct {



        struct {



            unsigned long long value;
        } fence;
        union {




            void *fence;
            unsigned long long reserved;
        } nvSciSync;



        struct {



            unsigned long long key;
        } keyedMutex;
        unsigned int reserved[12];
    } params;
# 2789 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    unsigned int flags;
    unsigned int reserved[16];
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreWaitParams {
    struct {



        struct {



            unsigned long long value;
        } fence;
        union {




            void *fence;
            unsigned long long reserved;
        } nvSciSync;



        struct {



            unsigned long long key;



            unsigned int timeoutMs;
        } keyedMutex;
        unsigned int reserved[10];
    } params;
# 2840 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
    unsigned int flags;
    unsigned int reserved[16];
};
# 2853 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef __attribute__((device_builtin)) enum cudaError cudaError_t;




typedef __attribute__((device_builtin)) struct CUstream_st *cudaStream_t;




typedef __attribute__((device_builtin)) struct CUevent_st *cudaEvent_t;




typedef __attribute__((device_builtin)) struct cudaGraphicsResource *cudaGraphicsResource_t;




typedef __attribute__((device_builtin)) enum cudaOutputMode cudaOutputMode_t;




typedef __attribute__((device_builtin)) struct CUexternalMemory_st *cudaExternalMemory_t;




typedef __attribute__((device_builtin)) struct CUexternalSemaphore_st *cudaExternalSemaphore_t;




typedef __attribute__((device_builtin)) struct CUgraph_st *cudaGraph_t;




typedef __attribute__((device_builtin)) struct CUgraphNode_st *cudaGraphNode_t;




typedef __attribute__((device_builtin)) struct CUuserObject_st *cudaUserObject_t;




typedef __attribute__((device_builtin)) struct CUfunc_st *cudaFunction_t;




typedef __attribute__((device_builtin)) struct CUmemPoolHandle_st *cudaMemPool_t;




enum __attribute__((device_builtin)) cudaCGScope {
    cudaCGScopeInvalid = 0,
    cudaCGScopeGrid = 1,
    cudaCGScopeMultiGrid = 2
};




struct __attribute__((device_builtin)) cudaLaunchParams
{
    void *func;
    dim3 gridDim;
    dim3 blockDim;
    void **args;
    size_t sharedMem;
    cudaStream_t stream;
};




struct __attribute__((device_builtin)) cudaKernelNodeParams {
    void* func;
    dim3 gridDim;
    dim3 blockDim;
    unsigned int sharedMemBytes;
    void **kernelParams;
    void **extra;
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreSignalNodeParams {
    cudaExternalSemaphore_t* extSemArray;
    const struct cudaExternalSemaphoreSignalParams* paramsArray;
    unsigned int numExtSems;
};




struct __attribute__((device_builtin)) cudaExternalSemaphoreWaitNodeParams {
    cudaExternalSemaphore_t* extSemArray;
    const struct cudaExternalSemaphoreWaitParams* paramsArray;
    unsigned int numExtSems;
};




enum __attribute__((device_builtin)) cudaGraphNodeType {
    cudaGraphNodeTypeKernel = 0x00,
    cudaGraphNodeTypeMemcpy = 0x01,
    cudaGraphNodeTypeMemset = 0x02,
    cudaGraphNodeTypeHost = 0x03,
    cudaGraphNodeTypeGraph = 0x04,
    cudaGraphNodeTypeEmpty = 0x05,
    cudaGraphNodeTypeWaitEvent = 0x06,
    cudaGraphNodeTypeEventRecord = 0x07,
    cudaGraphNodeTypeExtSemaphoreSignal = 0x08,
    cudaGraphNodeTypeExtSemaphoreWait = 0x09,
    cudaGraphNodeTypeMemAlloc = 0x0a,
    cudaGraphNodeTypeMemFree = 0x0b,
    cudaGraphNodeTypeCount
};




typedef struct CUgraphExec_st* cudaGraphExec_t;




enum __attribute__((device_builtin)) cudaGraphExecUpdateResult {
    cudaGraphExecUpdateSuccess = 0x0,
    cudaGraphExecUpdateError = 0x1,
    cudaGraphExecUpdateErrorTopologyChanged = 0x2,
    cudaGraphExecUpdateErrorNodeTypeChanged = 0x3,
    cudaGraphExecUpdateErrorFunctionChanged = 0x4,
    cudaGraphExecUpdateErrorParametersChanged = 0x5,
    cudaGraphExecUpdateErrorNotSupported = 0x6,
    cudaGraphExecUpdateErrorUnsupportedFunctionChange = 0x7,
    cudaGraphExecUpdateErrorAttributesChanged = 0x8
};





enum __attribute__((device_builtin)) cudaGetDriverEntryPointFlags {
    cudaEnableDefault = 0x0,
    cudaEnableLegacyStream = 0x1,
    cudaEnablePerThreadDefaultStream = 0x2
};




enum __attribute__((device_builtin)) cudaGraphDebugDotFlags {
    cudaGraphDebugDotFlagsVerbose = 1<<0,
    cudaGraphDebugDotFlagsKernelNodeParams = 1<<2,
    cudaGraphDebugDotFlagsMemcpyNodeParams = 1<<3,
    cudaGraphDebugDotFlagsMemsetNodeParams = 1<<4,
    cudaGraphDebugDotFlagsHostNodeParams = 1<<5,
    cudaGraphDebugDotFlagsEventNodeParams = 1<<6,
    cudaGraphDebugDotFlagsExtSemasSignalNodeParams = 1<<7,
    cudaGraphDebugDotFlagsExtSemasWaitNodeParams = 1<<8,
    cudaGraphDebugDotFlagsKernelNodeAttributes = 1<<9,
    cudaGraphDebugDotFlagsHandles = 1<<10
};




enum __attribute__((device_builtin)) cudaGraphInstantiateFlags {
    cudaGraphInstantiateFlagAutoFreeOnLaunch = 1

  , cudaGraphInstantiateFlagUseNodePriority = 8


};
# 3126 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef __attribute__((device_builtin)) enum cudaStreamAttrID {
    cudaStreamAttributeAccessPolicyWindow = 1,
    cudaStreamAttributeSynchronizationPolicy = 3
} cudaStreamAttrID;
# 3140 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef __attribute__((device_builtin)) union cudaStreamAttrValue {
    struct cudaAccessPolicyWindow accessPolicyWindow;
    enum cudaSynchronizationPolicy syncPolicy;
} cudaStreamAttrValue;
# 3152 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef __attribute__((device_builtin)) enum cudaKernelNodeAttrID {
    cudaKernelNodeAttributeAccessPolicyWindow = 1
  , cudaKernelNodeAttributeCooperative = 2

  , cudaKernelNodeAttributePriority = 8

} cudaKernelNodeAttrID;
# 3170 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h"
typedef __attribute__((device_builtin)) union cudaKernelNodeAttrValue {
    struct cudaAccessPolicyWindow accessPolicyWindow;
    int cooperative;

    int priority;

} cudaKernelNodeAttrValue;
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_types.h" 1
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_types.h"
enum __attribute__((device_builtin)) cudaSurfaceBoundaryMode
{
    cudaBoundaryModeZero = 0,
    cudaBoundaryModeClamp = 1,
    cudaBoundaryModeTrap = 2
};




enum __attribute__((device_builtin)) cudaSurfaceFormatMode
{
    cudaFormatModeForced = 0,
    cudaFormatModeAuto = 1
};




struct __attribute__((device_builtin)) surfaceReference
{



    struct cudaChannelFormatDesc channelDesc;
};




typedef __attribute__((device_builtin)) unsigned long long cudaSurfaceObject_t;
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_types.h" 1
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_types.h"
enum __attribute__((device_builtin)) cudaTextureAddressMode
{
    cudaAddressModeWrap = 0,
    cudaAddressModeClamp = 1,
    cudaAddressModeMirror = 2,
    cudaAddressModeBorder = 3
};




enum __attribute__((device_builtin)) cudaTextureFilterMode
{
    cudaFilterModePoint = 0,
    cudaFilterModeLinear = 1
};




enum __attribute__((device_builtin)) cudaTextureReadMode
{
    cudaReadModeElementType = 0,
    cudaReadModeNormalizedFloat = 1
};




struct __attribute__((device_builtin)) textureReference
{



    int normalized;



    enum cudaTextureFilterMode filterMode;



    enum cudaTextureAddressMode addressMode[3];



    struct cudaChannelFormatDesc channelDesc;



    int sRGB;



    unsigned int maxAnisotropy;



    enum cudaTextureFilterMode mipmapFilterMode;



    float mipmapLevelBias;



    float minMipmapLevelClamp;



    float maxMipmapLevelClamp;



    int disableTrilinearOptimization;
    int __cudaReserved[14];
};




struct __attribute__((device_builtin)) cudaTextureDesc
{



    enum cudaTextureAddressMode addressMode[3];



    enum cudaTextureFilterMode filterMode;



    enum cudaTextureReadMode readMode;



    int sRGB;



    float borderColor[4];



    int normalizedCoords;



    unsigned int maxAnisotropy;



    enum cudaTextureFilterMode mipmapFilterMode;



    float mipmapLevelBias;



    float minMipmapLevelClamp;



    float maxMipmapLevelClamp;



    int disableTrilinearOptimization;



    int seamlessCubemap;
};




typedef __attribute__((device_builtin)) unsigned long long cudaTextureObject_t;
# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 2
# 92 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/library_types.h" 1
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/library_types.h"
typedef enum cudaDataType_t
{
    CUDA_R_16F = 2,
    CUDA_C_16F = 6,
    CUDA_R_16BF = 14,
    CUDA_C_16BF = 15,
    CUDA_R_32F = 0,
    CUDA_C_32F = 4,
    CUDA_R_64F = 1,
    CUDA_C_64F = 5,
    CUDA_R_4I = 16,
    CUDA_C_4I = 17,
    CUDA_R_4U = 18,
    CUDA_C_4U = 19,
    CUDA_R_8I = 3,
    CUDA_C_8I = 7,
    CUDA_R_8U = 8,
    CUDA_C_8U = 9,
    CUDA_R_16I = 20,
    CUDA_C_16I = 21,
    CUDA_R_16U = 22,
    CUDA_C_16U = 23,
    CUDA_R_32I = 10,
    CUDA_C_32I = 11,
    CUDA_R_32U = 12,
    CUDA_C_32U = 13,
    CUDA_R_64I = 24,
    CUDA_C_64I = 25,
    CUDA_R_64U = 26,
    CUDA_C_64U = 27,




} cudaDataType;


typedef enum libraryPropertyType_t
{
    MAJOR_VERSION,
    MINOR_VERSION,
    PATCH_LEVEL
} libraryPropertyType;
# 93 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/channel_descriptor.h" 1
# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/channel_descriptor.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h" 1
# 147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 150 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h" 1
# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h"
extern "C" {


struct cudaFuncAttributes;


inline __attribute__((device)) cudaError_t cudaMalloc(void **p, size_t s)
{
  return cudaErrorUnknown;
}

inline __attribute__((device)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *p, const void *c)
{
  return cudaErrorUnknown;
}

inline __attribute__((device)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device)
{
  return cudaErrorUnknown;
}

inline __attribute__((device)) cudaError_t cudaGetDevice(int *device)
{
  return cudaErrorUnknown;
}

inline __attribute__((device)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize)
{
  return cudaErrorUnknown;
}

inline __attribute__((device)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize, unsigned int flags)
{
  return cudaErrorUnknown;
}



}
# 129 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 130 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h" 2






extern "C"
{
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
extern __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("Use of ""cudaDeviceSynchronize"" from device code is deprecated and will not be supported in a future release. Disable this warning with -D__CDPRT_SUPPRESS_SYNC_DEPRECATION_WARNING."))) cudaError_t cudaDeviceSynchronize(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t __cudaDeviceSynchronizeDeprecationAvoidance(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetLastError(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaPeekAtLastError(void);
extern __attribute__((device)) __attribute__((cudart_builtin)) const char* cudaGetErrorString(cudaError_t error);
extern __attribute__((device)) __attribute__((cudart_builtin)) const char* cudaGetErrorName(cudaError_t error);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceCount(int *count);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaGetDevice(int *device);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamDestroy(cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecordWithFlags_ptsz(cudaEvent_t event, cudaStream_t stream, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaEventDestroy(cudaEvent_t event);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFree(void *devPtr);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(void **devPtr, size_t size);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync_ptsz(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync_ptsz(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync_ptsz(const struct cudaMemcpy3DParms *p, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync_ptsz(void *devPtr, int value, size_t count, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync_ptsz(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync_ptsz(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);
# 196 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h"
extern __attribute__((device)) __attribute__((cudart_builtin)) void * cudaGetParameterBuffer(size_t alignment, size_t size);
# 224 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h"
extern __attribute__((device)) __attribute__((cudart_builtin)) void * cudaGetParameterBufferV2(void *func, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDevice_ptsz(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDeviceV2_ptsz(void *parameterBuffer, cudaStream_t stream);
# 244 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_device_runtime_api.h"
    extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDevice(void *func, void *parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned int sharedMemSize, cudaStream_t stream);
    extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaLaunchDeviceV2(void *parameterBuffer, cudaStream_t stream);


extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSmemSize, unsigned int flags);

extern __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long cudaCGGetIntrinsicHandle(enum cudaCGScope scope);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaCGSynchronize(unsigned long long handle, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaCGSynchronizeGrid(unsigned long long handle, unsigned int flags);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaCGGetSize(unsigned int *numThreads, unsigned int *numGrids, unsigned long long handle);
extern __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaCGGetRank(unsigned int *threadRank, unsigned int *gridRank, unsigned long long handle);
}

template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(T **devPtr, size_t size);
template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, T *entry);
template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize);
template <typename T> static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned int flags);
# 152 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h" 2
# 269 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern "C" {
# 309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceReset(void);
# 331 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceSynchronize(void);
# 418 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetLimit(enum cudaLimit limit, size_t value);
# 453 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetLimit(size_t *pValue, enum cudaLimit limit);
# 476 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements, const struct cudaChannelFormatDesc *fmtDesc, int device);
# 510 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetCacheConfig(enum cudaFuncCache *pCacheConfig);
# 547 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetStreamPriorityRange(int *leastPriority, int *greatestPriority);
# 591 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetCacheConfig(enum cudaFuncCache cacheConfig);
# 622 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetSharedMemConfig(enum cudaSharedMemConfig *pConfig);
# 666 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetSharedMemConfig(enum cudaSharedMemConfig config);
# 693 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetByPCIBusId(int *device, const char *pciBusId);
# 723 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetPCIBusId(char *pciBusId, int len, int device);
# 771 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t *handle, cudaEvent_t event);
# 812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcOpenEventHandle(cudaEvent_t *event, cudaIpcEventHandle_t handle);
# 855 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t *handle, void *devPtr);
# 919 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcOpenMemHandle(void **devPtr, cudaIpcMemHandle_t handle, unsigned int flags);
# 955 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaIpcCloseMemHandle(void *devPtr);
# 987 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceFlushGPUDirectRDMAWrites(enum cudaFlushGPUDirectRDMAWritesTarget target, enum cudaFlushGPUDirectRDMAWritesScope scope);
# 1031 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaThreadExit(void);
# 1057 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaThreadSynchronize(void);
# 1106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaThreadSetLimit(enum cudaLimit limit, size_t value);
# 1139 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaThreadGetLimit(size_t *pValue, enum cudaLimit limit);
# 1175 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaThreadGetCacheConfig(enum cudaFuncCache *pCacheConfig);
# 1222 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaThreadSetCacheConfig(enum cudaFuncCache cacheConfig);
# 1285 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetLastError(void);
# 1333 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaPeekAtLastError(void);
# 1349 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) const char* cudaGetErrorName(cudaError_t error);
# 1365 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) const char* cudaGetErrorString(cudaError_t error);
# 1393 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceCount(int *count);
# 1666 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDeviceProperties(struct cudaDeviceProp *prop, int device);
# 1868 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetAttribute(int *value, enum cudaDeviceAttr attr, int device);
# 1886 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetDefaultMemPool(cudaMemPool_t *memPool, int device);
# 1910 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetMemPool(int device, cudaMemPool_t memPool);
# 1930 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetMemPool(cudaMemPool_t *memPool, int device);
# 1978 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetNvSciSyncAttributes(void *nvSciSyncAttrList, int device, int flags);
# 2018 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaDeviceGetP2PAttribute(int *value, enum cudaDeviceP2PAttr attr, int srcDevice, int dstDevice);
# 2039 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaChooseDevice(int *device, const struct cudaDeviceProp *prop);
# 2083 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDevice(int device);
# 2104 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaGetDevice(int *device);
# 2135 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetValidDevices(int *device_arr, int len);
# 2200 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSetDeviceFlags( unsigned int flags );
# 2244 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetDeviceFlags( unsigned int *flags );
# 2284 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamCreate(cudaStream_t *pStream);
# 2316 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithFlags(cudaStream_t *pStream, unsigned int flags);
# 2362 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCreateWithPriority(cudaStream_t *pStream, unsigned int flags, int priority);
# 2389 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int *priority);
# 2414 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned int *flags);
# 2429 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCtxResetPersistingL2Cache(void);
# 2449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamCopyAttributes(cudaStream_t dst, cudaStream_t src);
# 2470 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamGetAttribute(
        cudaStream_t hStream, cudaStreamAttrID attr,
        cudaStreamAttrValue *value_out);
# 2494 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamSetAttribute(
        cudaStream_t hStream, cudaStreamAttrID attr,
        const cudaStreamAttrValue *value);
# 2528 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamDestroy(cudaStream_t stream);
# 2559 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned int flags = 0);







typedef void ( *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void *userData);
# 2634 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamAddCallback(cudaStream_t stream,
        cudaStreamCallback_t callback, void *userData, unsigned int flags);
# 2658 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamSynchronize(cudaStream_t stream);
# 2683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamQuery(cudaStream_t stream);
# 2767 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void *devPtr, size_t length = 0, unsigned int flags = 0x04);
# 2806 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamBeginCapture(cudaStream_t stream, enum cudaStreamCaptureMode mode);
# 2857 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaThreadExchangeStreamCaptureMode(enum cudaStreamCaptureMode *mode);
# 2885 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamEndCapture(cudaStream_t stream, cudaGraph_t *pGraph);
# 2923 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamIsCapturing(cudaStream_t stream, enum cudaStreamCaptureStatus *pCaptureStatus);
# 2955 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamGetCaptureInfo(cudaStream_t stream, enum cudaStreamCaptureStatus *pCaptureStatus, unsigned long long *pId);
# 3010 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamGetCaptureInfo_v2(cudaStream_t stream, enum cudaStreamCaptureStatus *captureStatus_out, unsigned long long *id_out = 0, cudaGraph_t *graph_out = 0, const cudaGraphNode_t **dependencies_out = 0, size_t *numDependencies_out = 0);
# 3043 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaStreamUpdateCaptureDependencies(cudaStream_t stream, cudaGraphNode_t *dependencies, size_t numDependencies, unsigned int flags = 0);
# 3080 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventCreate(cudaEvent_t *event);
# 3117 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventCreateWithFlags(cudaEvent_t *event, unsigned int flags);
# 3157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0);
# 3204 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream = 0, unsigned int flags = 0);
# 3236 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventQuery(cudaEvent_t event);
# 3266 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventSynchronize(cudaEvent_t event);
# 3295 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaEventDestroy(cudaEvent_t event);
# 3338 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaEventElapsedTime(float *ms, cudaEvent_t start, cudaEvent_t end);
# 3518 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaImportExternalMemory(cudaExternalMemory_t *extMem_out, const struct cudaExternalMemoryHandleDesc *memHandleDesc);
# 3573 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaExternalMemoryGetMappedBuffer(void **devPtr, cudaExternalMemory_t extMem, const struct cudaExternalMemoryBufferDesc *bufferDesc);
# 3635 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t *mipmap, cudaExternalMemory_t extMem, const struct cudaExternalMemoryMipmappedArrayDesc *mipmapDesc);
# 3659 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroyExternalMemory(cudaExternalMemory_t extMem);
# 3812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaImportExternalSemaphore(cudaExternalSemaphore_t *extSem_out, const struct cudaExternalSemaphoreHandleDesc *semHandleDesc);
# 3879 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaSignalExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t *extSemArray, const struct cudaExternalSemaphoreSignalParams *paramsArray, unsigned int numExtSems, cudaStream_t stream = 0);
# 3955 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaWaitExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t *extSemArray, const struct cudaExternalSemaphoreWaitParams *paramsArray, unsigned int numExtSems, cudaStream_t stream = 0);
# 3978 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem);
# 4045 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream);
# 4106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaLaunchCooperativeKernel(const void *func, dim3 gridDim, dim3 blockDim, void **args, size_t sharedMem, cudaStream_t stream);
# 4207 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaLaunchCooperativeKernelMultiDevice(struct cudaLaunchParams *launchParamsList, unsigned int numDevices, unsigned int flags = 0);
# 4254 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFuncSetCacheConfig(const void *func, enum cudaFuncCache cacheConfig);
# 4309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFuncSetSharedMemConfig(const void *func, enum cudaSharedMemConfig config);
# 4342 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFuncGetAttributes(struct cudaFuncAttributes *attr, const void *func);
# 4379 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFuncSetAttribute(const void *func, enum cudaFuncAttribute attr, int value);
# 4405 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaSetDoubleForDevice(double *d);
# 4429 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaSetDoubleForHost(double *d);
# 4497 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn, void *userData);
# 4554 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize);
# 4583 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyAvailableDynamicSMemPerBlock(size_t *dynamicSmemSize, const void *func, int numBlocks, int blockSize);
# 4628 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, const void *func, int blockSize, size_t dynamicSMemSize, unsigned int flags);
# 4749 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMallocManaged(void **devPtr, size_t size, unsigned int flags = 0x01);
# 4782 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMalloc(void **devPtr, size_t size);
# 4815 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocHost(void **ptr, size_t size);
# 4858 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocPitch(void **devPtr, size_t *pitch, size_t width, size_t height);
# 4912 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocArray(cudaArray_t *array, const struct cudaChannelFormatDesc *desc, size_t width, size_t height = 0, unsigned int flags = 0);
# 4950 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaFree(void *devPtr);
# 4973 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeHost(void *ptr);
# 4996 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeArray(cudaArray_t array);
# 5019 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray);
# 5085 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostAlloc(void **pHost, size_t size, unsigned int flags);
# 5178 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostRegister(void *ptr, size_t size, unsigned int flags);
# 5201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostUnregister(void *ptr);
# 5246 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostGetDevicePointer(void **pDevice, void *pHost, unsigned int flags);
# 5268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaHostGetFlags(unsigned int *pFlags, void *pHost);
# 5307 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMalloc3D(struct cudaPitchedPtr* pitchedDevPtr, struct cudaExtent extent);
# 5454 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMalloc3DArray(cudaArray_t *array, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int flags = 0);
# 5601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t *mipmappedArray, const struct cudaChannelFormatDesc* desc, struct cudaExtent extent, unsigned int numLevels, unsigned int flags = 0);
# 5634 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t *levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned int level);
# 5739 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3D(const struct cudaMemcpy3DParms *p);
# 5770 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3DPeer(const struct cudaMemcpy3DPeerParms *p);
# 5888 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy3DAsync(const struct cudaMemcpy3DParms *p, cudaStream_t stream = 0);
# 5914 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy3DPeerAsync(const struct cudaMemcpy3DPeerParms *p, cudaStream_t stream = 0);
# 5948 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemGetInfo(size_t *free, size_t *total);
# 5974 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaArrayGetInfo(struct cudaChannelFormatDesc *desc, struct cudaExtent *extent, unsigned int *flags, cudaArray_t array);
# 6003 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaArrayGetPlane(cudaArray_t *pPlaneArray, cudaArray_t hArray, unsigned int planeIdx);
# 6027 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaArrayGetMemoryRequirements(struct cudaArrayMemoryRequirements *memoryRequirements, cudaArray_t array, int device);
# 6051 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMipmappedArrayGetMemoryRequirements(struct cudaArrayMemoryRequirements *memoryRequirements, cudaMipmappedArray_t mipmap, int device);
# 6080 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaArrayGetSparseProperties(struct cudaArraySparseProperties *sparseProperties, cudaArray_t array);
# 6110 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaMipmappedArrayGetSparseProperties(struct cudaArraySparseProperties *sparseProperties, cudaMipmappedArray_t mipmap);
# 6155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind);
# 6190 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyPeer(void *dst, int dstDevice, const void *src, int srcDevice, size_t count);
# 6239 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2D(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
# 6289 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind);
# 6339 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DFromArray(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind);
# 6386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
# 6429 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToSymbol(const void *symbol, const void *src, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyHostToDevice);
# 6472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromSymbol(void *dst, const void *symbol, size_t count, size_t offset = 0, enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost);
# 6529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 6564 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyPeerAsync(void *dst, int dstDevice, const void *src, int srcDevice, size_t count, cudaStream_t stream = 0);
# 6627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemcpy2DAsync(void *dst, size_t dpitch, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 6685 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t spitch, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 6742 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpy2DFromArrayAsync(void *dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 6793 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyToSymbolAsync(const void *symbol, const void *src, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 6844 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemcpyFromSymbolAsync(void *dst, const void *symbol, size_t count, size_t offset, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 6873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset(void *devPtr, int value, size_t count);
# 6907 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset2D(void *devPtr, size_t pitch, int value, size_t width, size_t height);
# 6953 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemset3D(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent);
# 6989 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemsetAsync(void *devPtr, int value, size_t count, cudaStream_t stream = 0);
# 7030 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemset2DAsync(void *devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0);
# 7083 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaMemset3DAsync(struct cudaPitchedPtr pitchedDevPtr, int value, struct cudaExtent extent, cudaStream_t stream = 0);
# 7111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSymbolAddress(void **devPtr, const void *symbol);
# 7138 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSymbolSize(size_t *size, const void *symbol);
# 7208 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPrefetchAsync(const void *devPtr, size_t count, int dstDevice, cudaStream_t stream = 0);
# 7324 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemAdvise(const void *devPtr, size_t count, enum cudaMemoryAdvise advice, int device);
# 7383 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemRangeGetAttribute(void *data, size_t dataSize, enum cudaMemRangeAttribute attribute, const void *devPtr, size_t count);
# 7422 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemRangeGetAttributes(void **data, size_t *dataSizes, enum cudaMemRangeAttribute *attributes, size_t numAttributes, const void *devPtr, size_t count);
# 7482 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind);
# 7524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaMemcpyFromArray(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind);
# 7567 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, enum cudaMemcpyKind kind = cudaMemcpyDeviceToDevice);
# 7618 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 7668 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaMemcpyFromArrayAsync(void *dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream = 0);
# 7737 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocAsync(void **devPtr, size_t size, cudaStream_t hStream);
# 7763 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaFreeAsync(void *devPtr, cudaStream_t hStream);
# 7788 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolTrimTo(cudaMemPool_t memPool, size_t minBytesToKeep);
# 7832 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolSetAttribute(cudaMemPool_t memPool, enum cudaMemPoolAttr attr, void *value );
# 7880 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolGetAttribute(cudaMemPool_t memPool, enum cudaMemPoolAttr attr, void *value );
# 7895 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolSetAccess(cudaMemPool_t memPool, const struct cudaMemAccessDesc *descList, size_t count);
# 7908 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolGetAccess(enum cudaMemAccessFlags *flags, cudaMemPool_t memPool, struct cudaMemLocation *location);
# 7928 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolCreate(cudaMemPool_t *memPool, const struct cudaMemPoolProps *poolProps);
# 7950 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolDestroy(cudaMemPool_t memPool);
# 7986 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMallocFromPoolAsync(void **ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream);
# 8011 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolExportToShareableHandle(
    void *shareableHandle,
    cudaMemPool_t memPool,
    enum cudaMemAllocationHandleType handleType,
    unsigned int flags);
# 8038 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolImportFromShareableHandle(
    cudaMemPool_t *memPool,
    void *shareableHandle,
    enum cudaMemAllocationHandleType handleType,
    unsigned int flags);
# 8061 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolExportPointer(struct cudaMemPoolPtrExportData *exportData, void *ptr);
# 8090 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaMemPoolImportPointer(void **ptr, cudaMemPool_t memPool, struct cudaMemPoolPtrExportData *exportData);
# 8242 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaPointerGetAttributes(struct cudaPointerAttributes *attributes, const void *ptr);
# 8283 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceCanAccessPeer(int *canAccessPeer, int device, int peerDevice);
# 8325 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags);
# 8347 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceDisablePeerAccess(int peerDevice);
# 8411 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource);
# 8446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned int flags);
# 8485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);
# 8520 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t *resources, cudaStream_t stream = 0);
# 8552 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceGetMappedPointer(void **devPtr, size_t *size, cudaGraphicsResource_t resource);
# 8590 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t *array, cudaGraphicsResource_t resource, unsigned int arrayIndex, unsigned int mipLevel);
# 8619 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t *mipmappedArray, cudaGraphicsResource_t resource);
# 8690 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaBindTexture(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t size = 
# 8690 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h" 3 4
                                                                                                                                                                                                        (0x7fffffff * 2U + 1U)
# 8690 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
                                                                                                                                                                                                                      );
# 8749 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaBindTexture2D(size_t *offset, const struct textureReference *texref, const void *devPtr, const struct cudaChannelFormatDesc *desc, size_t width, size_t height, size_t pitch);
# 8787 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaBindTextureToArray(const struct textureReference *texref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
# 8827 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(const struct textureReference *texref, cudaMipmappedArray_const_t mipmappedArray, const struct cudaChannelFormatDesc *desc);
# 8853 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaUnbindTexture(const struct textureReference *texref);
# 8882 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaGetTextureAlignmentOffset(size_t *offset, const struct textureReference *texref);
# 8912 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaGetTextureReference(const struct textureReference **texref, const void *symbol);
# 8957 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaBindSurfaceToArray(const struct surfaceReference *surfref, cudaArray_const_t array, const struct cudaChannelFormatDesc *desc);
# 8982 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((deprecated)) __attribute__((host)) cudaError_t cudaGetSurfaceReference(const struct surfaceReference **surfref, const void *symbol);
# 9017 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetChannelDesc(struct cudaChannelFormatDesc *desc, cudaArray_const_t array);
# 9047 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) struct cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, enum cudaChannelFormatKind f);
# 9271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCreateTextureObject(cudaTextureObject_t *pTexObject, const struct cudaResourceDesc *pResDesc, const struct cudaTextureDesc *pTexDesc, const struct cudaResourceViewDesc *pResViewDesc);
# 9291 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject);
# 9311 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaTextureObject_t texObject);
# 9331 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectTextureDesc(struct cudaTextureDesc *pTexDesc, cudaTextureObject_t texObject);
# 9352 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetTextureObjectResourceViewDesc(struct cudaResourceViewDesc *pResViewDesc, cudaTextureObject_t texObject);
# 9397 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t *pSurfObject, const struct cudaResourceDesc *pResDesc);
# 9417 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject);
# 9436 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetSurfaceObjectResourceDesc(struct cudaResourceDesc *pResDesc, cudaSurfaceObject_t surfObject);
# 9470 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDriverGetVersion(int *driverVersion);
# 9495 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) __attribute__((cudart_builtin)) cudaError_t cudaRuntimeGetVersion(int *runtimeVersion);
# 9542 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphCreate(cudaGraph_t *pGraph, unsigned int flags);
# 9639 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddKernelNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaKernelNodeParams *pNodeParams);
# 9672 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphKernelNodeGetParams(cudaGraphNode_t node, struct cudaKernelNodeParams *pNodeParams);
# 9697 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphKernelNodeSetParams(cudaGraphNode_t node, const struct cudaKernelNodeParams *pNodeParams);
# 9717 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphKernelNodeCopyAttributes(
        cudaGraphNode_t hSrc,
        cudaGraphNode_t hDst);
# 9740 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphKernelNodeGetAttribute(
    cudaGraphNode_t hNode,
    cudaKernelNodeAttrID attr,
    cudaKernelNodeAttrValue *value_out);
# 9764 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphKernelNodeSetAttribute(
    cudaGraphNode_t hNode,
    cudaKernelNodeAttrID attr,
    const cudaKernelNodeAttrValue *value);
# 9814 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddMemcpyNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaMemcpy3DParms *pCopyParams);
# 9873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphAddMemcpyNodeToSymbol(
    cudaGraphNode_t *pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t *pDependencies,
    size_t numDependencies,
    const void* symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
# 9942 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphAddMemcpyNodeFromSymbol(
    cudaGraphNode_t* pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t* pDependencies,
    size_t numDependencies,
    void* dst,
    const void* symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
# 10010 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphAddMemcpyNode1D(
    cudaGraphNode_t *pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t *pDependencies,
    size_t numDependencies,
    void* dst,
    const void* src,
    size_t count,
    enum cudaMemcpyKind kind);
# 10042 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node, struct cudaMemcpy3DParms *pNodeParams);
# 10068 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node, const struct cudaMemcpy3DParms *pNodeParams);
# 10107 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphMemcpyNodeSetParamsToSymbol(
    cudaGraphNode_t node,
    const void* symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
# 10153 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphMemcpyNodeSetParamsFromSymbol(
    cudaGraphNode_t node,
    void* dst,
    const void* symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
# 10199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphMemcpyNodeSetParams1D(
    cudaGraphNode_t node,
    void* dst,
    const void* src,
    size_t count,
    enum cudaMemcpyKind kind);
# 10246 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddMemsetNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaMemsetParams *pMemsetParams);
# 10269 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphMemsetNodeGetParams(cudaGraphNode_t node, struct cudaMemsetParams *pNodeParams);
# 10292 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphMemsetNodeSetParams(cudaGraphNode_t node, const struct cudaMemsetParams *pNodeParams);
# 10333 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddHostNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaHostNodeParams *pNodeParams);
# 10356 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphHostNodeGetParams(cudaGraphNode_t node, struct cudaHostNodeParams *pNodeParams);
# 10379 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphHostNodeSetParams(cudaGraphNode_t node, const struct cudaHostNodeParams *pNodeParams);
# 10419 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddChildGraphNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, cudaGraph_t childGraph);
# 10446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node, cudaGraph_t *pGraph);
# 10483 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddEmptyNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies);
# 10526 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphAddEventRecordNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, cudaEvent_t event);
# 10553 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t node, cudaEvent_t *event_out);
# 10580 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event);
# 10626 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphAddEventWaitNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, cudaEvent_t event);
# 10653 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t node, cudaEvent_t *event_out);
# 10680 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event);
# 10729 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddExternalSemaphoresSignalNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaExternalSemaphoreSignalNodeParams *nodeParams);
# 10762 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExternalSemaphoresSignalNodeGetParams(cudaGraphNode_t hNode, struct cudaExternalSemaphoreSignalNodeParams *params_out);
# 10789 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExternalSemaphoresSignalNodeSetParams(cudaGraphNode_t hNode, const struct cudaExternalSemaphoreSignalNodeParams *nodeParams);
# 10838 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddExternalSemaphoresWaitNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, const struct cudaExternalSemaphoreWaitNodeParams *nodeParams);
# 10871 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExternalSemaphoresWaitNodeGetParams(cudaGraphNode_t hNode, struct cudaExternalSemaphoreWaitNodeParams *params_out);
# 10898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExternalSemaphoresWaitNodeSetParams(cudaGraphNode_t hNode, const struct cudaExternalSemaphoreWaitNodeParams *nodeParams);
# 10975 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddMemAllocNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, struct cudaMemAllocNodeParams *nodeParams);
# 11002 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphMemAllocNodeGetParams(cudaGraphNode_t node, struct cudaMemAllocNodeParams *params_out);
# 11062 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddMemFreeNode(cudaGraphNode_t *pGraphNode, cudaGraph_t graph, const cudaGraphNode_t *pDependencies, size_t numDependencies, void *dptr);
# 11086 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphMemFreeNodeGetParams(cudaGraphNode_t node, void *dptr_out);
# 11114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGraphMemTrim(int device);
# 11151 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceGetGraphMemAttribute(int device, enum cudaGraphMemAttributeType attr, void* value);
# 11185 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaDeviceSetGraphMemAttribute(int device, enum cudaGraphMemAttributeType attr, void* value);
# 11213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphClone(cudaGraph_t *pGraphClone, cudaGraph_t originalGraph);
# 11241 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphNodeFindInClone(cudaGraphNode_t *pNode, cudaGraphNode_t originalNode, cudaGraph_t clonedGraph);
# 11272 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphNodeGetType(cudaGraphNode_t node, enum cudaGraphNodeType *pType);
# 11303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t *nodes, size_t *numNodes);
# 11334 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphGetRootNodes(cudaGraph_t graph, cudaGraphNode_t *pRootNodes, size_t *pNumRootNodes);
# 11368 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t *from, cudaGraphNode_t *to, size_t *numEdges);
# 11399 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphNodeGetDependencies(cudaGraphNode_t node, cudaGraphNode_t *pDependencies, size_t *pNumDependencies);
# 11431 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphNodeGetDependentNodes(cudaGraphNode_t node, cudaGraphNode_t *pDependentNodes, size_t *pNumDependentNodes);
# 11462 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphAddDependencies(cudaGraph_t graph, const cudaGraphNode_t *from, const cudaGraphNode_t *to, size_t numDependencies);
# 11493 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphRemoveDependencies(cudaGraph_t graph, const cudaGraphNode_t *from, const cudaGraphNode_t *to, size_t numDependencies);
# 11523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphDestroyNode(cudaGraphNode_t node);
# 11561 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphInstantiate(cudaGraphExec_t *pGraphExec, cudaGraph_t graph, cudaGraphNode_t *pErrorNode, char *pLogBuffer, size_t bufferSize);
# 11611 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphInstantiateWithFlags(cudaGraphExec_t *pGraphExec, cudaGraph_t graph, unsigned long long flags);
# 11655 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaKernelNodeParams *pNodeParams);
# 11705 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaMemcpy3DParms *pNodeParams);
# 11760 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    const void* symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
# 11823 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    void* dst,
    const void* symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind);
# 11884 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphExecMemcpyNodeSetParams1D(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    void* dst,
    const void* src,
    size_t count,
    enum cudaMemcpyKind kind);
# 11938 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaMemsetParams *pNodeParams);
# 11977 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecHostNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const struct cudaHostNodeParams *pNodeParams);
# 12023 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, cudaGraph_t childGraph);
# 12067 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event);
# 12111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event);
# 12158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecExternalSemaphoresSignalNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const struct cudaExternalSemaphoreSignalNodeParams *nodeParams);
# 12205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecExternalSemaphoresWaitNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const struct cudaExternalSemaphoreWaitNodeParams *nodeParams);
# 12284 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphNodeSetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned int isEnabled);
# 12351 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphNodeGetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned int *isEnabled);
# 12510 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph, cudaGraphNode_t *hErrorNode_out, enum cudaGraphExecUpdateResult *updateResult_out);
# 12535 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
 extern __attribute__((host)) cudaError_t cudaGraphUpload(cudaGraphExec_t graphExec, cudaStream_t stream);
# 12566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream);
# 12589 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphExecDestroy(cudaGraphExec_t graphExec);
# 12610 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphDestroy(cudaGraph_t graph);
# 12629 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphDebugDotPrint(cudaGraph_t graph, const char *path, unsigned int flags);
# 12665 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaUserObjectCreate(cudaUserObject_t *object_out, void *ptr, cudaHostFn_t destroy, unsigned int initialRefcount, unsigned int flags);
# 12689 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaUserObjectRetain(cudaUserObject_t object, unsigned int count = 1);
# 12717 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaUserObjectRelease(cudaUserObject_t object, unsigned int count = 1);
# 12745 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphRetainUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned int count = 1, unsigned int flags = 0);
# 12770 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGraphReleaseUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned int count = 1);
# 12836 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetDriverEntryPoint(const char *symbol, void **funcPtr, unsigned long long flags);




extern __attribute__((host)) cudaError_t cudaGetExportTable(const void **ppExportTable, const cudaUUID_t *pExportTableId);
# 13017 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
extern __attribute__((host)) cudaError_t cudaGetFuncBySymbol(cudaFunction_t* functionPtr, const void* symbolPtr);
# 13175 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime_api.h"
}
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/channel_descriptor.h" 2
# 124 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/channel_descriptor.h"
template<class T> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
  return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf1(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf2(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescHalf4(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char>(void)
{
  int e = (int)sizeof(char) * 8;




  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);

}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<signed char>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned char>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char1>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar1>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char2>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar2>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<char4>(void)
{
  int e = (int)sizeof(signed char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uchar4>(void)
{
  int e = (int)sizeof(unsigned char) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned short>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short1>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort1>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short2>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort2>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<short4>(void)
{
  int e = (int)sizeof(short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<ushort4>(void)
{
  int e = (int)sizeof(unsigned short) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<unsigned int>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int1>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint1>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int2>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint2>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<int4>(void)
{
  int e = (int)sizeof(int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<uint4>(void)
{
  int e = (int)sizeof(unsigned int) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned);
}
# 396 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/channel_descriptor.h"
template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float1>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float2>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<float4>(void)
{
  int e = (int)sizeof(float) * 8;

  return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat);
}

static __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDescNV12(void)
{
    int e = (int)sizeof(char) * 8;

    return cudaCreateChannelDesc(e, e, e, 0, cudaChannelFormatKindNV12);
}

template<cudaChannelFormatKind> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc(void)
{
    return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X1>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedNormalized8X1);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X2>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedNormalized8X2);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized8X4>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindSignedNormalized8X4);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X1>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized8X1);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X2>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedNormalized8X2);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized8X4>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedNormalized8X4);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X1>(void)
{
    return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindSignedNormalized16X1);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X2>(void)
{
    return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindSignedNormalized16X2);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedNormalized16X4>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindSignedNormalized16X4);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X1>(void)
{
    return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized16X1);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X2>(void)
{
    return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindUnsignedNormalized16X2);
}

template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedNormalized16X4>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindUnsignedNormalized16X4);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindNV12>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 0, cudaChannelFormatKindNV12);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed1>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed1SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1SRGB);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed2>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed2SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2SRGB);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed3>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed3SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3SRGB);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed4>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed4);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed4>(void)
{
    return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedBlockCompressed4);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed5>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed5);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed5>(void)
{
    return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedBlockCompressed5);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed6H>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindUnsignedBlockCompressed6H);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindSignedBlockCompressed6H>(void)
{
    return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindSignedBlockCompressed6H);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed7>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7);
}


template<> __inline__ __attribute__((host)) cudaChannelFormatDesc cudaCreateChannelDesc<cudaChannelFormatKindUnsignedBlockCompressed7SRGB>(void)
{
    return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7SRGB);
}
# 96 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h" 1
# 53 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 54 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h" 2
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz)
{
  struct cudaPitchedPtr s;

  s.ptr = d;
  s.pitch = p;
  s.xsize = xsz;
  s.ysize = ysz;

  return s;
}
# 106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaPos make_cudaPos(size_t x, size_t y, size_t z)
{
  struct cudaPos p;

  p.x = x;
  p.y = y;
  p.z = z;

  return p;
}
# 132 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_functions.h"
static __inline__ __attribute__((host)) struct cudaExtent make_cudaExtent(size_t w, size_t h, size_t d)
{
  struct cudaExtent e;

  e.width = w;
  e.height = h;
  e.depth = d;

  return e;
}
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 101 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_functions.h" 1
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_functions.h"
static __inline__ __attribute__((host)) __attribute__((device)) char1 make_char1(signed char x);

static __inline__ __attribute__((host)) __attribute__((device)) uchar1 make_uchar1(unsigned char x);

static __inline__ __attribute__((host)) __attribute__((device)) char2 make_char2(signed char x, signed char y);

static __inline__ __attribute__((host)) __attribute__((device)) uchar2 make_uchar2(unsigned char x, unsigned char y);

static __inline__ __attribute__((host)) __attribute__((device)) char3 make_char3(signed char x, signed char y, signed char z);

static __inline__ __attribute__((host)) __attribute__((device)) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z);

static __inline__ __attribute__((host)) __attribute__((device)) char4 make_char4(signed char x, signed char y, signed char z, signed char w);

static __inline__ __attribute__((host)) __attribute__((device)) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w);

static __inline__ __attribute__((host)) __attribute__((device)) short1 make_short1(short x);

static __inline__ __attribute__((host)) __attribute__((device)) ushort1 make_ushort1(unsigned short x);

static __inline__ __attribute__((host)) __attribute__((device)) short2 make_short2(short x, short y);

static __inline__ __attribute__((host)) __attribute__((device)) ushort2 make_ushort2(unsigned short x, unsigned short y);

static __inline__ __attribute__((host)) __attribute__((device)) short3 make_short3(short x,short y, short z);

static __inline__ __attribute__((host)) __attribute__((device)) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z);

static __inline__ __attribute__((host)) __attribute__((device)) short4 make_short4(short x, short y, short z, short w);

static __inline__ __attribute__((host)) __attribute__((device)) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w);

static __inline__ __attribute__((host)) __attribute__((device)) int1 make_int1(int x);

static __inline__ __attribute__((host)) __attribute__((device)) uint1 make_uint1(unsigned int x);

static __inline__ __attribute__((host)) __attribute__((device)) int2 make_int2(int x, int y);

static __inline__ __attribute__((host)) __attribute__((device)) uint2 make_uint2(unsigned int x, unsigned int y);

static __inline__ __attribute__((host)) __attribute__((device)) int3 make_int3(int x, int y, int z);

static __inline__ __attribute__((host)) __attribute__((device)) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z);

static __inline__ __attribute__((host)) __attribute__((device)) int4 make_int4(int x, int y, int z, int w);

static __inline__ __attribute__((host)) __attribute__((device)) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w);

static __inline__ __attribute__((host)) __attribute__((device)) long1 make_long1(long int x);

static __inline__ __attribute__((host)) __attribute__((device)) ulong1 make_ulong1(unsigned long int x);

static __inline__ __attribute__((host)) __attribute__((device)) long2 make_long2(long int x, long int y);

static __inline__ __attribute__((host)) __attribute__((device)) ulong2 make_ulong2(unsigned long int x, unsigned long int y);

static __inline__ __attribute__((host)) __attribute__((device)) long3 make_long3(long int x, long int y, long int z);

static __inline__ __attribute__((host)) __attribute__((device)) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z);

static __inline__ __attribute__((host)) __attribute__((device)) long4 make_long4(long int x, long int y, long int z, long int w);

static __inline__ __attribute__((host)) __attribute__((device)) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w);

static __inline__ __attribute__((host)) __attribute__((device)) float1 make_float1(float x);

static __inline__ __attribute__((host)) __attribute__((device)) float2 make_float2(float x, float y);

static __inline__ __attribute__((host)) __attribute__((device)) float3 make_float3(float x, float y, float z);

static __inline__ __attribute__((host)) __attribute__((device)) float4 make_float4(float x, float y, float z, float w);

static __inline__ __attribute__((host)) __attribute__((device)) longlong1 make_longlong1(long long int x);

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong1 make_ulonglong1(unsigned long long int x);

static __inline__ __attribute__((host)) __attribute__((device)) longlong2 make_longlong2(long long int x, long long int y);

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y);

static __inline__ __attribute__((host)) __attribute__((device)) longlong3 make_longlong3(long long int x, long long int y, long long int z);

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z);

static __inline__ __attribute__((host)) __attribute__((device)) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w);

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w);

static __inline__ __attribute__((host)) __attribute__((device)) double1 make_double1(double x);

static __inline__ __attribute__((host)) __attribute__((device)) double2 make_double2(double x, double y);

static __inline__ __attribute__((host)) __attribute__((device)) double3 make_double3(double x, double y, double z);

static __inline__ __attribute__((host)) __attribute__((device)) double4 make_double4(double x, double y, double z, double w);




# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_functions.hpp" 1
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_functions.hpp"
static __inline__ __attribute__((host)) __attribute__((device)) char1 make_char1(signed char x)
{
  char1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar1 make_uchar1(unsigned char x)
{
  uchar1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char2 make_char2(signed char x, signed char y)
{
  char2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar2 make_uchar2(unsigned char x, unsigned char y)
{
  uchar2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char3 make_char3(signed char x, signed char y, signed char z)
{
  char3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z)
{
  uchar3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) char4 make_char4(signed char x, signed char y, signed char z, signed char w)
{
  char4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w)
{
  uchar4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short1 make_short1(short x)
{
  short1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort1 make_ushort1(unsigned short x)
{
  ushort1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short2 make_short2(short x, short y)
{
  short2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort2 make_ushort2(unsigned short x, unsigned short y)
{
  ushort2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short3 make_short3(short x,short y, short z)
{
  short3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z)
{
  ushort3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) short4 make_short4(short x, short y, short z, short w)
{
  short4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w)
{
  ushort4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int1 make_int1(int x)
{
  int1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint1 make_uint1(unsigned int x)
{
  uint1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int2 make_int2(int x, int y)
{
  int2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint2 make_uint2(unsigned int x, unsigned int y)
{
  uint2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int3 make_int3(int x, int y, int z)
{
  int3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint3 make_uint3(unsigned int x, unsigned int y, unsigned int z)
{
  uint3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) int4 make_int4(int x, int y, int z, int w)
{
  int4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) uint4 make_uint4(unsigned int x, unsigned int y, unsigned int z, unsigned int w)
{
  uint4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long1 make_long1(long int x)
{
  long1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong1 make_ulong1(unsigned long int x)
{
  ulong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long2 make_long2(long int x, long int y)
{
  long2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong2 make_ulong2(unsigned long int x, unsigned long int y)
{
  ulong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long3 make_long3(long int x, long int y, long int z)
{
  long3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong3 make_ulong3(unsigned long int x, unsigned long int y, unsigned long int z)
{
  ulong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) long4 make_long4(long int x, long int y, long int z, long int w)
{
  long4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulong4 make_ulong4(unsigned long int x, unsigned long int y, unsigned long int z, unsigned long int w)
{
  ulong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float1 make_float1(float x)
{
  float1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float2 make_float2(float x, float y)
{
  float2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float3 make_float3(float x, float y, float z)
{
  float3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) float4 make_float4(float x, float y, float z, float w)
{
  float4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong1 make_longlong1(long long int x)
{
  longlong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong1 make_ulonglong1(unsigned long long int x)
{
  ulonglong1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong2 make_longlong2(long long int x, long long int y)
{
  longlong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong2 make_ulonglong2(unsigned long long int x, unsigned long long int y)
{
  ulonglong2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong3 make_longlong3(long long int x, long long int y, long long int z)
{
  longlong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong3 make_ulonglong3(unsigned long long int x, unsigned long long int y, unsigned long long int z)
{
  ulonglong3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) longlong4 make_longlong4(long long int x, long long int y, long long int z, long long int w)
{
  longlong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) ulonglong4 make_ulonglong4(unsigned long long int x, unsigned long long int y, unsigned long long int z, unsigned long long int w)
{
  ulonglong4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double1 make_double1(double x)
{
  double1 t; t.x = x; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double2 make_double2(double x, double y)
{
  double2 t; t.x = x; t.y = y; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double3 make_double3(double x, double y, double z)
{
  double3 t; t.x = x; t.y = y; t.z = z; return t;
}

static __inline__ __attribute__((host)) __attribute__((device)) double4 make_double4(double x, double y, double z, double w)
{
  double4 t; t.x = x; t.y = y; t.z = z; t.w = w; return t;
}
# 173 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/vector_functions.h" 2
# 102 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 115 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 1
# 71 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 72 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2
# 85 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4

# 27 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 90 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 160 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 207 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 230 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 257 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 309 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 336 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 378 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 434 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 483 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 511 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 642 "/usr/include/string.h" 3 4
}
# 86 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 26 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 130 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 27 "/usr/include/bits/time.h" 2 3 4



struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 88 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 25 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 89 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 87 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2


# 88 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
extern "C"
{

extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) clock_t clock(void)




# 95 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 3 4
throw ()
# 95 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
      ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void* memset(void*, int, size_t) 
# 96 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 3 4
                                                                                                                   throw ()
# 96 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
                                                                                                                          ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void* memcpy(void*, const void*, size_t) 
# 97 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 3 4
                                                                                                                           throw ()
# 97 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
                                                                                                                                  ;

}
# 111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 1 3
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 3
       
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 278 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3

# 278 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 586 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 587 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 590 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 777 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/pstl_config.h" 1 3
# 778 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception.h" 1 3
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception.h" 3
       
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}

#pragma GCC visibility pop
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}



namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;
}
# 230 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/new" 3
#pragma GCC visibility pop
# 112 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2
# 125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"

# 125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* operator new(std:: size_t, void*) throw();
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* operator new[](std:: size_t, void*) throw();
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete(void*, void*) throw();
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete[](void*, void*) throw();

extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete(void*, std:: size_t) throw();
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete[](void*, std:: size_t) throw();




# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4

# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 33 "/usr/include/libio.h" 2 3 4
# 50 "/usr/include/libio.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stdarg.h" 1 3 4
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 51 "/usr/include/libio.h" 2 3 4
# 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 155 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 178 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 339 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 527 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 90 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 943 "/usr/include/stdio.h" 3 4
}
# 137 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdlib.h" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdlib.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
# 75 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4






# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/bits/byteswap.h" 2 3 4
# 44 "/usr/include/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 104 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 136 "/usr/include/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/bits/time.h" 1 3 4
# 46 "/usr/include/sys/select.h" 2 3 4
# 54 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/sys/select.h" 3 4
}
# 220 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 63 "/usr/include/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 212 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/sys/types.h" 2 3 4


}
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 492 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__, __alloc_size__ (2)));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 605 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 673 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 807 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 895 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 952 "/usr/include/stdlib.h" 2 3 4
# 964 "/usr/include/stdlib.h" 3 4
}
# 76 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_abs.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_abs.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_abs.h" 3
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 2 3
# 121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 138 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2






# 143 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
extern "C"
{
extern







__attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) int printf(const char*, ...);



extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* malloc(size_t) 
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 3 4
                                                                                    throw ()
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
                                                                                           ;
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void free(void*) 
# 158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 3 4
                                                                                 throw ()
# 158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
                                                                                        ;
# 168 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
}





# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4

# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 175 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2



# 177 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
extern "C"
{
# 205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void __assert_fail(
  const char *, const char *, unsigned int, const char *)
  
# 207 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 3 4
 throw ()
# 207 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
        ;




}
# 267 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* operator new(std:: size_t) ;
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* operator new[](std:: size_t) ;
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete(void*) throw();
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete[](void*) throw();

extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete(void*, std:: size_t) throw();
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete[](void*, std:: size_t) throw();



extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* operator new(std:: size_t, std::align_val_t);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void* operator new[](std:: size_t, std::align_val_t);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete(void*, std::align_val_t) noexcept;
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete[](void*, std::align_val_t) noexcept;
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete(void*, std:: size_t, std::align_val_t) noexcept;
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void operator delete[](void*, std:: size_t, std::align_val_t) noexcept;
# 303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 1
# 106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 107 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 108 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2







extern "C"
{
# 213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) int abs(int a) 
# 213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                        throw ()
# 213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                               ;







extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) long int labs(long int a) 
# 221 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                              throw ()
# 221 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                     ;







extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) long long int llabs(long long int a) 
# 229 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                                    throw ()
# 229 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                           ;
# 279 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fabs(double x) 
# 279 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 279 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 322 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fabsf(float x) 
# 322 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 322 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 332 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int min(const int a, const int b);






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned int umin(const unsigned int a, const unsigned int b);






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llmin(const long long int a, const long long int b);






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned long long int ullmin(const unsigned long long int a, const unsigned long long int b);
# 374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fminf(float x, float y) 
# 374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 394 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmin(double x, double y) 
# 394 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                   throw ()
# 394 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                          ;
# 407 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int max(const int a, const int b);







extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned int umax(const unsigned int a, const unsigned int b);






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llmax(const long long int a, const long long int b);






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) unsigned long long int ullmax(const unsigned long long int a, const unsigned long long int b);
# 450 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmaxf(float x, float y) 
# 450 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 450 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 470 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmax(double, double) 
# 470 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                               throw ()
# 470 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                      ;
# 514 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sin(double x) 
# 514 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 514 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 547 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cos(double x) 
# 547 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 547 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincos(double x, double *sptr, double *cptr) 
# 566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                                       throw ()
# 566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                              ;
# 582 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincosf(float x, float *sptr, float *cptr) 
# 582 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                                     throw ()
# 582 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                            ;
# 627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tan(double x) 
# 627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 696 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sqrt(double x) 
# 696 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 696 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 768 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rsqrt(double x);
# 838 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rsqrtf(float x);
# 894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log2(double x) 
# 894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 959 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp2(double x) 
# 959 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 959 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 1024 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float exp2f(float x) 
# 1024 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 1024 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 1091 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp10(double x) 
# 1091 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1091 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float exp10f(float x) 
# 1154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double expm1(double x) 
# 1247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1339 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float expm1f(float x) 
# 1339 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1339 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1395 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log2f(float x) 
# 1395 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 1395 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 1449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log10(double x) 
# 1449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1519 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log(double x) 
# 1519 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 1519 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 1615 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double log1p(double x) 
# 1615 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1615 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1714 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log1pf(float x) 
# 1714 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 1714 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 1778 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double floor(double x) 
# 1778 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                     throw ()
# 1778 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                            ;
# 1857 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double exp(double x) 
# 1857 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 1857 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 1898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cosh(double x) 
# 1898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 1898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 1948 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sinh(double x) 
# 1948 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 1948 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 1998 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tanh(double x) 
# 1998 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 1998 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 2053 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double acosh(double x) 
# 2053 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2053 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float acoshf(float x) 
# 2111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2164 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double asinh(double x) 
# 2164 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2164 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2217 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float asinhf(float x) 
# 2217 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2217 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atanh(double x) 
# 2271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2325 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atanhf(float x) 
# 2325 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2325 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double ldexp(double x, int exp) 
# 2374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                              throw ()
# 2374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                     ;
# 2420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ldexpf(float x, int exp) 
# 2420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                   throw ()
# 2420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                          ;
# 2472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double logb(double x) 
# 2472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 2472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 2527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float logbf(float x) 
# 2527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 2527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 2567 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int ilogb(double x) 
# 2567 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2567 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2607 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int ilogbf(float x) 
# 2607 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 2607 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 2683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double scalbn(double x, int n) 
# 2683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 2683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 2759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float scalbnf(float x, int n) 
# 2759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 2759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 2835 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double scalbln(double x, long int n) 
# 2835 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                        throw ()
# 2835 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                               ;
# 2911 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float scalblnf(float x, long int n) 
# 2911 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                        throw ()
# 2911 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                               ;
# 2988 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double frexp(double x, int *nptr) 
# 2988 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                                throw ()
# 2988 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                       ;
# 3062 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float frexpf(float x, int *nptr) 
# 3062 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                     throw ()
# 3062 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                            ;
# 3114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double round(double x) 
# 3114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 3114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 3169 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float roundf(float x) 
# 3169 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 3169 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 3187 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lround(double x) 
# 3187 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 3187 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 3205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lroundf(float x) 
# 3205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 3205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 3223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llround(double x) 
# 3223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                            throw ()
# 3223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                   ;
# 3241 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llroundf(float x) 
# 3241 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                            throw ()
# 3241 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                   ;
# 3315 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rint(double x) 
# 3315 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 3315 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 3369 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rintf(float x) 
# 3369 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 3369 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 3386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lrint(double x) 
# 3386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 3386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 3403 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long int lrintf(float x) 
# 3403 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 3403 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 3420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llrint(double x) 
# 3420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 3420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 3437 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) long long int llrintf(float x) 
# 3437 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 3437 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 3490 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nearbyint(double x) 
# 3490 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 3490 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 3543 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nearbyintf(float x) 
# 3543 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 3543 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 3605 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double ceil(double x) 
# 3605 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                    throw ()
# 3605 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                           ;
# 3655 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double trunc(double x) 
# 3655 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 3655 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 3708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float truncf(float x) 
# 3708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 3708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 3734 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fdim(double x, double y) 
# 3734 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                   throw ()
# 3734 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                          ;
# 3760 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fdimf(float x, float y) 
# 3760 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 3760 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 4060 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atan2(double y, double x) 
# 4060 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                    throw ()
# 4060 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                           ;
# 4131 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double atan(double x) 
# 4131 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 4131 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 4154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double acos(double x) 
# 4154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 4154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 4205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double asin(double x) 
# 4205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 4205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 4273 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double hypot(double x, double y) 
# 4273 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 4273 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 4328 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double rhypot(double x, double y) 
# 4328 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                     throw ()
# 4328 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                            ;
# 4396 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float hypotf(float x, float y) 
# 4396 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                            throw ()
# 4396 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                   ;
# 4451 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float rhypotf(float x, float y) 
# 4451 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                    throw ()
# 4451 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                           ;
# 4495 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double norm3d(double a, double b, double c) 
# 4495 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                           throw ()
# 4495 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                  ;
# 4546 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double rnorm3d(double a, double b, double c) 
# 4546 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                throw ()
# 4546 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                       ;
# 4595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double norm4d(double a, double b, double c, double d) 
# 4595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                                     throw ()
# 4595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                            ;
# 4651 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double rnorm4d(double a, double b, double c, double d) 
# 4651 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 4651 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 4708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern "C++" __attribute__((device)) __attribute__((device_builtin)) double norm(int dim, double const * p) 
# 4708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                   throw ()
# 4708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                          ;
# 4772 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double rnorm(int dim, double const * p) 
# 4772 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                            throw ()
# 4772 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                   ;
# 4837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float rnormf(int dim, float const * p) 
# 4837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                           throw ()
# 4837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                  ;
# 4894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern "C++" __attribute__((device)) __attribute__((device_builtin)) float normf(int dim, float const * p) 
# 4894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                  throw ()
# 4894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                         ;
# 4939 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float norm3df(float a, float b, float c) 
# 4939 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                             throw ()
# 4939 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                    ;
# 4990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float rnorm3df(float a, float b, float c) 
# 4990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                              throw ()
# 4990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                     ;
# 5039 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float norm4df(float a, float b, float c, float d) 
# 5039 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                      throw ()
# 5039 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                             ;
# 5095 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float rnorm4df(float a, float b, float c, float d) 
# 5095 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                       throw ()
# 5095 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                              ;
# 5182 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cbrt(double x) 
# 5182 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 5182 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 5268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cbrtf(float x) 
# 5268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 5268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 5323 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double rcbrt(double x);
# 5373 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float rcbrtf(float x);
# 5433 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double sinpi(double x);
# 5493 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinpif(float x);
# 5545 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double cospi(double x);
# 5597 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cospif(float x);
# 5627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincospi(double x, double *sptr, double *cptr);
# 5657 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) void sincospif(float x, float *sptr, float *cptr);
# 5990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double pow(double x, double y) 
# 5990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 5990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 6046 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double modf(double x, double *iptr) 
# 6046 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                                  throw ()
# 6046 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                         ;
# 6105 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fmod(double x, double y) 
# 6105 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                   throw ()
# 6105 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                          ;
# 6201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double remainder(double x, double y) 
# 6201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                        throw ()
# 6201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                               ;
# 6300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float remainderf(float x, float y) 
# 6300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                       throw ()
# 6300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                              ;
# 6372 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double remquo(double x, double y, int *quo) 
# 6372 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                               throw ()
# 6372 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                      ;
# 6444 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float remquof(float x, float y, int *quo) 
# 6444 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                              throw ()
# 6444 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                     ;
# 6485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double j0(double x) 
# 6485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 6485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 6527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float j0f(float x) 
# 6527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                       throw ()
# 6527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                              ;
# 6596 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double j1(double x) 
# 6596 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 6596 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 6665 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float j1f(float x) 
# 6665 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                       throw ()
# 6665 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                              ;
# 6708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double jn(int n, double x) 
# 6708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                         throw ()
# 6708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                ;
# 6751 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float jnf(int n, float x) 
# 6751 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 6751 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 6812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double y0(double x) 
# 6812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 6812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 6873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float y0f(float x) 
# 6873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                       throw ()
# 6873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                              ;
# 6934 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double y1(double x) 
# 6934 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 6934 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 6995 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float y1f(float x) 
# 6995 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                       throw ()
# 6995 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                              ;
# 7058 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double yn(int n, double x) 
# 7058 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                         throw ()
# 7058 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                ;
# 7121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ynf(int n, float x) 
# 7121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 7121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 7148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double cyl_bessel_i0(double x) 
# 7148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 7148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 7174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float cyl_bessel_i0f(float x) 
# 7174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                   throw ()
# 7174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                          ;
# 7201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double cyl_bessel_i1(double x) 
# 7201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                              throw ()
# 7201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                     ;
# 7227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float cyl_bessel_i1f(float x) 
# 7227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                   throw ()
# 7227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                          ;
# 7310 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erf(double x) 
# 7310 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 7310 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 7392 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erff(float x) 
# 7392 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 7392 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 7464 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfinv(double x);
# 7529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfinvf(float x);
# 7568 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfc(double x) 
# 7568 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 7568 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 7606 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcf(float x) 
# 7606 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 7606 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 7723 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double lgamma(double x) 
# 7723 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 7723 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 7785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfcinv(double x);
# 7840 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcinvf(float x);
# 7908 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double normcdfinv(double x);
# 7976 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normcdfinvf(float x);
# 8019 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double normcdf(double x);
# 8062 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float normcdff(float x);
# 8126 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double erfcx(double x);
# 8190 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float erfcxf(float x);
# 8309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float lgammaf(float x) 
# 8309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 8309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 8407 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double tgamma(double x) 
# 8407 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 8407 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 8505 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tgammaf(float x) 
# 8505 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 8505 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
# 8518 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double copysign(double x, double y) 
# 8518 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                       throw ()
# 8518 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                              ;
# 8531 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float copysignf(float x, float y) 
# 8531 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                      throw ()
# 8531 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                             ;
# 8550 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nextafter(double x, double y) 
# 8550 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                        throw ()
# 8550 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                               ;
# 8569 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nextafterf(float x, float y) 
# 8569 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                       throw ()
# 8569 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                              ;
# 8585 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double nan(const char *tagp) 
# 8585 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                throw ()
# 8585 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                       ;
# 8601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float nanf(const char *tagp) 
# 8601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                 throw ()
# 8601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                        ;






extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinff(float) 
# 8608 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 8608 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnanf(float) 
# 8609 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 8609 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 8619 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finite(double) 
# 8619 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 8619 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finitef(float) 
# 8620 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                           throw ()
# 8620 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                  ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbit(double) 
# 8621 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                            throw ()
# 8621 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                   ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnan(double) 
# 8622 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 8622 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinf(double) 
# 8623 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 8623 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;


extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbitf(float) 
# 8626 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                            throw ()
# 8626 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                   ;
# 8785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) double fma(double x, double y, double z) 
# 8785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                            throw ()
# 8785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                   ;
# 8943 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmaf(float x, float y, float z) 
# 8943 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                          throw ()
# 8943 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                                 ;
# 8954 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __signbitl(long double) 
# 8954 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 8954 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;





extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __finitel(long double) 
# 8960 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                 throw ()
# 8960 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                        ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isinfl(long double) 
# 8961 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                throw ()
# 8961 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                       ;
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) int __isnanl(long double) 
# 8962 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                throw ()
# 8962 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                       ;
# 9012 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float acosf(float x) 
# 9012 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 9012 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 9071 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float asinf(float x) 
# 9071 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 9071 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 9151 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atanf(float x) 
# 9151 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 9151 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 9448 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float atan2f(float y, float x) 
# 9448 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                   throw ()
# 9448 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                          ;
# 9482 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float cosf(float x) 
# 9482 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 9482 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 9524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinf(float x) 
# 9524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 9524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 9566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tanf(float x) 
# 9566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 9566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 9607 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float coshf(float x) 
# 9607 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 9607 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 9657 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sinhf(float x) 
# 9657 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 9657 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 9707 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float tanhf(float x) 
# 9707 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 9707 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 9759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float logf(float x) 
# 9759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 9759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 9839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float expf(float x) 
# 9839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                        throw ()
# 9839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                               ;
# 9891 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float log10f(float x) 
# 9891 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 9891 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 9946 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float modff(float x, float *iptr) 
# 9946 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                      throw ()
# 9946 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                             ;
# 10276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float powf(float x, float y) 
# 10276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                 throw ()
# 10276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                        ;
# 10345 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float sqrtf(float x) 
# 10345 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 10345 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 10404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float ceilf(float x) 
# 10404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                         throw ()
# 10404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                ;
# 10465 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float floorf(float x) 
# 10465 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                          throw ()
# 10465 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                 ;
# 10523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((device_builtin)) float fmodf(float x, float y) 
# 10523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 3 4
                                                                                                  throw ()
# 10523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
                                                                                                         ;
# 10538 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
}


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 1 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
       
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3

# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 270 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 287 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 423 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 532 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/type_traits.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/type_traits.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };


  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));


  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 29 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 34 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 40 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 43 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 28 "/usr/include/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 47 "/usr/include/math.h" 2 3 4
# 70 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 71 "/usr/include/math.h" 2 3 4
# 89 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 90 "/usr/include/math.h" 2 3 4
# 133 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 134 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
extern int signgam;
# 190 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 288 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 311 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 475 "/usr/include/math.h" 3 4
}
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 2 3
# 77 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }



  using ::isinf;






  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }



  using ::isnan;






  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1852 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }
# 1931 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3

}


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
#pragma GCC visibility push(default)
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 1 3
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functexcept.h" 1 3
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functexcept.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_defines.h" 1 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 135 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 236 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/numeric_traits.h" 3

}
# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 1 3
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 1 3
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    class reference_wrapper;
# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  using true_type = integral_constant<bool, true>;


  using false_type = integral_constant<bool, false>;



  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;






  template<bool __v>
    using bool_constant = integral_constant<bool, __v>;




  template<bool, typename, typename>
    struct conditional;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;




  template<typename... _Bn>
    struct conjunction
    : __and_<_Bn...>
    { };

  template<typename... _Bn>
    struct disjunction
    : __or_<_Bn...>
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };



  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };





  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 310 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 391 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };



  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 637 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 656 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };




  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };





  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };
# 842 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };



  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __bool_constant<__is_nothrow_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };



  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };



  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same(_Tp, _Up)>



    { };
# 1420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1518 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1742 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1818 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;




  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1946 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };

  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2082 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;





  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };



  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };




  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;




  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2261 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;






  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;





  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2655 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };







  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 2882 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop






  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Result, typename _Ret, typename = void>
    struct __is_nt_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_nt_invocable_impl<_Result, _Ret,
      __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>,
     __is_nothrow_convertible<typename _Result::type, _Ret>>
    { };



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3093 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_array_v = is_array<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v =
    is_lvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v =
    is_rvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    is_member_object_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    is_member_function_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_enum_v = is_enum<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_union_v = is_union<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_class_v = is_class<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_reference_v = is_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_const_v = is_const<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_volatile_v = is_volatile<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivial_v = is_trivial<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v =
    is_trivially_copyable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <typename _Tp>
 
  inline constexpr bool is_pod_v = is_pod<_Tp>::value;
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;
#pragma GCC diagnostic pop
 template <typename _Tp>
  inline constexpr bool is_empty_v = is_empty<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_abstract_v = is_abstract<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_final_v = is_final<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v =
    is_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_default_constructible_v =
    is_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v =
    is_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_constructible_v =
    is_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v =
    is_trivially_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v =
    is_trivially_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v =
    is_trivially_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v =
    is_trivially_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v =
    is_trivially_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v =
    is_trivially_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v =
    is_trivially_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v =
    is_nothrow_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v =
    is_nothrow_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v =
    is_nothrow_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v =
    is_nothrow_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v =
    is_nothrow_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v =
    is_nothrow_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v =
    is_nothrow_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v =
    has_virtual_destructor<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t rank_v = rank<_Tp>::value;
template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;

template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);




template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;





  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;





  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };


  template<typename _Tp>
    inline constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;
# 3597 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/type_traits" 3

}
# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 142 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 186 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 2 3
# 69 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;



  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 564 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_pair.h" 3

}
# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 1 3
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
       
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 209 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/concept_check.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/concept_check.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/concept_check.h" 3
# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/debug/assertions.h" 1 3
# 66 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (__builtin_is_constant_evaluated() && !bool(__n >= 0)) __builtin_unreachable(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 1 3
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ptr_traits.h" 1 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;

  template<typename _Ptr>
    struct __ptr_traits_elem_1
    { };

  template<template<typename, typename...> class _SomePointer, typename _Tp,
    typename... _Args>
    struct __ptr_traits_elem_1<_SomePointer<_Tp, _Args...>>
    {
      using element_type = _Tp;
      using pointer = _SomePointer<_Tp, _Args...>;

      static pointer
      pointer_to(__make_not_void<element_type>& __e)
      { return pointer::pointer_to(__e); }
    };

  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __ptr_traits_elem_1<_Ptr>
    { };

  template<typename _Ptr>
    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>
    {
      using element_type = typename _Ptr::element_type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_elem<_Ptr>
    {
    private:
      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 214 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ptr_traits.h" 3

}
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 2 3
# 87 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 126 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;
# 145 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;

      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
# 176 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator() : current() { }




      explicit constexpr
      reverse_iterator(iterator_type __x) : current(__x) { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>



 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.current) { }


      template<typename _Iter>




 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 {
   current = __x.current;
   return *this;
 }





      constexpr iterator_type
      base() const
      { return current; }
# 240 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      constexpr pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
# 394 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 417 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }




  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() <= __y.base(); }
# 558 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 599 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 630 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 670 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



     
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 717 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 733 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 773 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



     
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 820 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 840 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {







      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;


    public:

      typedef _Container container_type;
# 872 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 908 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



     
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 964 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline insert_iterator<_Container>
    inserter(_Container& __x, typename _Container::iterator __i)
    { return insert_iterator<_Container>(__x, __i); }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 986 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
       
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


   
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1308 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  namespace __detail
  {
# 1324 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  }
# 1335 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator



    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;

      using __base_ref = typename __traits_type::reference;


      template<typename _Iter2>
 friend class move_iterator;
# 1359 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
    public:
      using iterator_type = _Iterator;
# 1370 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>



 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>




 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }


      constexpr iterator_type
      base() const
      { return _M_current; }
# 1424 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
      constexpr reference
      operator*() const



      { return static_cast<reference>(*_M_current); }


      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      constexpr reference
      operator[](difference_type __n) const



      { return std::move(_M_current[__n]); }
# 1529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
    };

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
# 1548 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }
# 1599 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
# 2342 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
   
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<
    typename iterator_traits<_InputIterator>::value_type::first_type>;

  template<typename _InputIterator>
    using __iter_val_t =
    typename iterator_traits<_InputIterator>::value_type::second_type;

  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t =
    pair<add_const_t<__iter_key_t<_InputIterator>>,
  __iter_val_t<_InputIterator>>;



}
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/debug/debug.h" 1 3
# 48 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/predefined_ops.h" 1 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
# 105 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 149 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 182 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 198 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 251 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 275 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 297 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }

  template<typename _Ite, typename _Seq>
    _Ite
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&);




  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;





  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
   
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 608 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 641 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 845 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 881 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
# 943 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 989 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1041 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1141 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>

 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>

 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1487 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1543 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1574 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1664 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1697 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1729 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1764 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 1877 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1905 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1939 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1988 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2024 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2181 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



}
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 1 3
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
       
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
# 158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 796 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1635 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1667 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 1 3
# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/special_function_util.h" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/special_function_util.h" 3
  }





}
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 1 3
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 51 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 1 3
# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 52 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 1 3
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 153 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 191 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 219 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 266 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 314 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 399 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 433 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 492 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 561 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 661 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 701 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 53 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 1 3
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 54 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 1 3
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/legendre_function.tcc" 1 3
# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 56 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 1 3
# 51 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 57 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_hermite.tcc" 1 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 1 3
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 1 3
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 250 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 266 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 296 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 311 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 341 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 357 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 389 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 405 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 436 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 452 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 487 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 503 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 533 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 549 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 579 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 631 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 647 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 679 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 695 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 727 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 743 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 775 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 791 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 828 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 843 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 868 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 884 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 916 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 932 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 960 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 976 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1005 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1021 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1056 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1072 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1100 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1127 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1163 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1191 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1218 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
# 1294 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1305 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1325 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1342 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1353 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}


#pragma GCC visibility pop
# 1936 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 2 3


}
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 10542 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdlib.h" 1 3
# 10543 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 10546 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
# 10547 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2
# 10616 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"

# 10616 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
namespace std {
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool signbit(float x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool signbit(double x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool signbit(long double x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isfinite(float x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isfinite(double x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isfinite(long double x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isnan(float x);


__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(double x) throw();



__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isnan(long double x);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isinf(float x);


__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(double x) throw();



__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr bool isinf(long double x);
}
# 10792 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
namespace std
{
  template<typename T> extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) T __pow_helper(T, int);
  template<typename T> extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) T __cmath_power(T, unsigned int);
}

using std::abs;
using std::fabs;
using std::ceil;
using std::floor;
using std::sqrt;

using std::pow;

using std::log;
using std::log10;
using std::fmod;
using std::modf;
using std::exp;
using std::frexp;
using std::ldexp;
using std::asin;
using std::sin;
using std::sinh;
using std::acos;
using std::cos;
using std::cosh;
using std::atan;
using std::atan2;
using std::tan;
using std::tanh;
# 11193 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
namespace std {
# 11202 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long long int abs(long long int);
# 11212 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long int abs(long int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float abs(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double abs(double);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float fabs(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float ceil(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float floor(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sqrt(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float pow(float, float);




template<typename _Tp, typename _Up>
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin))
typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp, _Up);







extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float log(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float log10(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float fmod(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float modf(float, float*);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float exp(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float frexp(float, int*);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float ldexp(float, int);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float asin(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sin(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sinh(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float acos(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cos(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cosh(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float atan(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float atan2(float, float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float tan(float);
extern __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float tanh(float);
# 11329 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
}
# 11435 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
namespace std {
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float logb(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr int ilogb(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float scalbn(float a, int b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float scalbln(float a, long int b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float exp2(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float expm1(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float log2(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float log1p(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float acosh(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float asinh(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float atanh(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float hypot(float a, float b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float cbrt(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float erf(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float erfc(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float lgamma(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float tgamma(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float copysign(float a, float b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float nextafter(float a, float b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float remainder(float a, float b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float remquo(float a, float b, int *quo);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float round(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr long int lround(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr long long int llround(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float trunc(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float rint(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr long int lrint(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr long long int llrint(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float nearbyint(float a);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float fdim(float a, float b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float fma(float a, float b, float c);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float fmax(float a, float b);
__attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) constexpr float fmin(float a, float b);
}
# 11574 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float exp10(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float rsqrt(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float rcbrt(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float sinpi(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float cospi(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void sincospi(const float a, float *const sptr, float *const cptr);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) void sincos(const float a, float *const sptr, float *const cptr);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float j0(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float j1(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float jn(const int n, const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float y0(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float y1(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float yn(const int n, const float a);

static inline __attribute__((device)) __attribute__((cudart_builtin)) float cyl_bessel_i0(const float a);

static inline __attribute__((device)) __attribute__((cudart_builtin)) float cyl_bessel_i1(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float erfinv(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float erfcinv(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float normcdfinv(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float normcdf(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float erfcx(const float a);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double copysign(const double a, const float b);

static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double copysign(const float a, const double b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned int min(const unsigned int a, const unsigned int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned int min(const int a, const unsigned int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned int min(const unsigned int a, const int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long int min(const long int a, const long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long int min(const unsigned long int a, const unsigned long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long int min(const long int a, const unsigned long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long int min(const unsigned long int a, const long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long long int min(const long long int a, const long long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int min(const unsigned long long int a, const unsigned long long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int min(const long long int a, const unsigned long long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int min(const unsigned long long int a, const long long int b);
# 11715 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float min(const float a, const float b);
# 11726 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double min(const double a, const double b);
# 11736 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double min(const float a, const double b);
# 11746 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double min(const double a, const float b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned int max(const unsigned int a, const unsigned int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned int max(const int a, const unsigned int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned int max(const unsigned int a, const int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long int max(const long int a, const long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long int max(const unsigned long int a, const unsigned long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long int max(const long int a, const unsigned long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long int max(const unsigned long int a, const long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) long long int max(const long long int a, const long long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int max(const unsigned long long int a, const unsigned long long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int max(const long long int a, const unsigned long long int b);







static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) unsigned long long int max(const unsigned long long int a, const long long int b);
# 11845 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) float max(const float a, const float b);
# 11856 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double max(const double a, const double b);
# 11866 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double max(const float a, const double b);
# 11876 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
static inline __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) double max(const double a, const float b);
# 11887 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
extern "C"{
inline __attribute__((device)) void *__nv_aligned_device_malloc(size_t size, size_t align)
{
  __attribute__((device)) void *__nv_aligned_device_malloc_impl(size_t, size_t);
  return __nv_aligned_device_malloc_impl(size, align);
}
}
# 12173 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.hpp" 1
# 77 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.hpp"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 78 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.hpp" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.hpp" 2
# 174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.hpp"
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isnan(const double a) throw() { return __isnan(a); }
__inline__ __attribute__((always_inline)) __attribute__((host)) __attribute__((device)) __attribute__((cudart_builtin)) int isinf(const double x) throw() { return __isinf(x); }
# 758 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.hpp"
static inline __attribute__((host)) __attribute__((device)) float exp10(const float a)
{
  return exp10f(a);
}

static inline __attribute__((host)) __attribute__((device)) float rsqrt(const float a)
{
  return rsqrtf(a);
}

static inline __attribute__((host)) __attribute__((device)) float rcbrt(const float a)
{
  return rcbrtf(a);
}

static inline __attribute__((host)) __attribute__((device)) float sinpi(const float a)
{
  return sinpif(a);
}

static inline __attribute__((host)) __attribute__((device)) float cospi(const float a)
{
  return cospif(a);
}

static inline __attribute__((host)) __attribute__((device)) void sincospi(const float a, float *const sptr, float *const cptr)
{
  sincospif(a, sptr, cptr);
}

static inline __attribute__((host)) __attribute__((device)) void sincos(const float a, float *const sptr, float *const cptr)
{
  sincosf(a, sptr, cptr);
}

static inline __attribute__((host)) __attribute__((device)) float j0(const float a)
{
  return j0f(a);
}

static inline __attribute__((host)) __attribute__((device)) float j1(const float a)
{
  return j1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float jn(const int n, const float a)
{
  return jnf(n, a);
}

static inline __attribute__((host)) __attribute__((device)) float y0(const float a)
{
  return y0f(a);
}

static inline __attribute__((host)) __attribute__((device)) float y1(const float a)
{
  return y1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float yn(const int n, const float a)
{
  return ynf(n, a);
}

static inline __attribute__((device)) float cyl_bessel_i0(const float a)
{
  return cyl_bessel_i0f(a);
}

static inline __attribute__((device)) float cyl_bessel_i1(const float a)
{
  return cyl_bessel_i1f(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfinv(const float a)
{
  return erfinvf(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfcinv(const float a)
{
  return erfcinvf(a);
}

static inline __attribute__((host)) __attribute__((device)) float normcdfinv(const float a)
{
  return normcdfinvf(a);
}

static inline __attribute__((host)) __attribute__((device)) float normcdf(const float a)
{
  return normcdff(a);
}

static inline __attribute__((host)) __attribute__((device)) float erfcx(const float a)
{
  return erfcxf(a);
}

static inline __attribute__((host)) __attribute__((device)) double copysign(const double a, const float b)
{
  return copysign(a, static_cast<double>(b));
}

static inline __attribute__((host)) __attribute__((device)) double copysign(const float a, const double b)
{
  return copysign(static_cast<double>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int min(const unsigned int a, const unsigned int b)
{
  return umin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int min(const int a, const unsigned int b)
{
  return umin(static_cast<unsigned int>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int min(const unsigned int a, const int b)
{
  return umin(a, static_cast<unsigned int>(b));
}

static inline __attribute__((host)) __attribute__((device)) long int min(const long int a, const long int b)
{
  long int retval;





  if (sizeof(long int) == sizeof(int)) {



    retval = static_cast<long int>(min(static_cast<int>(a), static_cast<int>(b)));
  } else {
    retval = static_cast<long int>(llmin(static_cast<long long int>(a), static_cast<long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(const unsigned long int a, const unsigned long int b)
{
  unsigned long int retval;



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    retval = static_cast<unsigned long int>(umin(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmin(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(const long int a, const unsigned long int b)
{
  unsigned long int retval;



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    retval = static_cast<unsigned long int>(umin(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmin(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int min(const unsigned long int a, const long int b)
{
  unsigned long int retval;



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    retval = static_cast<unsigned long int>(umin(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmin(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) long long int min(const long long int a, const long long int b)
{
  return llmin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(const unsigned long long int a, const unsigned long long int b)
{
  return ullmin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(const long long int a, const unsigned long long int b)
{
  return ullmin(static_cast<unsigned long long int>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int min(const unsigned long long int a, const long long int b)
{
  return ullmin(a, static_cast<unsigned long long int>(b));
}

static inline __attribute__((host)) __attribute__((device)) float min(const float a, const float b)
{
  return fminf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double min(const double a, const double b)
{
  return fmin(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double min(const float a, const double b)
{
  return fmin(static_cast<double>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) double min(const double a, const float b)
{
  return fmin(a, static_cast<double>(b));
}

static inline __attribute__((host)) __attribute__((device)) unsigned int max(const unsigned int a, const unsigned int b)
{
  return umax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int max(const int a, const unsigned int b)
{
  return umax(static_cast<unsigned int>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned int max(const unsigned int a, const int b)
{
  return umax(a, static_cast<unsigned int>(b));
}

static inline __attribute__((host)) __attribute__((device)) long int max(const long int a, const long int b)
{
  long int retval;




  if (sizeof(long int) == sizeof(int)) {



    retval = static_cast<long int>(max(static_cast<int>(a), static_cast<int>(b)));
  } else {
    retval = static_cast<long int>(llmax(static_cast<long long int>(a), static_cast<long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(const unsigned long int a, const unsigned long int b)
{
  unsigned long int retval;



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    retval = static_cast<unsigned long int>(umax(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmax(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(const long int a, const unsigned long int b)
{
  unsigned long int retval;



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    retval = static_cast<unsigned long int>(umax(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmax(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) unsigned long int max(const unsigned long int a, const long int b)
{
  unsigned long int retval;



  if (sizeof(unsigned long int) == sizeof(unsigned int)) {



    retval = static_cast<unsigned long int>(umax(static_cast<unsigned int>(a), static_cast<unsigned int>(b)));
  } else {
    retval = static_cast<unsigned long int>(ullmax(static_cast<unsigned long long int>(a), static_cast<unsigned long long int>(b)));
  }
  return retval;
}

static inline __attribute__((host)) __attribute__((device)) long long int max(const long long int a, const long long int b)
{
  return llmax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(const unsigned long long int a, const unsigned long long int b)
{
  return ullmax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(const long long int a, const unsigned long long int b)
{
  return ullmax(static_cast<unsigned long long int>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) unsigned long long int max(const unsigned long long int a, const long long int b)
{
  return ullmax(a, static_cast<unsigned long long int>(b));
}

static inline __attribute__((host)) __attribute__((device)) float max(const float a, const float b)
{
  return fmaxf(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double max(const double a, const double b)
{
  return fmax(a, b);
}

static inline __attribute__((host)) __attribute__((device)) double max(const float a, const double b)
{
  return fmax(static_cast<double>(a), b);
}

static inline __attribute__((host)) __attribute__((device)) double max(const double a, const float b)
{
  return fmax(a, static_cast<double>(b));
}
# 12174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/math_functions.h" 2
# 304 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/common_functions.h" 2
# 116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_surface_types.h" 1
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_surface_types.h"
template<class T, int dim = 1>
struct __attribute__((device_builtin_surface_type)) surface : public surfaceReference
{

  __attribute__((host)) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<T>();
  }

  __attribute__((host)) surface(struct cudaChannelFormatDesc desc)
  {
    channelDesc = desc;
  }

};

template<int dim>
struct __attribute__((device_builtin_surface_type)) surface<void, dim> : public surfaceReference
{

  __attribute__((host)) surface(void)
  {
    channelDesc = cudaCreateChannelDesc<void>();
  }

};
# 117 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_texture_types.h" 1
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_texture_types.h"
template<class T, int texType = 0x01, enum cudaTextureReadMode mode = cudaReadModeElementType>
struct __attribute__((device_builtin_texture_type)) texture : public textureReference
{

  __attribute__((host)) texture(int norm = 0,
                   enum cudaTextureFilterMode fMode = cudaFilterModePoint,
                   enum cudaTextureAddressMode aMode = cudaAddressModeClamp)
  {
    normalized = norm;
    filterMode = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc = cudaCreateChannelDesc<T>();
    sRGB = 0;
  }

  __attribute__((host)) texture(int norm,
                   enum cudaTextureFilterMode fMode,
                   enum cudaTextureAddressMode aMode,
                   struct cudaChannelFormatDesc desc)
  {
    normalized = norm;
    filterMode = fMode;
    addressMode[0] = aMode;
    addressMode[1] = aMode;
    addressMode[2] = aMode;
    channelDesc = desc;
    sRGB = 0;
  }

};
# 118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 1
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_types.h" 1
# 81 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 82 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2







extern "C"
{
# 100 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __mulhi(int x, int y);
# 110 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __umulhi(unsigned int x, unsigned int y);
# 120 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __mul64hi(long long int x, long long int y);
# 130 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __umul64hi(unsigned long long int x, unsigned long long int y);
# 139 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int_as_float(int x);
# 148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float_as_int(float x);
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint_as_float(unsigned int x);
# 166 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float_as_uint(float x);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __syncthreads(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __prof_trigger(int);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __threadfence(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __threadfence_block(void);
__attribute__((device)) __attribute__((cudart_builtin))

__attribute__((__noreturn__))



__attribute__((device_builtin)) void __trap(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) void __brkpt();
# 201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __saturatef(float x);
# 270 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __sad(int x, int y, unsigned int z);
# 338 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __usad(unsigned int x, unsigned int y, unsigned int z);
# 348 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __mul24(int x, int y);
# 358 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __umul24(unsigned int x, unsigned int y);
# 371 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float fdividef(float x, float y);
# 444 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdividef(float x, float y);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) double fdivide(double x, double y);
# 457 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __sinf(float x) 
# 457 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                      throw ()
# 457 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                             ;
# 468 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __cosf(float x) 
# 468 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                      throw ()
# 468 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                             ;
# 481 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __tanf(float x) 
# 481 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                      throw ()
# 481 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                             ;
# 496 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) void __sincosf(float x, float *sptr, float *cptr) 
# 496 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                                                   throw ()
# 496 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                                                          ;
# 545 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __expf(float x) 
# 545 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                      throw ()
# 545 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                             ;
# 576 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __exp10f(float x) 
# 576 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                        throw ()
# 576 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                               ;
# 601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __log2f(float x) 
# 601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                       throw ()
# 601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                              ;
# 628 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __log10f(float x) 
# 628 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                        throw ()
# 628 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                               ;
# 671 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __logf(float x) 
# 671 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                      throw ()
# 671 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                             ;
# 713 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) __attribute__((cudart_builtin)) float __powf(float x, float y) 
# 713 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 3 4
                                                                                                               throw ()
# 713 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
                                                                                                                      ;
# 722 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_rn(float x);
# 731 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_rz(float x);
# 740 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_ru(float);
# 749 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __float2int_rd(float x);
# 758 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_rn(float x);
# 767 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_rz(float x);
# 776 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_ru(float x);
# 785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __float2uint_rd(float x);
# 794 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_rn(int x);
# 803 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_rz(int x);
# 812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_ru(int x);
# 821 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __int2float_rd(int x);
# 830 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_rn(unsigned int x);
# 839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_rz(unsigned int x);
# 848 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_ru(unsigned int x);
# 857 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __uint2float_rd(unsigned int x);
# 866 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_rn(float x);
# 875 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_rz(float x);
# 884 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_ru(float x);
# 893 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __float2ll_rd(float x);
# 902 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_rn(float x);
# 911 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_rz(float x);
# 920 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_ru(float x);
# 929 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __float2ull_rd(float x);
# 938 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_rn(long long int x);
# 947 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_rz(long long int x);
# 956 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_ru(long long int x);
# 965 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ll2float_rd(long long int x);
# 974 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_rn(unsigned long long int x);
# 983 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_rz(unsigned long long int x);
# 992 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_ru(unsigned long long int x);
# 1001 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __ull2float_rd(unsigned long long int x);
# 1013 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_rn(float x, float y);
# 1025 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_rz(float x, float y);
# 1037 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_ru(float x, float y);
# 1049 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fadd_rd(float x, float y);
# 1061 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_rn(float x, float y);
# 1073 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_rz(float x, float y);
# 1085 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_ru(float x, float y);
# 1097 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsub_rd(float x, float y);
# 1109 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_rn(float x, float y);
# 1121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_rz(float x, float y);
# 1133 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_ru(float x, float y);
# 1145 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmul_rd(float x, float y);
# 1298 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_rn(float x, float y, float z);
# 1451 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_rz(float x, float y, float z);
# 1604 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_ru(float x, float y, float z);
# 1757 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fmaf_rd(float x, float y, float z);
# 1790 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_rn(float x);
# 1823 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_rz(float x);
# 1856 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_ru(float x);
# 1889 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frcp_rd(float x);
# 1920 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_rn(float x);
# 1951 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_rz(float x);
# 1982 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_ru(float x);
# 2013 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fsqrt_rd(float x);
# 2052 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __frsqrt_rn(float x);
# 2063 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_rn(float x, float y);
# 2074 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_rz(float x, float y);
# 2085 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_ru(float x, float y);
# 2096 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) float __fdiv_rd(float x, float y);
# 2105 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __clz(int x);
# 2116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __ffs(int x);
# 2125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __popc(unsigned int x);
# 2134 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __brev(unsigned int x);
# 2143 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __clzll(long long int x);
# 2154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __ffsll(long long int x);
# 2165 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __popcll(unsigned long long int x);
# 2174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __brevll(unsigned long long int x);
# 2198 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __byte_perm(unsigned int x, unsigned int y, unsigned int s);
# 2210 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __hadd(int x, int y);
# 2223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __rhadd(int x, int y);
# 2235 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __uhadd(unsigned int x, unsigned int y);
# 2248 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __urhadd(unsigned int x, unsigned int y);
# 2258 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) int __double2int_rz(double x);
# 2267 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __double2uint_rz(double x);
# 2276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) long long int __double2ll_rz(double x);
# 2285 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned long long int __double2ull_rz(double x);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm0(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm1(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm2(void);
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __pm3(void);
# 2315 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabs2(unsigned int a);
# 2326 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsss2(unsigned int a);
# 2337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vadd2(unsigned int a, unsigned int b);
# 2348 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddss2 (unsigned int a, unsigned int b);
# 2358 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddus2 (unsigned int a, unsigned int b);
# 2369 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgs2(unsigned int a, unsigned int b);
# 2380 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgu2(unsigned int a, unsigned int b);
# 2391 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vhaddu2(unsigned int a, unsigned int b);
# 2402 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpeq2(unsigned int a, unsigned int b);
# 2413 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpges2(unsigned int a, unsigned int b);
# 2424 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgeu2(unsigned int a, unsigned int b);
# 2435 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgts2(unsigned int a, unsigned int b);
# 2446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgtu2(unsigned int a, unsigned int b);
# 2457 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmples2(unsigned int a, unsigned int b);
# 2469 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpleu2(unsigned int a, unsigned int b);
# 2480 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmplts2(unsigned int a, unsigned int b);
# 2491 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpltu2(unsigned int a, unsigned int b);
# 2502 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpne2(unsigned int a, unsigned int b);
# 2513 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffu2(unsigned int a, unsigned int b);
# 2524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxs2(unsigned int a, unsigned int b);
# 2535 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxu2(unsigned int a, unsigned int b);
# 2546 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmins2(unsigned int a, unsigned int b);
# 2557 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vminu2(unsigned int a, unsigned int b);
# 2568 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vseteq2(unsigned int a, unsigned int b);
# 2579 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetges2(unsigned int a, unsigned int b);
# 2590 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgeu2(unsigned int a, unsigned int b);
# 2601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgts2(unsigned int a, unsigned int b);
# 2612 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgtu2(unsigned int a, unsigned int b);
# 2623 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetles2(unsigned int a, unsigned int b);
# 2634 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetleu2(unsigned int a, unsigned int b);
# 2645 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetlts2(unsigned int a, unsigned int b);
# 2656 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetltu2(unsigned int a, unsigned int b);
# 2667 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetne2(unsigned int a, unsigned int b);
# 2678 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsadu2(unsigned int a, unsigned int b);
# 2689 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsub2(unsigned int a, unsigned int b);
# 2700 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubss2 (unsigned int a, unsigned int b);
# 2711 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubus2 (unsigned int a, unsigned int b);
# 2721 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vneg2(unsigned int a);
# 2731 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vnegss2(unsigned int a);
# 2742 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffs2(unsigned int a, unsigned int b);
# 2753 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsads2(unsigned int a, unsigned int b);
# 2763 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabs4(unsigned int a);
# 2774 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsss4(unsigned int a);
# 2785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vadd4(unsigned int a, unsigned int b);
# 2796 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddss4 (unsigned int a, unsigned int b);
# 2806 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vaddus4 (unsigned int a, unsigned int b);
# 2817 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgs4(unsigned int a, unsigned int b);
# 2828 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vavgu4(unsigned int a, unsigned int b);
# 2839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vhaddu4(unsigned int a, unsigned int b);
# 2850 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpeq4(unsigned int a, unsigned int b);
# 2861 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpges4(unsigned int a, unsigned int b);
# 2872 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgeu4(unsigned int a, unsigned int b);
# 2883 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgts4(unsigned int a, unsigned int b);
# 2894 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpgtu4(unsigned int a, unsigned int b);
# 2905 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmples4(unsigned int a, unsigned int b);
# 2916 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpleu4(unsigned int a, unsigned int b);
# 2927 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmplts4(unsigned int a, unsigned int b);
# 2938 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpltu4(unsigned int a, unsigned int b);
# 2949 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vcmpne4(unsigned int a, unsigned int b);
# 2960 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffu4(unsigned int a, unsigned int b);
# 2971 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxs4(unsigned int a, unsigned int b);
# 2982 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmaxu4(unsigned int a, unsigned int b);
# 2993 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vmins4(unsigned int a, unsigned int b);
# 3004 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vminu4(unsigned int a, unsigned int b);
# 3015 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vseteq4(unsigned int a, unsigned int b);
# 3026 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetles4(unsigned int a, unsigned int b);
# 3037 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetleu4(unsigned int a, unsigned int b);
# 3048 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetlts4(unsigned int a, unsigned int b);
# 3059 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetltu4(unsigned int a, unsigned int b);
# 3070 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetges4(unsigned int a, unsigned int b);
# 3081 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgeu4(unsigned int a, unsigned int b);
# 3092 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgts4(unsigned int a, unsigned int b);
# 3103 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetgtu4(unsigned int a, unsigned int b);
# 3114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsetne4(unsigned int a, unsigned int b);
# 3125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsadu4(unsigned int a, unsigned int b);
# 3136 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsub4(unsigned int a, unsigned int b);
# 3147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubss4(unsigned int a, unsigned int b);
# 3158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsubus4(unsigned int a, unsigned int b);
# 3168 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vneg4(unsigned int a);
# 3178 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vnegss4(unsigned int a);
# 3189 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vabsdiffs4(unsigned int a, unsigned int b);
# 3200 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
__attribute__((device)) __attribute__((cudart_builtin)) __attribute__((device_builtin)) unsigned int __vsads4(unsigned int a, unsigned int b);






}
# 3229 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int mulhi(const int a, const int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int mulhi(const unsigned int a, const unsigned int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int mulhi(const int a, const unsigned int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mulhi" "() is deprecated in favor of __" "mulhi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int mulhi(const unsigned int a, const int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long long int mul64hi(const long long int a, const long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long int mul64hi(const unsigned long long int a, const unsigned long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long int mul64hi(const long long int a, const unsigned long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mul64hi" "() is deprecated in favor of __" "mul64hi" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long int mul64hi(const unsigned long long int a, const long long int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("float_as_int" "() is deprecated in favor of __" "float_as_int" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int float_as_int(const float a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("int_as_float" "() is deprecated in favor of __" "int_as_float" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float int_as_float(const int a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("float_as_uint" "() is deprecated in favor of __" "float_as_uint" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int float_as_uint(const float a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("uint_as_float" "() is deprecated in favor of __" "uint_as_float" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float uint_as_float(const unsigned int a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("saturate" "() is deprecated in favor of __" "saturate" "f" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float saturate(const float a);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("mul24" "() is deprecated in favor of __" "mul24" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int mul24(const int a, const int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("umul24" "() is deprecated in favor of __" "umul24" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int umul24(const unsigned int a, const unsigned int b);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("float2int" "() is deprecated in favor of __" "float2int" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int float2int(const float a, const enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("float2uint" "() is deprecated in favor of __" "float2uint" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int float2uint(const float a, const enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("int2float" "() is deprecated in favor of __" "int2float" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float int2float(const int a, const enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) __attribute__((cudart_builtin)) __attribute__((deprecated("uint2float" "() is deprecated in favor of __" "uint2float" "_ru|_rd|_rn|_rz" "() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float uint2float(const unsigned int a, const enum cudaRoundMode mode = cudaRoundNearest);
# 3285 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.hpp" 1
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.hpp"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.hpp" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 82 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.hpp" 2
# 90 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.hpp"
static __inline__ __attribute__((device)) int mulhi(const int a, const int b)
{
  return __mulhi(a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(const unsigned int a, const unsigned int b)
{
  return __umulhi(a, b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(const int a, const unsigned int b)
{
  return __umulhi(static_cast<unsigned int>(a), b);
}

static __inline__ __attribute__((device)) unsigned int mulhi(const unsigned int a, const int b)
{
  return __umulhi(a, static_cast<unsigned int>(b));
}

static __inline__ __attribute__((device)) long long int mul64hi(const long long int a, const long long int b)
{
  return __mul64hi(a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(const unsigned long long int a, const unsigned long long int b)
{
  return __umul64hi(a, b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(const long long int a, const unsigned long long int b)
{
  return __umul64hi(static_cast<unsigned long long int>(a), b);
}

static __inline__ __attribute__((device)) unsigned long long int mul64hi(const unsigned long long int a, const long long int b)
{
  return __umul64hi(a, static_cast<unsigned long long int>(b));
}

static __inline__ __attribute__((device)) int float_as_int(const float a)
{
  return __float_as_int(a);
}

static __inline__ __attribute__((device)) float int_as_float(const int a)
{
  return __int_as_float(a);
}

static __inline__ __attribute__((device)) unsigned int float_as_uint(const float a)
{
  return __float_as_uint(a);
}

static __inline__ __attribute__((device)) float uint_as_float(const unsigned int a)
{
  return __uint_as_float(a);
}
static __inline__ __attribute__((device)) float saturate(const float a)
{
  return __saturatef(a);
}

static __inline__ __attribute__((device)) int mul24(const int a, const int b)
{
  return __mul24(a, b);
}

static __inline__ __attribute__((device)) unsigned int umul24(const unsigned int a, const unsigned int b)
{
  return __umul24(a, b);
}

static __inline__ __attribute__((device)) int float2int(const float a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundNearest) ? __float2int_rn(a) :
         (mode == cudaRoundPosInf ) ? __float2int_ru(a) :
         (mode == cudaRoundMinInf ) ? __float2int_rd(a) :
                                      __float2int_rz(a);
}

static __inline__ __attribute__((device)) unsigned int float2uint(const float a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundNearest) ? __float2uint_rn(a) :
         (mode == cudaRoundPosInf ) ? __float2uint_ru(a) :
         (mode == cudaRoundMinInf ) ? __float2uint_rd(a) :
                                      __float2uint_rz(a);
}

static __inline__ __attribute__((device)) float int2float(const int a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundZero ) ? __int2float_rz(a) :
         (mode == cudaRoundPosInf) ? __int2float_ru(a) :
         (mode == cudaRoundMinInf) ? __int2float_rd(a) :
                                     __int2float_rn(a);
}

static __inline__ __attribute__((device)) float uint2float(const unsigned int a, const enum cudaRoundMode mode)
{
  return (mode == cudaRoundZero ) ? __uint2float_rz(a) :
         (mode == cudaRoundPosInf) ? __uint2float_ru(a) :
         (mode == cudaRoundMinInf) ? __uint2float_rd(a) :
                                     __uint2float_rn(a);
}
# 3286 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h" 1
# 76 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h"
extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicAdd(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicAdd(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicExch(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicExch(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) float __fAtomicExch(float *address, float val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicMin(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicMin(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicMax(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicMax(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicInc(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicDec(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicAnd(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicAnd(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicOr(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicOr(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicXor(int *address, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicXor(unsigned int *address, unsigned int val);
extern __attribute__((device)) __attribute__((device_builtin)) int __iAtomicCAS(int *address, int compare, int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __uAtomicCAS(unsigned int *address, unsigned int compare, unsigned int val);
}
# 106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h"
static __inline__ __attribute__((device)) int atomicAdd(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicAdd(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicSub(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicSub(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicExch(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicExch(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) float atomicExch(float *address, float val) ;

static __inline__ __attribute__((device)) int atomicMin(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicMin(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicMax(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicMax(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) unsigned int atomicInc(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) unsigned int atomicDec(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicAnd(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicAnd(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicOr(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicOr(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicXor(int *address, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicXor(unsigned int *address, unsigned int val) ;

static __inline__ __attribute__((device)) int atomicCAS(int *address, int compare, int val) ;

static __inline__ __attribute__((device)) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val) ;
# 171 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h"
extern "C"
{

extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __ullAtomicAdd(unsigned long long int *address, unsigned long long int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __ullAtomicExch(unsigned long long int *address, unsigned long long int val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __ullAtomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val);

extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((deprecated("__any""() is deprecated in favor of ""__any""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int __any(int cond);
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((deprecated("__all""() is deprecated in favor of ""__all""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int __all(int cond);
}
# 189 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h"
static __inline__ __attribute__((device)) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val) ;

static __inline__ __attribute__((device)) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val) ;

static __inline__ __attribute__((device)) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val) ;

static __inline__ __attribute__((device)) __attribute__((deprecated("__any""() is deprecated in favor of ""__any""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) bool any(bool cond) ;

static __inline__ __attribute__((device)) __attribute__((deprecated("__all""() is deprecated in favor of ""__all""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) bool all(bool cond) ;
# 208 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.hpp" 1
# 75 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.hpp"
static __inline__ __attribute__((device)) int atomicAdd(int *address, int val)
{
  return __iAtomicAdd(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicAdd(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, val);
}

static __inline__ __attribute__((device)) int atomicSub(int *address, int val)
{
  return __iAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline__ __attribute__((device)) unsigned int atomicSub(unsigned int *address, unsigned int val)
{
  return __uAtomicAdd(address, (unsigned int)-(int)val);
}

static __inline__ __attribute__((device)) int atomicExch(int *address, int val)
{
  return __iAtomicExch(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicExch(unsigned int *address, unsigned int val)
{
  return __uAtomicExch(address, val);
}

static __inline__ __attribute__((device)) float atomicExch(float *address, float val)
{
  return __fAtomicExch(address, val);
}

static __inline__ __attribute__((device)) int atomicMin(int *address, int val)
{
  return __iAtomicMin(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicMin(unsigned int *address, unsigned int val)
{
  return __uAtomicMin(address, val);
}

static __inline__ __attribute__((device)) int atomicMax(int *address, int val)
{
  return __iAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicMax(unsigned int *address, unsigned int val)
{
  return __uAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicInc(unsigned int *address, unsigned int val)
{
  return __uAtomicInc(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicDec(unsigned int *address, unsigned int val)
{
  return __uAtomicDec(address, val);
}

static __inline__ __attribute__((device)) int atomicAnd(int *address, int val)
{
  return __iAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicAnd(unsigned int *address, unsigned int val)
{
  return __uAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) int atomicOr(int *address, int val)
{
  return __iAtomicOr(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicOr(unsigned int *address, unsigned int val)
{
  return __uAtomicOr(address, val);
}

static __inline__ __attribute__((device)) int atomicXor(int *address, int val)
{
  return __iAtomicXor(address, val);
}

static __inline__ __attribute__((device)) unsigned int atomicXor(unsigned int *address, unsigned int val)
{
  return __uAtomicXor(address, val);
}

static __inline__ __attribute__((device)) int atomicCAS(int *address, int compare, int val)
{
  return __iAtomicCAS(address, compare, val);
}

static __inline__ __attribute__((device)) unsigned int atomicCAS(unsigned int *address, unsigned int compare, unsigned int val)
{
  return __uAtomicCAS(address, compare, val);
}
# 194 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.hpp"
static __inline__ __attribute__((device)) unsigned long long int atomicAdd(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicAdd(address, val);
}

static __inline__ __attribute__((device)) unsigned long long int atomicExch(unsigned long long int *address, unsigned long long int val)
{
  return __ullAtomicExch(address, val);
}

static __inline__ __attribute__((device)) unsigned long long int atomicCAS(unsigned long long int *address, unsigned long long int compare, unsigned long long int val)
{
  return __ullAtomicCAS(address, compare, val);
}

static __inline__ __attribute__((device)) bool any(bool cond)
{
  return (bool)__any((int)cond);
}

static __inline__ __attribute__((device)) bool all(bool cond)
{
  return (bool)__all((int)cond);
}
# 209 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_atomic_functions.h" 2
# 3289 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h" 1
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 86 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h" 2

extern "C"
{
# 97 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double_as_longlong(double x);
# 106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __longlong_as_double(long long int x);
# 263 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rn(double x, double y, double z);
# 420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rz(double x, double y, double z);
# 577 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_ru(double x, double y, double z);
# 734 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rd(double x, double y, double z);
# 746 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rn(double x, double y);
# 758 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rz(double x, double y);
# 770 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_ru(double x, double y);
# 782 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rd(double x, double y);
# 794 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rn(double x, double y);
# 806 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rz(double x, double y);
# 818 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_ru(double x, double y);
# 830 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rd(double x, double y);
# 842 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rn(double x, double y);
# 854 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rz(double x, double y);
# 866 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_ru(double x, double y);
# 878 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rd(double x, double y);
# 887 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rn(double x);
# 896 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rz(double x);
# 905 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_ru(double x);
# 914 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rd(double x);
# 923 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rn(double x);
# 932 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_ru(double x);
# 941 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rd(double x);
# 950 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rn(double x);
# 959 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_ru(double x);
# 968 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rd(double x);
# 977 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rn(double x);
# 986 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_ru(double x);
# 995 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rd(double x);
# 1004 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rn(double x);
# 1013 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_ru(double x);
# 1022 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rd(double x);







extern __attribute__((device)) __attribute__((device_builtin)) double __int2double_rn(int x);







extern __attribute__((device)) __attribute__((device_builtin)) double __uint2double_rn(unsigned int x);
# 1047 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rn(long long int x);
# 1056 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rz(long long int x);
# 1065 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_ru(long long int x);
# 1074 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rd(long long int x);
# 1083 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rn(unsigned long long int x);
# 1092 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rz(unsigned long long int x);
# 1101 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_ru(unsigned long long int x);
# 1110 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rd(unsigned long long int x);
# 1119 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2hiint(double x);
# 1128 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2loint(double x);
# 1138 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __hiloint2double(int hi, int lo);
}







static __inline__ __attribute__((device)) double fma(double a, double b, double c, enum cudaRoundMode mode);

static __inline__ __attribute__((device)) double dmul(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double dadd(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double dsub(double a, double b, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) int double2int(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) unsigned int double2uint(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) long long int double2ll(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) unsigned long long int double2ull(double a, enum cudaRoundMode mode = cudaRoundZero);

static __inline__ __attribute__((device)) double ll2double(long long int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double ull2double(unsigned long long int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double int2double(int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double uint2double(unsigned int a, enum cudaRoundMode mode = cudaRoundNearest);

static __inline__ __attribute__((device)) double float2double(float a, enum cudaRoundMode mode = cudaRoundNearest);






# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.hpp" 1
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.hpp"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/builtin_types.h" 1
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.hpp" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/host_defines.h" 1
# 86 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.hpp" 2







static __inline__ __attribute__((device)) double fma(double a, double b, double c, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __fma_rz(a, b, c) :
         mode == cudaRoundPosInf ? __fma_ru(a, b, c) :
         mode == cudaRoundMinInf ? __fma_rd(a, b, c) :
                                   __fma_rn(a, b, c);
}

static __inline__ __attribute__((device)) double dmul(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __dmul_rz(a, b) :
         mode == cudaRoundPosInf ? __dmul_ru(a, b) :
         mode == cudaRoundMinInf ? __dmul_rd(a, b) :
                                   __dmul_rn(a, b);
}

static __inline__ __attribute__((device)) double dadd(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __dadd_rz(a, b) :
         mode == cudaRoundPosInf ? __dadd_ru(a, b) :
         mode == cudaRoundMinInf ? __dadd_rd(a, b) :
                                   __dadd_rn(a, b);
}

static __inline__ __attribute__((device)) double dsub(double a, double b, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __dsub_rz(a, b) :
         mode == cudaRoundPosInf ? __dsub_ru(a, b) :
         mode == cudaRoundMinInf ? __dsub_rd(a, b) :
                                   __dsub_rn(a, b);
}

static __inline__ __attribute__((device)) int double2int(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2int_rn(a) :
         mode == cudaRoundPosInf ? __double2int_ru(a) :
         mode == cudaRoundMinInf ? __double2int_rd(a) :
                                    __double2int_rz(a);
}

static __inline__ __attribute__((device)) unsigned int double2uint(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2uint_rn(a) :
         mode == cudaRoundPosInf ? __double2uint_ru(a) :
         mode == cudaRoundMinInf ? __double2uint_rd(a) :
                                    __double2uint_rz(a);
}

static __inline__ __attribute__((device)) long long int double2ll(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2ll_rn(a) :
         mode == cudaRoundPosInf ? __double2ll_ru(a) :
         mode == cudaRoundMinInf ? __double2ll_rd(a) :
                                    __double2ll_rz(a);
}

static __inline__ __attribute__((device)) unsigned long long int double2ull(double a, enum cudaRoundMode mode)
{
  return mode == cudaRoundNearest ? __double2ull_rn(a) :
         mode == cudaRoundPosInf ? __double2ull_ru(a) :
         mode == cudaRoundMinInf ? __double2ull_rd(a) :
                                    __double2ull_rz(a);
}

static __inline__ __attribute__((device)) double ll2double(long long int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __ll2double_rz(a) :
         mode == cudaRoundPosInf ? __ll2double_ru(a) :
         mode == cudaRoundMinInf ? __ll2double_rd(a) :
                                   __ll2double_rn(a);
}

static __inline__ __attribute__((device)) double ull2double(unsigned long long int a, enum cudaRoundMode mode)
{
  return mode == cudaRoundZero ? __ull2double_rz(a) :
         mode == cudaRoundPosInf ? __ull2double_ru(a) :
         mode == cudaRoundMinInf ? __ull2double_rd(a) :
                                   __ull2double_rn(a);
}

static __inline__ __attribute__((device)) double int2double(int a, enum cudaRoundMode mode)
{
  return (double)a;
}

static __inline__ __attribute__((device)) double uint2double(unsigned int a, enum cudaRoundMode mode)
{
  return (double)a;
}

static __inline__ __attribute__((device)) double float2double(float a, enum cudaRoundMode mode)
{
  return (double)a;
}
# 1179 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_double_functions.h" 2
# 3290 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_atomic_functions.h" 1
# 77 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_atomic_functions.h"
extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) float __fAtomicAdd(float *address, float val);
}
# 89 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_atomic_functions.h"
static __inline__ __attribute__((device)) float atomicAdd(float *address, float val) ;







# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_atomic_functions.hpp" 1
# 75 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_atomic_functions.hpp"
static __inline__ __attribute__((device)) float atomicAdd(float *address, float val)
{
  return __fAtomicAdd(address, val);
}
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_atomic_functions.h" 2
# 3291 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.h" 1
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.h"
extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) long long __illAtomicMin(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) long long __illAtomicMax(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) long long __llAtomicAnd(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) long long __llAtomicOr(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) long long __llAtomicXor(long long *address, long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicMin(unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicMax(unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicAnd(unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicOr (unsigned long long *address, unsigned long long val);
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long __ullAtomicXor(unsigned long long *address, unsigned long long val);
}
# 100 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.h"
static __inline__ __attribute__((device)) long long atomicMin(long long *address, long long val) ;

static __inline__ __attribute__((device)) long long atomicMax(long long *address, long long val) ;

static __inline__ __attribute__((device)) long long atomicAnd(long long *address, long long val) ;

static __inline__ __attribute__((device)) long long atomicOr(long long *address, long long val) ;

static __inline__ __attribute__((device)) long long atomicXor(long long *address, long long val) ;

static __inline__ __attribute__((device)) unsigned long long atomicMin(unsigned long long *address, unsigned long long val) ;

static __inline__ __attribute__((device)) unsigned long long atomicMax(unsigned long long *address, unsigned long long val) ;

static __inline__ __attribute__((device)) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) ;

static __inline__ __attribute__((device)) unsigned long long atomicOr(unsigned long long *address, unsigned long long val) ;

static __inline__ __attribute__((device)) unsigned long long atomicXor(unsigned long long *address, unsigned long long val) ;
# 128 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.hpp" 1
# 77 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.hpp"
static __inline__ __attribute__((device)) long long atomicMin(long long *address, long long val)
{
    return __illAtomicMin(address, val);
}

static __inline__ __attribute__((device)) long long atomicMax(long long *address, long long val)
{
    return __illAtomicMax(address, val);
}

static __inline__ __attribute__((device)) long long atomicAnd(long long *address, long long val)
{
    return __llAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) long long atomicOr(long long *address, long long val)
{
    return __llAtomicOr(address, val);
}

static __inline__ __attribute__((device)) long long atomicXor(long long *address, long long val)
{
    return __llAtomicXor(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicMin(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMin(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicMax(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicMax(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicAnd(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicAnd(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicOr(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicOr(address, val);
}

static __inline__ __attribute__((device)) unsigned long long atomicXor(unsigned long long *address, unsigned long long val)
{
    return __ullAtomicXor(address, val);
}
# 129 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.h" 2
# 3292 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_35_atomic_functions.h" 1
# 56 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_35_atomic_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_atomic_functions.h" 1
# 57 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_35_atomic_functions.h" 2
# 3293 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_60_atomic_functions.h" 1
# 535 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_60_atomic_functions.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_60_atomic_functions.hpp" 1
# 536 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_60_atomic_functions.h" 2
# 3294 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h" 1
# 90 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern "C"
{
extern __attribute__((device)) __attribute__((device_builtin)) void __threadfence_system(void);
# 104 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rn(double x, double y);
# 116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rz(double x, double y);
# 128 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_ru(double x, double y);
# 140 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ddiv_rd(double x, double y);
# 174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rn(double x);
# 208 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rz(double x);
# 242 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_ru(double x);
# 276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __drcp_rd(double x);
# 308 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rn(double x);
# 340 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rz(double x);
# 372 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_ru(double x);
# 404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsqrt_rd(double x);
extern __attribute__((device)) __attribute__((device_builtin)) __attribute__((deprecated("__ballot""() is deprecated in favor of ""__ballot""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int __ballot(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_count(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_and(int);
extern __attribute__((device)) __attribute__((device_builtin)) int __syncthreads_or(int);
extern __attribute__((device)) __attribute__((device_builtin)) long long int clock64(void);
# 419 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rn(float x, float y, float z);
# 428 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rd(float x, float y, float z);
# 437 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_ru(float x, float y, float z);
# 446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __fmaf_ieee_rz(float x, float y, float z);
# 459 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double_as_longlong(double x);
# 468 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __longlong_as_double(long long int x);
# 625 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rn(double x, double y, double z);
# 782 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rz(double x, double y, double z);
# 939 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_ru(double x, double y, double z);
# 1096 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __fma_rd(double x, double y, double z);
# 1108 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rn(double x, double y);
# 1120 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rz(double x, double y);
# 1132 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_ru(double x, double y);
# 1144 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dadd_rd(double x, double y);
# 1156 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rn(double x, double y);
# 1168 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rz(double x, double y);
# 1180 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_ru(double x, double y);
# 1192 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dsub_rd(double x, double y);
# 1204 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rn(double x, double y);
# 1216 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rz(double x, double y);
# 1228 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_ru(double x, double y);
# 1240 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __dmul_rd(double x, double y);
# 1249 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rn(double x);
# 1258 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rz(double x);
# 1267 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_ru(double x);
# 1276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) float __double2float_rd(double x);
# 1285 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rn(double x);
# 1294 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_ru(double x);
# 1303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2int_rd(double x);
# 1312 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rn(double x);
# 1321 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_ru(double x);
# 1330 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __double2uint_rd(double x);
# 1339 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rn(double x);
# 1348 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_ru(double x);
# 1357 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) long long int __double2ll_rd(double x);
# 1366 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rn(double x);
# 1375 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_ru(double x);
# 1384 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) unsigned long long int __double2ull_rd(double x);







extern __attribute__((device)) __attribute__((device_builtin)) double __int2double_rn(int x);







extern __attribute__((device)) __attribute__((device_builtin)) double __uint2double_rn(unsigned int x);
# 1409 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rn(long long int x);
# 1418 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rz(long long int x);
# 1427 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_ru(long long int x);
# 1436 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ll2double_rd(long long int x);
# 1445 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rn(unsigned long long int x);
# 1454 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rz(unsigned long long int x);
# 1463 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_ru(unsigned long long int x);
# 1472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __ull2double_rd(unsigned long long int x);
# 1481 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2hiint(double x);
# 1490 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) int __double2loint(double x);
# 1500 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
extern __attribute__((device)) __attribute__((device_builtin)) double __hiloint2double(int hi, int lo);


}






static __inline__ __attribute__((device)) __attribute__((deprecated("__ballot""() is deprecated in favor of ""__ballot""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int ballot(bool pred) ;

static __inline__ __attribute__((device)) int syncthreads_count(bool pred) ;

static __inline__ __attribute__((device)) bool syncthreads_and(bool pred) ;

static __inline__ __attribute__((device)) bool syncthreads_or(bool pred) ;




static __inline__ __attribute__((device)) unsigned int __isGlobal(const void *ptr) ;
static __inline__ __attribute__((device)) unsigned int __isShared(const void *ptr) ;
static __inline__ __attribute__((device)) unsigned int __isConstant(const void *ptr) ;
static __inline__ __attribute__((device)) unsigned int __isLocal(const void *ptr) ;



static __inline__ __attribute__((device)) size_t __cvta_generic_to_global(const void *ptr) ;
static __inline__ __attribute__((device)) size_t __cvta_generic_to_shared(const void *ptr) ;
static __inline__ __attribute__((device)) size_t __cvta_generic_to_constant(const void *ptr) ;
static __inline__ __attribute__((device)) size_t __cvta_generic_to_local(const void *ptr) ;




static __inline__ __attribute__((device)) void * __cvta_global_to_generic(size_t rawbits) ;
static __inline__ __attribute__((device)) void * __cvta_shared_to_generic(size_t rawbits) ;
static __inline__ __attribute__((device)) void * __cvta_constant_to_generic(size_t rawbits) ;
static __inline__ __attribute__((device)) void * __cvta_local_to_generic(size_t rawbits) ;
# 1549 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.hpp" 1
# 75 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.hpp"
static __inline__ __attribute__((device)) unsigned int ballot(bool pred)
{
  return __ballot((int)pred);
}

static __inline__ __attribute__((device)) int syncthreads_count(bool pred)
{
  return __syncthreads_count((int)pred);
}

static __inline__ __attribute__((device)) bool syncthreads_and(bool pred)
{
  return (bool)__syncthreads_and((int)pred);
}

static __inline__ __attribute__((device)) bool syncthreads_or(bool pred)
{
  return (bool)__syncthreads_or((int)pred);
}


extern "C" {
  __attribute__((device)) unsigned __nv_isGlobal_impl(const void *);
  __attribute__((device)) unsigned __nv_isShared_impl(const void *);
  __attribute__((device)) unsigned __nv_isConstant_impl(const void *);
  __attribute__((device)) unsigned __nv_isLocal_impl(const void *);
  __attribute__((device)) unsigned __nv_isGridConstant_impl(const void *);
}

static __inline__ __attribute__((device)) unsigned int __isGlobal(const void *ptr)
{
  return __nv_isGlobal_impl(ptr);
}

static __inline__ __attribute__((device)) unsigned int __isShared(const void *ptr)
{
  return __nv_isShared_impl(ptr);
}

static __inline__ __attribute__((device)) unsigned int __isConstant(const void *ptr)
{
  return __nv_isConstant_impl(ptr);
}

static __inline__ __attribute__((device)) unsigned int __isLocal(const void *ptr)
{
  return __nv_isLocal_impl(ptr);
}
# 131 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.hpp"
extern "C" {
  __attribute__((device)) size_t __nv_cvta_generic_to_global_impl(const void *);
  __attribute__((device)) size_t __nv_cvta_generic_to_shared_impl(const void *);
  __attribute__((device)) size_t __nv_cvta_generic_to_constant_impl(const void *);
  __attribute__((device)) size_t __nv_cvta_generic_to_local_impl(const void *);
  __attribute__((device)) void * __nv_cvta_global_to_generic_impl(size_t);
  __attribute__((device)) void * __nv_cvta_shared_to_generic_impl(size_t);
  __attribute__((device)) void * __nv_cvta_constant_to_generic_impl(size_t);
  __attribute__((device)) void * __nv_cvta_local_to_generic_impl(size_t);
}

static __inline__ __attribute__((device)) size_t __cvta_generic_to_global(const void *p)
{
  return __nv_cvta_generic_to_global_impl(p);
}

static __inline__ __attribute__((device)) size_t __cvta_generic_to_shared(const void *p)
{
  return __nv_cvta_generic_to_shared_impl(p);
}

static __inline__ __attribute__((device)) size_t __cvta_generic_to_constant(const void *p)
{
  return __nv_cvta_generic_to_constant_impl(p);
}

static __inline__ __attribute__((device)) size_t __cvta_generic_to_local(const void *p)
{
  return __nv_cvta_generic_to_local_impl(p);
}

static __inline__ __attribute__((device)) void * __cvta_global_to_generic(size_t rawbits)
{
  return __nv_cvta_global_to_generic_impl(rawbits);
}

static __inline__ __attribute__((device)) void * __cvta_shared_to_generic(size_t rawbits)
{
  return __nv_cvta_shared_to_generic_impl(rawbits);
}

static __inline__ __attribute__((device)) void * __cvta_constant_to_generic(size_t rawbits)
{
  return __nv_cvta_constant_to_generic_impl(rawbits);
}

static __inline__ __attribute__((device)) void * __cvta_local_to_generic(size_t rawbits)
{
  return __nv_cvta_local_to_generic_impl(rawbits);
}
# 1550 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_20_intrinsics.h" 2
# 3295 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.h" 1
# 102 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.h"
static __attribute__((device)) __inline__ unsigned __fns(unsigned mask, unsigned base, int offset) ;
static __attribute__((device)) __inline__ void __barrier_sync(unsigned id) ;
static __attribute__((device)) __inline__ void __barrier_sync_count(unsigned id, unsigned cnt) ;
static __attribute__((device)) __inline__ void __syncwarp(unsigned mask=0xFFFFFFFF) ;
static __attribute__((device)) __inline__ int __all_sync(unsigned mask, int pred) ;
static __attribute__((device)) __inline__ int __any_sync(unsigned mask, int pred) ;
static __attribute__((device)) __inline__ int __uni_sync(unsigned mask, int pred) ;
static __attribute__((device)) __inline__ unsigned __ballot_sync(unsigned mask, int pred) ;
static __attribute__((device)) __inline__ unsigned __activemask() ;
# 119 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.h"
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int __shfl(int var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int __shfl(unsigned int var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int __shfl_up(int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int __shfl_up(unsigned int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int __shfl_down(int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int __shfl_down(unsigned int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) int __shfl_xor(int var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned int __shfl_xor(unsigned int var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float __shfl(float var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float __shfl_up(float var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float __shfl_down(float var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) float __shfl_xor(float var, int laneMask, int width=32) ;


static __attribute__((device)) __inline__ int __shfl_sync(unsigned mask, int var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ unsigned int __shfl_sync(unsigned mask, unsigned int var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ int __shfl_up_sync(unsigned mask, int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ unsigned int __shfl_up_sync(unsigned mask, unsigned int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ int __shfl_down_sync(unsigned mask, int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ unsigned int __shfl_down_sync(unsigned mask, unsigned int var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ unsigned int __shfl_xor_sync(unsigned mask, unsigned int var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ float __shfl_sync(unsigned mask, float var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ float __shfl_up_sync(unsigned mask, float var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ float __shfl_down_sync(unsigned mask, float var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width=32) ;



static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long __shfl(unsigned long long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long long __shfl(long long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long long __shfl_up(long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long __shfl_up(unsigned long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long long __shfl_down(long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long __shfl_down(unsigned long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long long __shfl_xor(long long var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) double __shfl(double var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) double __shfl_up(double var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) double __shfl_down(double var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) double __shfl_xor(double var, int laneMask, int width=32) ;


static __attribute__((device)) __inline__ long long __shfl_sync(unsigned mask, long long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ unsigned long long __shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ long long __shfl_up_sync(unsigned mask, long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ unsigned long long __shfl_up_sync(unsigned mask, unsigned long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ long long __shfl_down_sync(unsigned mask, long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ unsigned long long __shfl_down_sync(unsigned mask, unsigned long long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ long long __shfl_xor_sync(unsigned mask, long long var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ unsigned long long __shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ double __shfl_sync(unsigned mask, double var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ double __shfl_up_sync(unsigned mask, double var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ double __shfl_down_sync(unsigned mask, double var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width=32) ;



static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long __shfl(long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl""() is deprecated in favor of ""__shfl""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long __shfl(unsigned long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long __shfl_up(long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_up""() is deprecated in favor of ""__shfl_up""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long __shfl_up(unsigned long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long __shfl_down(long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_down""() is deprecated in favor of ""__shfl_down""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long __shfl_down(unsigned long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) long __shfl_xor(long var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ __attribute__((deprecated("__shfl_xor""() is deprecated in favor of ""__shfl_xor""_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress this warning)."))) unsigned long __shfl_xor(unsigned long var, int laneMask, int width=32) ;


static __attribute__((device)) __inline__ long __shfl_sync(unsigned mask, long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width=32) ;
static __attribute__((device)) __inline__ long __shfl_up_sync(unsigned mask, long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ long __shfl_down_sync(unsigned mask, long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned int delta, int width=32) ;
static __attribute__((device)) __inline__ long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width=32) ;
static __attribute__((device)) __inline__ unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width=32) ;
# 212 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.hpp" 1
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.hpp"
extern "C"
{
}
# 89 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.hpp"
static __attribute__((device)) __inline__
unsigned __fns(unsigned mask, unsigned base, int offset) {
  extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __nvvm_fns(unsigned int mask, unsigned int base, int offset);
  return __nvvm_fns(mask, base, offset);
}

static __attribute__((device)) __inline__
void __barrier_sync(unsigned id) {
  extern __attribute__((device)) __attribute__((device_builtin)) void __nvvm_barrier_sync(unsigned id);
  return __nvvm_barrier_sync(id);
}

static __attribute__((device)) __inline__
void __barrier_sync_count(unsigned id, unsigned cnt) {
  extern __attribute__((device)) __attribute__((device_builtin)) void __nvvm_barrier_sync_cnt(unsigned id, unsigned cnt);
  return __nvvm_barrier_sync_cnt(id, cnt);
}

static __attribute__((device)) __inline__
void __syncwarp(unsigned mask) {
  extern __attribute__((device)) __attribute__((device_builtin)) void __nvvm_bar_warp_sync(unsigned mask);
  return __nvvm_bar_warp_sync(mask);
}

static __attribute__((device)) __inline__
int __all_sync(unsigned mask, int pred) {
  extern __attribute__((device)) __attribute__((device_builtin)) int __nvvm_vote_all_sync(unsigned int mask, int pred);
  return __nvvm_vote_all_sync(mask, pred);
}

static __attribute__((device)) __inline__
int __any_sync(unsigned mask, int pred) {
  extern __attribute__((device)) __attribute__((device_builtin)) int __nvvm_vote_any_sync(unsigned int mask, int pred);
  return __nvvm_vote_any_sync(mask, pred);
}

static __attribute__((device)) __inline__
int __uni_sync(unsigned mask, int pred) {
  extern __attribute__((device)) __attribute__((device_builtin)) int __nvvm_vote_uni_sync(unsigned int mask, int pred);
  return __nvvm_vote_uni_sync(mask, pred);
}

static __attribute__((device)) __inline__
unsigned __ballot_sync(unsigned mask, int pred) {
  extern __attribute__((device)) __attribute__((device_builtin)) unsigned int __nvvm_vote_ballot_sync(unsigned int mask, int pred);
  return __nvvm_vote_ballot_sync(mask, pred);
}

static __attribute__((device)) __inline__
unsigned __activemask() {
    unsigned ret;
    asm volatile ("activemask.b32 %0;" : "=r"(ret));
    return ret;
}




static __attribute__((device)) __inline__ int __shfl(int var, int srcLane, int width) {
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.idx.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(srcLane), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl(unsigned int var, int srcLane, int width) {
 return (unsigned int) __shfl((int)var, srcLane, width);
}

static __attribute__((device)) __inline__ int __shfl_up(int var, unsigned int delta, int width) {
 int ret;
 int c = (32 -width) << 8;
 asm volatile ("shfl.up.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_up(unsigned int var, unsigned int delta, int width) {
 return (unsigned int) __shfl_up((int)var, delta, width);
}

static __attribute__((device)) __inline__ int __shfl_down(int var, unsigned int delta, int width) {
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.down.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_down(unsigned int var, unsigned int delta, int width) {
 return (unsigned int) __shfl_down((int)var, delta, width);
}

static __attribute__((device)) __inline__ int __shfl_xor(int var, int laneMask, int width) {
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.bfly.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(var), "r"(laneMask), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_xor(unsigned int var, int laneMask, int width) {
 return (unsigned int) __shfl_xor((int)var, laneMask, width);
}

static __attribute__((device)) __inline__ float __shfl(float var, int srcLane, int width) {
 float ret;
        int c;
 c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.idx.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(srcLane), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ float __shfl_up(float var, unsigned int delta, int width) {
 float ret;
        int c;
 c = (32 -width) << 8;
 asm volatile ("shfl.up.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ float __shfl_down(float var, unsigned int delta, int width) {
 float ret;
        int c;
 c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.down.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(delta), "r"(c));
 return ret;
}

static __attribute__((device)) __inline__ float __shfl_xor(float var, int laneMask, int width) {
 float ret;
        int c;
 c = ((32 -width) << 8) | 0x1f;
 asm volatile ("shfl.bfly.b32 %0, %1, %2, %3;" : "=f"(ret) : "f"(var), "r"(laneMask), "r"(c));
 return ret;
}



static __attribute__((device)) __inline__ long long __shfl(long long var, int srcLane, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl(hi, srcLane, width);
 lo = __shfl(lo, srcLane, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl(unsigned long long var, int srcLane, int width) {
 return (unsigned long long) __shfl((long long) var, srcLane, width);
}

static __attribute__((device)) __inline__ long long __shfl_up(long long var, unsigned int delta, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_up(hi, delta, width);
 lo = __shfl_up(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_up(unsigned long long var, unsigned int delta, int width) {
 return (unsigned long long) __shfl_up((long long) var, delta, width);
}

static __attribute__((device)) __inline__ long long __shfl_down(long long var, unsigned int delta, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_down(hi, delta, width);
 lo = __shfl_down(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_down(unsigned long long var, unsigned int delta, int width) {
 return (unsigned long long) __shfl_down((long long) var, delta, width);
}

static __attribute__((device)) __inline__ long long __shfl_xor(long long var, int laneMask, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_xor(hi, laneMask, width);
 lo = __shfl_xor(lo, laneMask, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width) {
 return (unsigned long long) __shfl_xor((long long) var, laneMask, width);
}

static __attribute__((device)) __inline__ double __shfl(double var, int srcLane, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl(hi, srcLane, width);
 lo = __shfl(lo, srcLane, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_up(double var, unsigned int delta, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_up(hi, delta, width);
 lo = __shfl_up(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_down(double var, unsigned int delta, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_down(hi, delta, width);
 lo = __shfl_down(lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_xor(double var, int laneMask, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_xor(hi, laneMask, width);
 lo = __shfl_xor(lo, laneMask, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ long __shfl(long var, int srcLane, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl((long long) var, srcLane, width) :
  __shfl((int) var, srcLane, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl(unsigned long var, int srcLane, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl((unsigned long long) var, srcLane, width) :
  __shfl((unsigned int) var, srcLane, width);
}

static __attribute__((device)) __inline__ long __shfl_up(long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_up((long long) var, delta, width) :
  __shfl_up((int) var, delta, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_up(unsigned long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_up((unsigned long long) var, delta, width) :
  __shfl_up((unsigned int) var, delta, width);
}

static __attribute__((device)) __inline__ long __shfl_down(long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_down((long long) var, delta, width) :
  __shfl_down((int) var, delta, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_down(unsigned long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_down((unsigned long long) var, delta, width) :
  __shfl_down((unsigned int) var, delta, width);
}

static __attribute__((device)) __inline__ long __shfl_xor(long var, int laneMask, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_xor((long long) var, laneMask, width) :
  __shfl_xor((int) var, laneMask, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_xor(unsigned long var, int laneMask, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_xor((unsigned long long) var, laneMask, width) :
  __shfl_xor((unsigned int) var, laneMask, width);
}
# 369 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.hpp"
static __attribute__((device)) __inline__ int __shfl_sync(unsigned mask, int var, int srcLane, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_idx_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
        ret = __nvvm_shfl_idx_sync(mask, var, srcLane, c);
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_sync(unsigned mask, unsigned int var, int srcLane, int width) {
        return (unsigned int) __shfl_sync(mask, (int)var, srcLane, width);
}

static __attribute__((device)) __inline__ int __shfl_up_sync(unsigned mask, int var, unsigned int delta, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_up_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
 int c = (32 -width) << 8;
        ret = __nvvm_shfl_up_sync(mask, var, delta, c);
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_up_sync(unsigned mask, unsigned int var, unsigned int delta, int width) {
        return (unsigned int) __shfl_up_sync(mask, (int)var, delta, width);
}

static __attribute__((device)) __inline__ int __shfl_down_sync(unsigned mask, int var, unsigned int delta, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_down_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
        ret = __nvvm_shfl_down_sync(mask, var, delta, c);
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_down_sync(unsigned mask, unsigned int var, unsigned int delta, int width) {
        return (unsigned int) __shfl_down_sync(mask, (int)var, delta, width);
}

static __attribute__((device)) __inline__ int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_bfly_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
 int c = ((32 -width) << 8) | 0x1f;
        ret = __nvvm_shfl_bfly_sync(mask, var, laneMask, c);
 return ret;
}

static __attribute__((device)) __inline__ unsigned int __shfl_xor_sync(unsigned mask, unsigned int var, int laneMask, int width) {
 return (unsigned int) __shfl_xor_sync(mask, (int)var, laneMask, width);
}

static __attribute__((device)) __inline__ float __shfl_sync(unsigned mask, float var, int srcLane, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_idx_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
        int ret;
        int c;
 c = ((32 -width) << 8) | 0x1f;
        ret = __nvvm_shfl_idx_sync(mask, __float_as_int(var), srcLane, c);
 return __int_as_float(ret);
}

static __attribute__((device)) __inline__ float __shfl_up_sync(unsigned mask, float var, unsigned int delta, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_up_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
        int c;
 c = (32 -width) << 8;
        ret = __nvvm_shfl_up_sync(mask, __float_as_int(var), delta, c);
 return __int_as_float(ret);
}

static __attribute__((device)) __inline__ float __shfl_down_sync(unsigned mask, float var, unsigned int delta, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_down_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
        int c;
 c = ((32 -width) << 8) | 0x1f;
        ret = __nvvm_shfl_down_sync(mask, __float_as_int(var), delta, c);
 return __int_as_float(ret);
}

static __attribute__((device)) __inline__ float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width) {
        extern __attribute__((device)) __attribute__((device_builtin)) unsigned __nvvm_shfl_bfly_sync(unsigned mask, unsigned a, unsigned b, unsigned c);
 int ret;
        int c;
 c = ((32 -width) << 8) | 0x1f;
        ret = __nvvm_shfl_bfly_sync(mask, __float_as_int(var), laneMask, c);
 return __int_as_float(ret);
}


static __attribute__((device)) __inline__ long long __shfl_sync(unsigned mask, long long var, int srcLane, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_sync(mask, hi, srcLane, width);
 lo = __shfl_sync(mask, lo, srcLane, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width) {
        return (unsigned long long) __shfl_sync(mask, (long long) var, srcLane, width);
}

static __attribute__((device)) __inline__ long long __shfl_up_sync(unsigned mask, long long var, unsigned int delta, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_up_sync(mask, hi, delta, width);
 lo = __shfl_up_sync(mask, lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_up_sync(unsigned mask, unsigned long long var, unsigned int delta, int width) {
        return (unsigned long long) __shfl_up_sync(mask, (long long) var, delta, width);
}

static __attribute__((device)) __inline__ long long __shfl_down_sync(unsigned mask, long long var, unsigned int delta, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_down_sync(mask, hi, delta, width);
 lo = __shfl_down_sync(mask, lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_down_sync(unsigned mask, unsigned long long var, unsigned int delta, int width) {
        return (unsigned long long) __shfl_down_sync(mask, (long long) var, delta, width);
}

static __attribute__((device)) __inline__ long long __shfl_xor_sync(unsigned mask, long long var, int laneMask, int width) {
 int lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "l"(var));
 hi = __shfl_xor_sync(mask, hi, laneMask, width);
 lo = __shfl_xor_sync(mask, lo, laneMask, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=l"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ unsigned long long __shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask, int width) {
        return (unsigned long long) __shfl_xor_sync(mask, (long long) var, laneMask, width);
}

static __attribute__((device)) __inline__ double __shfl_sync(unsigned mask, double var, int srcLane, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_sync(mask, hi, srcLane, width);
 lo = __shfl_sync(mask, lo, srcLane, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_up_sync(unsigned mask, double var, unsigned int delta, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_up_sync(mask, hi, delta, width);
 lo = __shfl_up_sync(mask, lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_down_sync(unsigned mask, double var, unsigned int delta, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_down_sync(mask, hi, delta, width);
 lo = __shfl_down_sync(mask, lo, delta, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}

static __attribute__((device)) __inline__ double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width) {
 unsigned lo, hi;
 asm volatile("mov.b64 {%0,%1}, %2;" : "=r"(lo), "=r"(hi) : "d"(var));
 hi = __shfl_xor_sync(mask, hi, laneMask, width);
 lo = __shfl_xor_sync(mask, lo, laneMask, width);
 asm volatile("mov.b64 %0, {%1,%2};" : "=d"(var) : "r"(lo), "r"(hi));
 return var;
}



static __attribute__((device)) __inline__ long __shfl_sync(unsigned mask, long var, int srcLane, int width) {
 return (sizeof(long) == sizeof(long long)) ?
                __shfl_sync(mask, (long long) var, srcLane, width) :
  __shfl_sync(mask, (int) var, srcLane, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width) {
 return (sizeof(long) == sizeof(long long)) ?
                __shfl_sync(mask, (unsigned long long) var, srcLane, width) :
  __shfl_sync(mask, (unsigned int) var, srcLane, width);
}

static __attribute__((device)) __inline__ long __shfl_up_sync(unsigned mask, long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_up_sync(mask, (long long) var, delta, width) :
  __shfl_up_sync(mask, (int) var, delta, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_up_sync(mask, (unsigned long long) var, delta, width) :
  __shfl_up_sync(mask, (unsigned int) var, delta, width);
}

static __attribute__((device)) __inline__ long __shfl_down_sync(unsigned mask, long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_down_sync(mask, (long long) var, delta, width) :
  __shfl_down_sync(mask, (int) var, delta, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned int delta, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_down_sync(mask, (unsigned long long) var, delta, width) :
  __shfl_down_sync(mask, (unsigned int) var, delta, width);
}

static __attribute__((device)) __inline__ long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_xor_sync(mask, (long long) var, laneMask, width) :
  __shfl_xor_sync(mask, (int) var, laneMask, width);
}

static __attribute__((device)) __inline__ unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width) {
 return (sizeof(long) == sizeof(long long)) ?
  __shfl_xor_sync(mask, (unsigned long long) var, laneMask, width) :
  __shfl_xor_sync(mask, (unsigned int) var, laneMask, width);
}
# 213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_30_intrinsics.h" 2
# 3296 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h" 1
# 87 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ long __ldg(const long *ptr) ;
static __attribute__((device)) __inline__ unsigned long __ldg(const unsigned long *ptr) ;

static __attribute__((device)) __inline__ char __ldg(const char *ptr) ;
static __attribute__((device)) __inline__ signed char __ldg(const signed char *ptr) ;
static __attribute__((device)) __inline__ short __ldg(const short *ptr) ;
static __attribute__((device)) __inline__ int __ldg(const int *ptr) ;
static __attribute__((device)) __inline__ long long __ldg(const long long *ptr) ;
static __attribute__((device)) __inline__ char2 __ldg(const char2 *ptr) ;
static __attribute__((device)) __inline__ char4 __ldg(const char4 *ptr) ;
static __attribute__((device)) __inline__ short2 __ldg(const short2 *ptr) ;
static __attribute__((device)) __inline__ short4 __ldg(const short4 *ptr) ;
static __attribute__((device)) __inline__ int2 __ldg(const int2 *ptr) ;
static __attribute__((device)) __inline__ int4 __ldg(const int4 *ptr) ;
static __attribute__((device)) __inline__ longlong2 __ldg(const longlong2 *ptr) ;

static __attribute__((device)) __inline__ unsigned char __ldg(const unsigned char *ptr) ;
static __attribute__((device)) __inline__ unsigned short __ldg(const unsigned short *ptr) ;
static __attribute__((device)) __inline__ unsigned int __ldg(const unsigned int *ptr) ;
static __attribute__((device)) __inline__ unsigned long long __ldg(const unsigned long long *ptr) ;
static __attribute__((device)) __inline__ uchar2 __ldg(const uchar2 *ptr) ;
static __attribute__((device)) __inline__ uchar4 __ldg(const uchar4 *ptr) ;
static __attribute__((device)) __inline__ ushort2 __ldg(const ushort2 *ptr) ;
static __attribute__((device)) __inline__ ushort4 __ldg(const ushort4 *ptr) ;
static __attribute__((device)) __inline__ uint2 __ldg(const uint2 *ptr) ;
static __attribute__((device)) __inline__ uint4 __ldg(const uint4 *ptr) ;
static __attribute__((device)) __inline__ ulonglong2 __ldg(const ulonglong2 *ptr) ;

static __attribute__((device)) __inline__ float __ldg(const float *ptr) ;
static __attribute__((device)) __inline__ double __ldg(const double *ptr) ;
static __attribute__((device)) __inline__ float2 __ldg(const float2 *ptr) ;
static __attribute__((device)) __inline__ float4 __ldg(const float4 *ptr) ;
static __attribute__((device)) __inline__ double2 __ldg(const double2 *ptr) ;



static __attribute__((device)) __inline__ long __ldcg(const long *ptr) ;
static __attribute__((device)) __inline__ unsigned long __ldcg(const unsigned long *ptr) ;

static __attribute__((device)) __inline__ char __ldcg(const char *ptr) ;
static __attribute__((device)) __inline__ signed char __ldcg(const signed char *ptr) ;
static __attribute__((device)) __inline__ short __ldcg(const short *ptr) ;
static __attribute__((device)) __inline__ int __ldcg(const int *ptr) ;
static __attribute__((device)) __inline__ long long __ldcg(const long long *ptr) ;
static __attribute__((device)) __inline__ char2 __ldcg(const char2 *ptr) ;
static __attribute__((device)) __inline__ char4 __ldcg(const char4 *ptr) ;
static __attribute__((device)) __inline__ short2 __ldcg(const short2 *ptr) ;
static __attribute__((device)) __inline__ short4 __ldcg(const short4 *ptr) ;
static __attribute__((device)) __inline__ int2 __ldcg(const int2 *ptr) ;
static __attribute__((device)) __inline__ int4 __ldcg(const int4 *ptr) ;
static __attribute__((device)) __inline__ longlong2 __ldcg(const longlong2 *ptr) ;

static __attribute__((device)) __inline__ unsigned char __ldcg(const unsigned char *ptr) ;
static __attribute__((device)) __inline__ unsigned short __ldcg(const unsigned short *ptr) ;
static __attribute__((device)) __inline__ unsigned int __ldcg(const unsigned int *ptr) ;
static __attribute__((device)) __inline__ unsigned long long __ldcg(const unsigned long long *ptr) ;
static __attribute__((device)) __inline__ uchar2 __ldcg(const uchar2 *ptr) ;
static __attribute__((device)) __inline__ uchar4 __ldcg(const uchar4 *ptr) ;
static __attribute__((device)) __inline__ ushort2 __ldcg(const ushort2 *ptr) ;
static __attribute__((device)) __inline__ ushort4 __ldcg(const ushort4 *ptr) ;
static __attribute__((device)) __inline__ uint2 __ldcg(const uint2 *ptr) ;
static __attribute__((device)) __inline__ uint4 __ldcg(const uint4 *ptr) ;
static __attribute__((device)) __inline__ ulonglong2 __ldcg(const ulonglong2 *ptr) ;

static __attribute__((device)) __inline__ float __ldcg(const float *ptr) ;
static __attribute__((device)) __inline__ double __ldcg(const double *ptr) ;
static __attribute__((device)) __inline__ float2 __ldcg(const float2 *ptr) ;
static __attribute__((device)) __inline__ float4 __ldcg(const float4 *ptr) ;
static __attribute__((device)) __inline__ double2 __ldcg(const double2 *ptr) ;



static __attribute__((device)) __inline__ long __ldca(const long *ptr) ;
static __attribute__((device)) __inline__ unsigned long __ldca(const unsigned long *ptr) ;

static __attribute__((device)) __inline__ char __ldca(const char *ptr) ;
static __attribute__((device)) __inline__ signed char __ldca(const signed char *ptr) ;
static __attribute__((device)) __inline__ short __ldca(const short *ptr) ;
static __attribute__((device)) __inline__ int __ldca(const int *ptr) ;
static __attribute__((device)) __inline__ long long __ldca(const long long *ptr) ;
static __attribute__((device)) __inline__ char2 __ldca(const char2 *ptr) ;
static __attribute__((device)) __inline__ char4 __ldca(const char4 *ptr) ;
static __attribute__((device)) __inline__ short2 __ldca(const short2 *ptr) ;
static __attribute__((device)) __inline__ short4 __ldca(const short4 *ptr) ;
static __attribute__((device)) __inline__ int2 __ldca(const int2 *ptr) ;
static __attribute__((device)) __inline__ int4 __ldca(const int4 *ptr) ;
static __attribute__((device)) __inline__ longlong2 __ldca(const longlong2 *ptr) ;

static __attribute__((device)) __inline__ unsigned char __ldca(const unsigned char *ptr) ;
static __attribute__((device)) __inline__ unsigned short __ldca(const unsigned short *ptr) ;
static __attribute__((device)) __inline__ unsigned int __ldca(const unsigned int *ptr) ;
static __attribute__((device)) __inline__ unsigned long long __ldca(const unsigned long long *ptr) ;
static __attribute__((device)) __inline__ uchar2 __ldca(const uchar2 *ptr) ;
static __attribute__((device)) __inline__ uchar4 __ldca(const uchar4 *ptr) ;
static __attribute__((device)) __inline__ ushort2 __ldca(const ushort2 *ptr) ;
static __attribute__((device)) __inline__ ushort4 __ldca(const ushort4 *ptr) ;
static __attribute__((device)) __inline__ uint2 __ldca(const uint2 *ptr) ;
static __attribute__((device)) __inline__ uint4 __ldca(const uint4 *ptr) ;
static __attribute__((device)) __inline__ ulonglong2 __ldca(const ulonglong2 *ptr) ;

static __attribute__((device)) __inline__ float __ldca(const float *ptr) ;
static __attribute__((device)) __inline__ double __ldca(const double *ptr) ;
static __attribute__((device)) __inline__ float2 __ldca(const float2 *ptr) ;
static __attribute__((device)) __inline__ float4 __ldca(const float4 *ptr) ;
static __attribute__((device)) __inline__ double2 __ldca(const double2 *ptr) ;



static __attribute__((device)) __inline__ long __ldcs(const long *ptr) ;
static __attribute__((device)) __inline__ unsigned long __ldcs(const unsigned long *ptr) ;

static __attribute__((device)) __inline__ char __ldcs(const char *ptr) ;
static __attribute__((device)) __inline__ signed char __ldcs(const signed char *ptr) ;
static __attribute__((device)) __inline__ short __ldcs(const short *ptr) ;
static __attribute__((device)) __inline__ int __ldcs(const int *ptr) ;
static __attribute__((device)) __inline__ long long __ldcs(const long long *ptr) ;
static __attribute__((device)) __inline__ char2 __ldcs(const char2 *ptr) ;
static __attribute__((device)) __inline__ char4 __ldcs(const char4 *ptr) ;
static __attribute__((device)) __inline__ short2 __ldcs(const short2 *ptr) ;
static __attribute__((device)) __inline__ short4 __ldcs(const short4 *ptr) ;
static __attribute__((device)) __inline__ int2 __ldcs(const int2 *ptr) ;
static __attribute__((device)) __inline__ int4 __ldcs(const int4 *ptr) ;
static __attribute__((device)) __inline__ longlong2 __ldcs(const longlong2 *ptr) ;

static __attribute__((device)) __inline__ unsigned char __ldcs(const unsigned char *ptr) ;
static __attribute__((device)) __inline__ unsigned short __ldcs(const unsigned short *ptr) ;
static __attribute__((device)) __inline__ unsigned int __ldcs(const unsigned int *ptr) ;
static __attribute__((device)) __inline__ unsigned long long __ldcs(const unsigned long long *ptr) ;
static __attribute__((device)) __inline__ uchar2 __ldcs(const uchar2 *ptr) ;
static __attribute__((device)) __inline__ uchar4 __ldcs(const uchar4 *ptr) ;
static __attribute__((device)) __inline__ ushort2 __ldcs(const ushort2 *ptr) ;
static __attribute__((device)) __inline__ ushort4 __ldcs(const ushort4 *ptr) ;
static __attribute__((device)) __inline__ uint2 __ldcs(const uint2 *ptr) ;
static __attribute__((device)) __inline__ uint4 __ldcs(const uint4 *ptr) ;
static __attribute__((device)) __inline__ ulonglong2 __ldcs(const ulonglong2 *ptr) ;

static __attribute__((device)) __inline__ float __ldcs(const float *ptr) ;
static __attribute__((device)) __inline__ double __ldcs(const double *ptr) ;
static __attribute__((device)) __inline__ float2 __ldcs(const float2 *ptr) ;
static __attribute__((device)) __inline__ float4 __ldcs(const float4 *ptr) ;
static __attribute__((device)) __inline__ double2 __ldcs(const double2 *ptr) ;



static __attribute__((device)) __inline__ long __ldlu(const long *ptr) ;
static __attribute__((device)) __inline__ unsigned long __ldlu(const unsigned long *ptr) ;

static __attribute__((device)) __inline__ char __ldlu(const char *ptr) ;
static __attribute__((device)) __inline__ signed char __ldlu(const signed char *ptr) ;
static __attribute__((device)) __inline__ short __ldlu(const short *ptr) ;
static __attribute__((device)) __inline__ int __ldlu(const int *ptr) ;
static __attribute__((device)) __inline__ long long __ldlu(const long long *ptr) ;
static __attribute__((device)) __inline__ char2 __ldlu(const char2 *ptr) ;
static __attribute__((device)) __inline__ char4 __ldlu(const char4 *ptr) ;
static __attribute__((device)) __inline__ short2 __ldlu(const short2 *ptr) ;
static __attribute__((device)) __inline__ short4 __ldlu(const short4 *ptr) ;
static __attribute__((device)) __inline__ int2 __ldlu(const int2 *ptr) ;
static __attribute__((device)) __inline__ int4 __ldlu(const int4 *ptr) ;
static __attribute__((device)) __inline__ longlong2 __ldlu(const longlong2 *ptr) ;

static __attribute__((device)) __inline__ unsigned char __ldlu(const unsigned char *ptr) ;
static __attribute__((device)) __inline__ unsigned short __ldlu(const unsigned short *ptr) ;
static __attribute__((device)) __inline__ unsigned int __ldlu(const unsigned int *ptr) ;
static __attribute__((device)) __inline__ unsigned long long __ldlu(const unsigned long long *ptr) ;
static __attribute__((device)) __inline__ uchar2 __ldlu(const uchar2 *ptr) ;
static __attribute__((device)) __inline__ uchar4 __ldlu(const uchar4 *ptr) ;
static __attribute__((device)) __inline__ ushort2 __ldlu(const ushort2 *ptr) ;
static __attribute__((device)) __inline__ ushort4 __ldlu(const ushort4 *ptr) ;
static __attribute__((device)) __inline__ uint2 __ldlu(const uint2 *ptr) ;
static __attribute__((device)) __inline__ uint4 __ldlu(const uint4 *ptr) ;
static __attribute__((device)) __inline__ ulonglong2 __ldlu(const ulonglong2 *ptr) ;

static __attribute__((device)) __inline__ float __ldlu(const float *ptr) ;
static __attribute__((device)) __inline__ double __ldlu(const double *ptr) ;
static __attribute__((device)) __inline__ float2 __ldlu(const float2 *ptr) ;
static __attribute__((device)) __inline__ float4 __ldlu(const float4 *ptr) ;
static __attribute__((device)) __inline__ double2 __ldlu(const double2 *ptr) ;



static __attribute__((device)) __inline__ long __ldcv(const long *ptr) ;
static __attribute__((device)) __inline__ unsigned long __ldcv(const unsigned long *ptr) ;

static __attribute__((device)) __inline__ char __ldcv(const char *ptr) ;
static __attribute__((device)) __inline__ signed char __ldcv(const signed char *ptr) ;
static __attribute__((device)) __inline__ short __ldcv(const short *ptr) ;
static __attribute__((device)) __inline__ int __ldcv(const int *ptr) ;
static __attribute__((device)) __inline__ long long __ldcv(const long long *ptr) ;
static __attribute__((device)) __inline__ char2 __ldcv(const char2 *ptr) ;
static __attribute__((device)) __inline__ char4 __ldcv(const char4 *ptr) ;
static __attribute__((device)) __inline__ short2 __ldcv(const short2 *ptr) ;
static __attribute__((device)) __inline__ short4 __ldcv(const short4 *ptr) ;
static __attribute__((device)) __inline__ int2 __ldcv(const int2 *ptr) ;
static __attribute__((device)) __inline__ int4 __ldcv(const int4 *ptr) ;
static __attribute__((device)) __inline__ longlong2 __ldcv(const longlong2 *ptr) ;

static __attribute__((device)) __inline__ unsigned char __ldcv(const unsigned char *ptr) ;
static __attribute__((device)) __inline__ unsigned short __ldcv(const unsigned short *ptr) ;
static __attribute__((device)) __inline__ unsigned int __ldcv(const unsigned int *ptr) ;
static __attribute__((device)) __inline__ unsigned long long __ldcv(const unsigned long long *ptr) ;
static __attribute__((device)) __inline__ uchar2 __ldcv(const uchar2 *ptr) ;
static __attribute__((device)) __inline__ uchar4 __ldcv(const uchar4 *ptr) ;
static __attribute__((device)) __inline__ ushort2 __ldcv(const ushort2 *ptr) ;
static __attribute__((device)) __inline__ ushort4 __ldcv(const ushort4 *ptr) ;
static __attribute__((device)) __inline__ uint2 __ldcv(const uint2 *ptr) ;
static __attribute__((device)) __inline__ uint4 __ldcv(const uint4 *ptr) ;
static __attribute__((device)) __inline__ ulonglong2 __ldcv(const ulonglong2 *ptr) ;

static __attribute__((device)) __inline__ float __ldcv(const float *ptr) ;
static __attribute__((device)) __inline__ double __ldcv(const double *ptr) ;
static __attribute__((device)) __inline__ float2 __ldcv(const float2 *ptr) ;
static __attribute__((device)) __inline__ float4 __ldcv(const float4 *ptr) ;
static __attribute__((device)) __inline__ double2 __ldcv(const double2 *ptr) ;



static __attribute__((device)) __inline__ void __stwb(long *ptr, long value) ;
static __attribute__((device)) __inline__ void __stwb(unsigned long *ptr, unsigned long value) ;

static __attribute__((device)) __inline__ void __stwb(char *ptr, char value) ;
static __attribute__((device)) __inline__ void __stwb(signed char *ptr, signed char value) ;
static __attribute__((device)) __inline__ void __stwb(short *ptr, short value) ;
static __attribute__((device)) __inline__ void __stwb(int *ptr, int value) ;
static __attribute__((device)) __inline__ void __stwb(long long *ptr, long long value) ;
static __attribute__((device)) __inline__ void __stwb(char2 *ptr, char2 value) ;
static __attribute__((device)) __inline__ void __stwb(char4 *ptr, char4 value) ;
static __attribute__((device)) __inline__ void __stwb(short2 *ptr, short2 value) ;
static __attribute__((device)) __inline__ void __stwb(short4 *ptr, short4 value) ;
static __attribute__((device)) __inline__ void __stwb(int2 *ptr, int2 value) ;
static __attribute__((device)) __inline__ void __stwb(int4 *ptr, int4 value) ;
static __attribute__((device)) __inline__ void __stwb(longlong2 *ptr, longlong2 value) ;

static __attribute__((device)) __inline__ void __stwb(unsigned char *ptr, unsigned char value) ;
static __attribute__((device)) __inline__ void __stwb(unsigned short *ptr, unsigned short value) ;
static __attribute__((device)) __inline__ void __stwb(unsigned int *ptr, unsigned int value) ;
static __attribute__((device)) __inline__ void __stwb(unsigned long long *ptr, unsigned long long value) ;
static __attribute__((device)) __inline__ void __stwb(uchar2 *ptr, uchar2 value) ;
static __attribute__((device)) __inline__ void __stwb(uchar4 *ptr, uchar4 value) ;
static __attribute__((device)) __inline__ void __stwb(ushort2 *ptr, ushort2 value) ;
static __attribute__((device)) __inline__ void __stwb(ushort4 *ptr, ushort4 value) ;
static __attribute__((device)) __inline__ void __stwb(uint2 *ptr, uint2 value) ;
static __attribute__((device)) __inline__ void __stwb(uint4 *ptr, uint4 value) ;
static __attribute__((device)) __inline__ void __stwb(ulonglong2 *ptr, ulonglong2 value) ;

static __attribute__((device)) __inline__ void __stwb(float *ptr, float value) ;
static __attribute__((device)) __inline__ void __stwb(double *ptr, double value) ;
static __attribute__((device)) __inline__ void __stwb(float2 *ptr, float2 value) ;
static __attribute__((device)) __inline__ void __stwb(float4 *ptr, float4 value) ;
static __attribute__((device)) __inline__ void __stwb(double2 *ptr, double2 value) ;



static __attribute__((device)) __inline__ void __stcg(long *ptr, long value) ;
static __attribute__((device)) __inline__ void __stcg(unsigned long *ptr, unsigned long value) ;

static __attribute__((device)) __inline__ void __stcg(char *ptr, char value) ;
static __attribute__((device)) __inline__ void __stcg(signed char *ptr, signed char value) ;
static __attribute__((device)) __inline__ void __stcg(short *ptr, short value) ;
static __attribute__((device)) __inline__ void __stcg(int *ptr, int value) ;
static __attribute__((device)) __inline__ void __stcg(long long *ptr, long long value) ;
static __attribute__((device)) __inline__ void __stcg(char2 *ptr, char2 value) ;
static __attribute__((device)) __inline__ void __stcg(char4 *ptr, char4 value) ;
static __attribute__((device)) __inline__ void __stcg(short2 *ptr, short2 value) ;
static __attribute__((device)) __inline__ void __stcg(short4 *ptr, short4 value) ;
static __attribute__((device)) __inline__ void __stcg(int2 *ptr, int2 value) ;
static __attribute__((device)) __inline__ void __stcg(int4 *ptr, int4 value) ;
static __attribute__((device)) __inline__ void __stcg(longlong2 *ptr, longlong2 value) ;

static __attribute__((device)) __inline__ void __stcg(unsigned char *ptr, unsigned char value) ;
static __attribute__((device)) __inline__ void __stcg(unsigned short *ptr, unsigned short value) ;
static __attribute__((device)) __inline__ void __stcg(unsigned int *ptr, unsigned int value) ;
static __attribute__((device)) __inline__ void __stcg(unsigned long long *ptr, unsigned long long value) ;
static __attribute__((device)) __inline__ void __stcg(uchar2 *ptr, uchar2 value) ;
static __attribute__((device)) __inline__ void __stcg(uchar4 *ptr, uchar4 value) ;
static __attribute__((device)) __inline__ void __stcg(ushort2 *ptr, ushort2 value) ;
static __attribute__((device)) __inline__ void __stcg(ushort4 *ptr, ushort4 value) ;
static __attribute__((device)) __inline__ void __stcg(uint2 *ptr, uint2 value) ;
static __attribute__((device)) __inline__ void __stcg(uint4 *ptr, uint4 value) ;
static __attribute__((device)) __inline__ void __stcg(ulonglong2 *ptr, ulonglong2 value) ;

static __attribute__((device)) __inline__ void __stcg(float *ptr, float value) ;
static __attribute__((device)) __inline__ void __stcg(double *ptr, double value) ;
static __attribute__((device)) __inline__ void __stcg(float2 *ptr, float2 value) ;
static __attribute__((device)) __inline__ void __stcg(float4 *ptr, float4 value) ;
static __attribute__((device)) __inline__ void __stcg(double2 *ptr, double2 value) ;



static __attribute__((device)) __inline__ void __stcs(long *ptr, long value) ;
static __attribute__((device)) __inline__ void __stcs(unsigned long *ptr, unsigned long value) ;

static __attribute__((device)) __inline__ void __stcs(char *ptr, char value) ;
static __attribute__((device)) __inline__ void __stcs(signed char *ptr, signed char value) ;
static __attribute__((device)) __inline__ void __stcs(short *ptr, short value) ;
static __attribute__((device)) __inline__ void __stcs(int *ptr, int value) ;
static __attribute__((device)) __inline__ void __stcs(long long *ptr, long long value) ;
static __attribute__((device)) __inline__ void __stcs(char2 *ptr, char2 value) ;
static __attribute__((device)) __inline__ void __stcs(char4 *ptr, char4 value) ;
static __attribute__((device)) __inline__ void __stcs(short2 *ptr, short2 value) ;
static __attribute__((device)) __inline__ void __stcs(short4 *ptr, short4 value) ;
static __attribute__((device)) __inline__ void __stcs(int2 *ptr, int2 value) ;
static __attribute__((device)) __inline__ void __stcs(int4 *ptr, int4 value) ;
static __attribute__((device)) __inline__ void __stcs(longlong2 *ptr, longlong2 value) ;

static __attribute__((device)) __inline__ void __stcs(unsigned char *ptr, unsigned char value) ;
static __attribute__((device)) __inline__ void __stcs(unsigned short *ptr, unsigned short value) ;
static __attribute__((device)) __inline__ void __stcs(unsigned int *ptr, unsigned int value) ;
static __attribute__((device)) __inline__ void __stcs(unsigned long long *ptr, unsigned long long value) ;
static __attribute__((device)) __inline__ void __stcs(uchar2 *ptr, uchar2 value) ;
static __attribute__((device)) __inline__ void __stcs(uchar4 *ptr, uchar4 value) ;
static __attribute__((device)) __inline__ void __stcs(ushort2 *ptr, ushort2 value) ;
static __attribute__((device)) __inline__ void __stcs(ushort4 *ptr, ushort4 value) ;
static __attribute__((device)) __inline__ void __stcs(uint2 *ptr, uint2 value) ;
static __attribute__((device)) __inline__ void __stcs(uint4 *ptr, uint4 value) ;
static __attribute__((device)) __inline__ void __stcs(ulonglong2 *ptr, ulonglong2 value) ;

static __attribute__((device)) __inline__ void __stcs(float *ptr, float value) ;
static __attribute__((device)) __inline__ void __stcs(double *ptr, double value) ;
static __attribute__((device)) __inline__ void __stcs(float2 *ptr, float2 value) ;
static __attribute__((device)) __inline__ void __stcs(float4 *ptr, float4 value) ;
static __attribute__((device)) __inline__ void __stcs(double2 *ptr, double2 value) ;



static __attribute__((device)) __inline__ void __stwt(long *ptr, long value) ;
static __attribute__((device)) __inline__ void __stwt(unsigned long *ptr, unsigned long value) ;

static __attribute__((device)) __inline__ void __stwt(char *ptr, char value) ;
static __attribute__((device)) __inline__ void __stwt(signed char *ptr, signed char value) ;
static __attribute__((device)) __inline__ void __stwt(short *ptr, short value) ;
static __attribute__((device)) __inline__ void __stwt(int *ptr, int value) ;
static __attribute__((device)) __inline__ void __stwt(long long *ptr, long long value) ;
static __attribute__((device)) __inline__ void __stwt(char2 *ptr, char2 value) ;
static __attribute__((device)) __inline__ void __stwt(char4 *ptr, char4 value) ;
static __attribute__((device)) __inline__ void __stwt(short2 *ptr, short2 value) ;
static __attribute__((device)) __inline__ void __stwt(short4 *ptr, short4 value) ;
static __attribute__((device)) __inline__ void __stwt(int2 *ptr, int2 value) ;
static __attribute__((device)) __inline__ void __stwt(int4 *ptr, int4 value) ;
static __attribute__((device)) __inline__ void __stwt(longlong2 *ptr, longlong2 value) ;

static __attribute__((device)) __inline__ void __stwt(unsigned char *ptr, unsigned char value) ;
static __attribute__((device)) __inline__ void __stwt(unsigned short *ptr, unsigned short value) ;
static __attribute__((device)) __inline__ void __stwt(unsigned int *ptr, unsigned int value) ;
static __attribute__((device)) __inline__ void __stwt(unsigned long long *ptr, unsigned long long value) ;
static __attribute__((device)) __inline__ void __stwt(uchar2 *ptr, uchar2 value) ;
static __attribute__((device)) __inline__ void __stwt(uchar4 *ptr, uchar4 value) ;
static __attribute__((device)) __inline__ void __stwt(ushort2 *ptr, ushort2 value) ;
static __attribute__((device)) __inline__ void __stwt(ushort4 *ptr, ushort4 value) ;
static __attribute__((device)) __inline__ void __stwt(uint2 *ptr, uint2 value) ;
static __attribute__((device)) __inline__ void __stwt(uint4 *ptr, uint4 value) ;
static __attribute__((device)) __inline__ void __stwt(ulonglong2 *ptr, ulonglong2 value) ;

static __attribute__((device)) __inline__ void __stwt(float *ptr, float value) ;
static __attribute__((device)) __inline__ void __stwt(double *ptr, double value) ;
static __attribute__((device)) __inline__ void __stwt(float2 *ptr, float2 value) ;
static __attribute__((device)) __inline__ void __stwt(float4 *ptr, float4 value) ;
static __attribute__((device)) __inline__ void __stwt(double2 *ptr, double2 value) ;
# 460 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift) ;
# 472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift) ;
# 485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift) ;
# 497 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h"
static __attribute__((device)) __inline__ unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift) ;
# 507 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.hpp" 1
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.hpp"
extern "C"
{


}
# 101 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.hpp"
static __attribute__((device)) __inline__ long __ldg(const long *ptr) { unsigned long ret; asm volatile ("ld.global.nc.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldg(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.nc.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }






static __attribute__((device)) __inline__ char __ldg(const char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __attribute__((device)) __inline__ signed char __ldg(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __attribute__((device)) __inline__ short __ldg(const short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.s16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __attribute__((device)) __inline__ int __ldg(const int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.s32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldg(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldg(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.nc.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldg(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldg(const short2 *ptr) { short2 ret; asm volatile ("ld.global.nc.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ short4 __ldg(const short4 *ptr) { short4 ret; asm volatile ("ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int2 __ldg(const int2 *ptr) { int2 ret; asm volatile ("ld.global.nc.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int4 __ldg(const int4 *ptr) { int4 ret; asm volatile ("ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldg(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.nc.v2.s64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldg(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldg(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.nc.u16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldg(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.nc.u32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldg(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.nc.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldg(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.nc.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldg(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldg(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.nc.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldg(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint2 __ldg(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.nc.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint4 __ldg(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldg(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.nc.v2.u64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ float __ldg(const float *ptr) { float ret; asm volatile ("ld.global.nc.f32 %0, [%1];" : "=f"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double __ldg(const double *ptr) { double ret; asm volatile ("ld.global.nc.f64 %0, [%1];" : "=d"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float2 __ldg(const float2 *ptr) { float2 ret; asm volatile ("ld.global.nc.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float4 __ldg(const float4 *ptr) { float4 ret; asm volatile ("ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double2 __ldg(const double2 *ptr) { double2 ret; asm volatile ("ld.global.nc.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }
# 147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.hpp"
static __attribute__((device)) __inline__ long __ldcg(const long *ptr) { unsigned long ret; asm volatile ("ld.global.cg.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldcg(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.cg.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }






static __attribute__((device)) __inline__ char __ldcg(const char *ptr) { unsigned int ret; asm volatile ("ld.global.cg.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __attribute__((device)) __inline__ signed char __ldcg(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.cg.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __attribute__((device)) __inline__ short __ldcg(const short *ptr) { unsigned short ret; asm volatile ("ld.global.cg.s16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __attribute__((device)) __inline__ int __ldcg(const int *ptr) { unsigned int ret; asm volatile ("ld.global.cg.s32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldcg(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cg.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldcg(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.cg.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldcg(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.cg.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldcg(const short2 *ptr) { short2 ret; asm volatile ("ld.global.cg.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ short4 __ldcg(const short4 *ptr) { short4 ret; asm volatile ("ld.global.cg.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int2 __ldcg(const int2 *ptr) { int2 ret; asm volatile ("ld.global.cg.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int4 __ldcg(const int4 *ptr) { int4 ret; asm volatile ("ld.global.cg.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldcg(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.cg.v2.s64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldcg(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.cg.u8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldcg(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.cg.u16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldcg(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.cg.u32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldcg(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cg.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldcg(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.cg.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldcg(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.cg.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldcg(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.cg.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldcg(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.cg.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint2 __ldcg(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.cg.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint4 __ldcg(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.cg.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldcg(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.cg.v2.u64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ float __ldcg(const float *ptr) { float ret; asm volatile ("ld.global.cg.f32 %0, [%1];" : "=f"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double __ldcg(const double *ptr) { double ret; asm volatile ("ld.global.cg.f64 %0, [%1];" : "=d"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float2 __ldcg(const float2 *ptr) { float2 ret; asm volatile ("ld.global.cg.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float4 __ldcg(const float4 *ptr) { float4 ret; asm volatile ("ld.global.cg.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double2 __ldcg(const double2 *ptr) { double2 ret; asm volatile ("ld.global.cg.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }







static __attribute__((device)) __inline__ long __ldca(const long *ptr) { unsigned long ret; asm volatile ("ld.global.ca.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldca(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.ca.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }






static __attribute__((device)) __inline__ char __ldca(const char *ptr) { unsigned int ret; asm volatile ("ld.global.ca.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __attribute__((device)) __inline__ signed char __ldca(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.ca.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __attribute__((device)) __inline__ short __ldca(const short *ptr) { unsigned short ret; asm volatile ("ld.global.ca.s16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __attribute__((device)) __inline__ int __ldca(const int *ptr) { unsigned int ret; asm volatile ("ld.global.ca.s32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldca(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.ca.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldca(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.ca.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldca(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.ca.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldca(const short2 *ptr) { short2 ret; asm volatile ("ld.global.ca.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ short4 __ldca(const short4 *ptr) { short4 ret; asm volatile ("ld.global.ca.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int2 __ldca(const int2 *ptr) { int2 ret; asm volatile ("ld.global.ca.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int4 __ldca(const int4 *ptr) { int4 ret; asm volatile ("ld.global.ca.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldca(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.ca.v2.s64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldca(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.ca.u8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldca(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.ca.u16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldca(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.ca.u32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldca(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.ca.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldca(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.ca.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldca(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.ca.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldca(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.ca.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldca(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.ca.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint2 __ldca(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.ca.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint4 __ldca(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.ca.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldca(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.ca.v2.u64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ float __ldca(const float *ptr) { float ret; asm volatile ("ld.global.ca.f32 %0, [%1];" : "=f"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double __ldca(const double *ptr) { double ret; asm volatile ("ld.global.ca.f64 %0, [%1];" : "=d"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float2 __ldca(const float2 *ptr) { float2 ret; asm volatile ("ld.global.ca.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float4 __ldca(const float4 *ptr) { float4 ret; asm volatile ("ld.global.ca.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double2 __ldca(const double2 *ptr) { double2 ret; asm volatile ("ld.global.ca.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }







static __attribute__((device)) __inline__ long __ldcs(const long *ptr) { unsigned long ret; asm volatile ("ld.global.cs.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldcs(const unsigned long *ptr) { unsigned long ret; asm volatile ("ld.global.cs.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }






static __attribute__((device)) __inline__ char __ldcs(const char *ptr) { unsigned int ret; asm volatile ("ld.global.cs.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (char)ret; }
static __attribute__((device)) __inline__ signed char __ldcs(const signed char *ptr) { unsigned int ret; asm volatile ("ld.global.cs.s8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (signed char)ret; }
static __attribute__((device)) __inline__ short __ldcs(const short *ptr) { unsigned short ret; asm volatile ("ld.global.cs.s16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return (short)ret; }
static __attribute__((device)) __inline__ int __ldcs(const int *ptr) { unsigned int ret; asm volatile ("ld.global.cs.s32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldcs(const long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cs.s64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldcs(const char2 *ptr) { char2 ret; int2 tmp; asm volatile ("ld.global.cs.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldcs(const char4 *ptr) { char4 ret; int4 tmp; asm volatile ("ld.global.cs.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldcs(const short2 *ptr) { short2 ret; asm volatile ("ld.global.cs.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ short4 __ldcs(const short4 *ptr) { short4 ret; asm volatile ("ld.global.cs.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int2 __ldcs(const int2 *ptr) { int2 ret; asm volatile ("ld.global.cs.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ int4 __ldcs(const int4 *ptr) { int4 ret; asm volatile ("ld.global.cs.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldcs(const longlong2 *ptr) { longlong2 ret; asm volatile ("ld.global.cs.v2.s64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldcs(const unsigned char *ptr) { unsigned int ret; asm volatile ("ld.global.cs.u8 %0, [%1];" : "=r"(ret) : "l" (ptr)); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldcs(const unsigned short *ptr) { unsigned short ret; asm volatile ("ld.global.cs.u16 %0, [%1];" : "=h"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldcs(const unsigned int *ptr) { unsigned int ret; asm volatile ("ld.global.cs.u32 %0, [%1];" : "=r"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldcs(const unsigned long long *ptr) { unsigned long long ret; asm volatile ("ld.global.cs.u64 %0, [%1];" : "=l"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldcs(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm volatile ("ld.global.cs.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldcs(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm volatile ("ld.global.cs.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr)); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldcs(const ushort2 *ptr) { ushort2 ret; asm volatile ("ld.global.cs.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldcs(const ushort4 *ptr) { ushort4 ret; asm volatile ("ld.global.cs.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint2 __ldcs(const uint2 *ptr) { uint2 ret; asm volatile ("ld.global.cs.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ uint4 __ldcs(const uint4 *ptr) { uint4 ret; asm volatile ("ld.global.cs.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldcs(const ulonglong2 *ptr) { ulonglong2 ret; asm volatile ("ld.global.cs.v2.u64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr)); return ret; }

static __attribute__((device)) __inline__ float __ldcs(const float *ptr) { float ret; asm volatile ("ld.global.cs.f32 %0, [%1];" : "=f"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double __ldcs(const double *ptr) { double ret; asm volatile ("ld.global.cs.f64 %0, [%1];" : "=d"(ret) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float2 __ldcs(const float2 *ptr) { float2 ret; asm volatile ("ld.global.cs.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ float4 __ldcs(const float4 *ptr) { float4 ret; asm volatile ("ld.global.cs.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr)); return ret; }
static __attribute__((device)) __inline__ double2 __ldcs(const double2 *ptr) { double2 ret; asm volatile ("ld.global.cs.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr)); return ret; }







static __attribute__((device)) __inline__ long __ldlu(const long *ptr) { unsigned long ret; asm ("ld.global.lu.s64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldlu(const unsigned long *ptr) { unsigned long ret; asm ("ld.global.lu.u64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return ret; }






static __attribute__((device)) __inline__ char __ldlu(const char *ptr) { unsigned int ret; asm ("ld.global.lu.s8 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (char)ret; }
static __attribute__((device)) __inline__ signed char __ldlu(const signed char *ptr) { unsigned int ret; asm ("ld.global.lu.s8 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (signed char)ret; }
static __attribute__((device)) __inline__ short __ldlu(const short *ptr) { unsigned short ret; asm ("ld.global.lu.s16 %0, [%1];" : "=h"(ret) : "l" (ptr) : "memory"); return (short)ret; }
static __attribute__((device)) __inline__ int __ldlu(const int *ptr) { unsigned int ret; asm ("ld.global.lu.s32 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldlu(const long long *ptr) { unsigned long long ret; asm ("ld.global.lu.s64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldlu(const char2 *ptr) { char2 ret; int2 tmp; asm ("ld.global.lu.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldlu(const char4 *ptr) { char4 ret; int4 tmp; asm ("ld.global.lu.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldlu(const short2 *ptr) { short2 ret; asm ("ld.global.lu.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ short4 __ldlu(const short4 *ptr) { short4 ret; asm ("ld.global.lu.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ int2 __ldlu(const int2 *ptr) { int2 ret; asm ("ld.global.lu.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ int4 __ldlu(const int4 *ptr) { int4 ret; asm ("ld.global.lu.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldlu(const longlong2 *ptr) { longlong2 ret; asm ("ld.global.lu.v2.s64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldlu(const unsigned char *ptr) { unsigned int ret; asm ("ld.global.lu.u8 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldlu(const unsigned short *ptr) { unsigned short ret; asm ("ld.global.lu.u16 %0, [%1];" : "=h"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldlu(const unsigned int *ptr) { unsigned int ret; asm ("ld.global.lu.u32 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldlu(const unsigned long long *ptr) { unsigned long long ret; asm ("ld.global.lu.u64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldlu(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm ("ld.global.lu.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldlu(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm ("ld.global.lu.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldlu(const ushort2 *ptr) { ushort2 ret; asm ("ld.global.lu.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldlu(const ushort4 *ptr) { ushort4 ret; asm ("ld.global.lu.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ uint2 __ldlu(const uint2 *ptr) { uint2 ret; asm ("ld.global.lu.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ uint4 __ldlu(const uint4 *ptr) { uint4 ret; asm ("ld.global.lu.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldlu(const ulonglong2 *ptr) { ulonglong2 ret; asm ("ld.global.lu.v2.u64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __attribute__((device)) __inline__ float __ldlu(const float *ptr) { float ret; asm ("ld.global.lu.f32 %0, [%1];" : "=f"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ double __ldlu(const double *ptr) { double ret; asm ("ld.global.lu.f64 %0, [%1];" : "=d"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ float2 __ldlu(const float2 *ptr) { float2 ret; asm ("ld.global.lu.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ float4 __ldlu(const float4 *ptr) { float4 ret; asm ("ld.global.lu.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ double2 __ldlu(const double2 *ptr) { double2 ret; asm ("ld.global.lu.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr) : "memory"); return ret; }







static __attribute__((device)) __inline__ long __ldcv(const long *ptr) { unsigned long ret; asm ("ld.global.cv.s64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return (long)ret; }
static __attribute__((device)) __inline__ unsigned long __ldcv(const unsigned long *ptr) { unsigned long ret; asm ("ld.global.cv.u64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return ret; }






static __attribute__((device)) __inline__ char __ldcv(const char *ptr) { unsigned int ret; asm ("ld.global.cv.s8 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (char)ret; }
static __attribute__((device)) __inline__ signed char __ldcv(const signed char *ptr) { unsigned int ret; asm ("ld.global.cv.s8 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (signed char)ret; }
static __attribute__((device)) __inline__ short __ldcv(const short *ptr) { unsigned short ret; asm ("ld.global.cv.s16 %0, [%1];" : "=h"(ret) : "l" (ptr) : "memory"); return (short)ret; }
static __attribute__((device)) __inline__ int __ldcv(const int *ptr) { unsigned int ret; asm ("ld.global.cv.s32 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (int)ret; }
static __attribute__((device)) __inline__ long long __ldcv(const long long *ptr) { unsigned long long ret; asm ("ld.global.cv.s64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return (long long)ret; }
static __attribute__((device)) __inline__ char2 __ldcv(const char2 *ptr) { char2 ret; int2 tmp; asm ("ld.global.cv.v2.s8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; return ret; }
static __attribute__((device)) __inline__ char4 __ldcv(const char4 *ptr) { char4 ret; int4 tmp; asm ("ld.global.cv.v4.s8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (char)tmp.x; ret.y = (char)tmp.y; ret.z = (char)tmp.z; ret.w = (char)tmp.w; return ret; }
static __attribute__((device)) __inline__ short2 __ldcv(const short2 *ptr) { short2 ret; asm ("ld.global.cv.v2.s16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ short4 __ldcv(const short4 *ptr) { short4 ret; asm ("ld.global.cv.v4.s16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ int2 __ldcv(const int2 *ptr) { int2 ret; asm ("ld.global.cv.v2.s32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ int4 __ldcv(const int4 *ptr) { int4 ret; asm ("ld.global.cv.v4.s32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ longlong2 __ldcv(const longlong2 *ptr) { longlong2 ret; asm ("ld.global.cv.v2.s64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __attribute__((device)) __inline__ unsigned char __ldcv(const unsigned char *ptr) { unsigned int ret; asm ("ld.global.cv.u8 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return (unsigned char)ret; }
static __attribute__((device)) __inline__ unsigned short __ldcv(const unsigned short *ptr) { unsigned short ret; asm ("ld.global.cv.u16 %0, [%1];" : "=h"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ unsigned int __ldcv(const unsigned int *ptr) { unsigned int ret; asm ("ld.global.cv.u32 %0, [%1];" : "=r"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ unsigned long long __ldcv(const unsigned long long *ptr) { unsigned long long ret; asm ("ld.global.cv.u64 %0, [%1];" : "=l"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ uchar2 __ldcv(const uchar2 *ptr) { uchar2 ret; uint2 tmp; asm ("ld.global.cv.v2.u8 {%0,%1}, [%2];" : "=r"(tmp.x), "=r"(tmp.y) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; return ret; }
static __attribute__((device)) __inline__ uchar4 __ldcv(const uchar4 *ptr) { uchar4 ret; uint4 tmp; asm ("ld.global.cv.v4.u8 {%0,%1,%2,%3}, [%4];" : "=r"(tmp.x), "=r"(tmp.y), "=r"(tmp.z), "=r"(tmp.w) : "l" (ptr) : "memory"); ret.x = (unsigned char)tmp.x; ret.y = (unsigned char)tmp.y; ret.z = (unsigned char)tmp.z; ret.w = (unsigned char)tmp.w; return ret; }
static __attribute__((device)) __inline__ ushort2 __ldcv(const ushort2 *ptr) { ushort2 ret; asm ("ld.global.cv.v2.u16 {%0,%1}, [%2];" : "=h"(ret.x), "=h"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ ushort4 __ldcv(const ushort4 *ptr) { ushort4 ret; asm ("ld.global.cv.v4.u16 {%0,%1,%2,%3}, [%4];" : "=h"(ret.x), "=h"(ret.y), "=h"(ret.z), "=h"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ uint2 __ldcv(const uint2 *ptr) { uint2 ret; asm ("ld.global.cv.v2.u32 {%0,%1}, [%2];" : "=r"(ret.x), "=r"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ uint4 __ldcv(const uint4 *ptr) { uint4 ret; asm ("ld.global.cv.v4.u32 {%0,%1,%2,%3}, [%4];" : "=r"(ret.x), "=r"(ret.y), "=r"(ret.z), "=r"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ ulonglong2 __ldcv(const ulonglong2 *ptr) { ulonglong2 ret; asm ("ld.global.cv.v2.u64 {%0,%1}, [%2];" : "=l"(ret.x), "=l"(ret.y) : "l" (ptr) : "memory"); return ret; }

static __attribute__((device)) __inline__ float __ldcv(const float *ptr) { float ret; asm ("ld.global.cv.f32 %0, [%1];" : "=f"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ double __ldcv(const double *ptr) { double ret; asm ("ld.global.cv.f64 %0, [%1];" : "=d"(ret) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ float2 __ldcv(const float2 *ptr) { float2 ret; asm ("ld.global.cv.v2.f32 {%0,%1}, [%2];" : "=f"(ret.x), "=f"(ret.y) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ float4 __ldcv(const float4 *ptr) { float4 ret; asm ("ld.global.cv.v4.f32 {%0,%1,%2,%3}, [%4];" : "=f"(ret.x), "=f"(ret.y), "=f"(ret.z), "=f"(ret.w) : "l" (ptr) : "memory"); return ret; }
static __attribute__((device)) __inline__ double2 __ldcv(const double2 *ptr) { double2 ret; asm ("ld.global.cv.v2.f64 {%0,%1}, [%2];" : "=d"(ret.x), "=d"(ret.y) : "l" (ptr) : "memory"); return ret; }







static __attribute__((device)) __inline__ void __stwb(long *ptr, long value) { asm ("st.global.wb.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(unsigned long *ptr, unsigned long value) { asm ("st.global.wb.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }






static __attribute__((device)) __inline__ void __stwb(char *ptr, char value) { asm ("st.global.wb.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(signed char *ptr, signed char value) { asm ("st.global.wb.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(short *ptr, short value) { asm ("st.global.wb.s16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(int *ptr, int value) { asm ("st.global.wb.s32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(long long *ptr, long long value) { asm ("st.global.wb.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.wb.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wb.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(short2 *ptr, short2 value) { asm ("st.global.wb.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(short4 *ptr, short4 value) { asm ("st.global.wb.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(int2 *ptr, int2 value) { asm ("st.global.wb.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(int4 *ptr, int4 value) { asm ("st.global.wb.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(longlong2 *ptr, longlong2 value) { asm ("st.global.wb.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stwb(unsigned char *ptr, unsigned char value) { asm ("st.global.wb.u8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(unsigned short *ptr, unsigned short value) { asm ("st.global.wb.u16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(unsigned int *ptr, unsigned int value) { asm ("st.global.wb.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(unsigned long long *ptr, unsigned long long value) { asm ("st.global.wb.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.wb.v2.u8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wb.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(ushort2 *ptr, ushort2 value) { asm ("st.global.wb.v2.u16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(ushort4 *ptr, ushort4 value) { asm ("st.global.wb.v4.u16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(uint2 *ptr, uint2 value) { asm ("st.global.wb.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(uint4 *ptr, uint4 value) { asm ("st.global.wb.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.wb.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stwb(float *ptr, float value) { asm ("st.global.wb.f32 [%0], %1;" :: "l" (ptr), "f"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(double *ptr, double value) { asm ("st.global.wb.f64 [%0], %1;" :: "l" (ptr), "d"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(float2 *ptr, float2 value) { asm ("st.global.wb.v2.f32 [%0], {%1,%2};" :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(float4 *ptr, float4 value) { asm ("st.global.wb.v4.f32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwb(double2 *ptr, double2 value) { asm ("st.global.wb.v2.f64 [%0], {%1,%2};" :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }







static __attribute__((device)) __inline__ void __stcg(long *ptr, long value) { asm ("st.global.cg.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(unsigned long *ptr, unsigned long value) { asm ("st.global.cg.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }






static __attribute__((device)) __inline__ void __stcg(char *ptr, char value) { asm ("st.global.cg.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(signed char *ptr, signed char value) { asm ("st.global.cg.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(short *ptr, short value) { asm ("st.global.cg.s16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(int *ptr, int value) { asm ("st.global.cg.s32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(long long *ptr, long long value) { asm ("st.global.cg.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.cg.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cg.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(short2 *ptr, short2 value) { asm ("st.global.cg.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(short4 *ptr, short4 value) { asm ("st.global.cg.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(int2 *ptr, int2 value) { asm ("st.global.cg.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(int4 *ptr, int4 value) { asm ("st.global.cg.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(longlong2 *ptr, longlong2 value) { asm ("st.global.cg.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stcg(unsigned char *ptr, unsigned char value) { asm ("st.global.cg.u8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(unsigned short *ptr, unsigned short value) { asm ("st.global.cg.u16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(unsigned int *ptr, unsigned int value) { asm ("st.global.cg.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(unsigned long long *ptr, unsigned long long value) { asm ("st.global.cg.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.cg.v2.u8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cg.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(ushort2 *ptr, ushort2 value) { asm ("st.global.cg.v2.u16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(ushort4 *ptr, ushort4 value) { asm ("st.global.cg.v4.u16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(uint2 *ptr, uint2 value) { asm ("st.global.cg.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(uint4 *ptr, uint4 value) { asm ("st.global.cg.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.cg.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stcg(float *ptr, float value) { asm ("st.global.cg.f32 [%0], %1;" :: "l" (ptr), "f"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(double *ptr, double value) { asm ("st.global.cg.f64 [%0], %1;" :: "l" (ptr), "d"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(float2 *ptr, float2 value) { asm ("st.global.cg.v2.f32 [%0], {%1,%2};" :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(float4 *ptr, float4 value) { asm ("st.global.cg.v4.f32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcg(double2 *ptr, double2 value) { asm ("st.global.cg.v2.f64 [%0], {%1,%2};" :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }







static __attribute__((device)) __inline__ void __stcs(long *ptr, long value) { asm ("st.global.cs.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(unsigned long *ptr, unsigned long value) { asm ("st.global.cs.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }






static __attribute__((device)) __inline__ void __stcs(char *ptr, char value) { asm ("st.global.cs.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(signed char *ptr, signed char value) { asm ("st.global.cs.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(short *ptr, short value) { asm ("st.global.cs.s16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(int *ptr, int value) { asm ("st.global.cs.s32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(long long *ptr, long long value) { asm ("st.global.cs.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.cs.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cs.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(short2 *ptr, short2 value) { asm ("st.global.cs.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(short4 *ptr, short4 value) { asm ("st.global.cs.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(int2 *ptr, int2 value) { asm ("st.global.cs.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(int4 *ptr, int4 value) { asm ("st.global.cs.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(longlong2 *ptr, longlong2 value) { asm ("st.global.cs.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stcs(unsigned char *ptr, unsigned char value) { asm ("st.global.cs.u8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(unsigned short *ptr, unsigned short value) { asm ("st.global.cs.u16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(unsigned int *ptr, unsigned int value) { asm ("st.global.cs.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(unsigned long long *ptr, unsigned long long value) { asm ("st.global.cs.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.cs.v2.u8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.cs.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(ushort2 *ptr, ushort2 value) { asm ("st.global.cs.v2.u16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(ushort4 *ptr, ushort4 value) { asm ("st.global.cs.v4.u16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(uint2 *ptr, uint2 value) { asm ("st.global.cs.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(uint4 *ptr, uint4 value) { asm ("st.global.cs.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.cs.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stcs(float *ptr, float value) { asm ("st.global.cs.f32 [%0], %1;" :: "l" (ptr), "f"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(double *ptr, double value) { asm ("st.global.cs.f64 [%0], %1;" :: "l" (ptr), "d"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(float2 *ptr, float2 value) { asm ("st.global.cs.v2.f32 [%0], {%1,%2};" :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(float4 *ptr, float4 value) { asm ("st.global.cs.v4.f32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stcs(double2 *ptr, double2 value) { asm ("st.global.cs.v2.f64 [%0], {%1,%2};" :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }







static __attribute__((device)) __inline__ void __stwt(long *ptr, long value) { asm ("st.global.wt.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(unsigned long *ptr, unsigned long value) { asm ("st.global.wt.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }






static __attribute__((device)) __inline__ void __stwt(char *ptr, char value) { asm ("st.global.wt.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(signed char *ptr, signed char value) { asm ("st.global.wt.s8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(short *ptr, short value) { asm ("st.global.wt.s16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(int *ptr, int value) { asm ("st.global.wt.s32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(long long *ptr, long long value) { asm ("st.global.wt.s64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(char2 *ptr, char2 value) { const int x = value.x, y = value.y; asm ("st.global.wt.v2.s8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(char4 *ptr, char4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wt.v4.s8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(short2 *ptr, short2 value) { asm ("st.global.wt.v2.s16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(short4 *ptr, short4 value) { asm ("st.global.wt.v4.s16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(int2 *ptr, int2 value) { asm ("st.global.wt.v2.s32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(int4 *ptr, int4 value) { asm ("st.global.wt.v4.s32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(longlong2 *ptr, longlong2 value) { asm ("st.global.wt.v2.s64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stwt(unsigned char *ptr, unsigned char value) { asm ("st.global.wt.u8 [%0], %1;" :: "l" (ptr), "r"((int)value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(unsigned short *ptr, unsigned short value) { asm ("st.global.wt.u16 [%0], %1;" :: "l" (ptr), "h"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(unsigned int *ptr, unsigned int value) { asm ("st.global.wt.u32 [%0], %1;" :: "l" (ptr), "r"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(unsigned long long *ptr, unsigned long long value) { asm ("st.global.wt.u64 [%0], %1;" :: "l" (ptr), "l"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(uchar2 *ptr, uchar2 value) { const int x = value.x, y = value.y; asm ("st.global.wt.v2.u8 [%0], {%1,%2};" :: "l" (ptr), "r"(x), "r"(y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(uchar4 *ptr, uchar4 value) { const int x = value.x, y = value.y, z = value.z, w = value.w; asm ("st.global.wt.v4.u8 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(x), "r"(y), "r"(z), "r"(w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(ushort2 *ptr, ushort2 value) { asm ("st.global.wt.v2.u16 [%0], {%1,%2};" :: "l" (ptr), "h"(value.x), "h"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(ushort4 *ptr, ushort4 value) { asm ("st.global.wt.v4.u16 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "h"(value.x), "h"(value.y), "h"(value.z), "h"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(uint2 *ptr, uint2 value) { asm ("st.global.wt.v2.u32 [%0], {%1,%2};" :: "l" (ptr), "r"(value.x), "r"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(uint4 *ptr, uint4 value) { asm ("st.global.wt.v4.u32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "r"(value.x), "r"(value.y), "r"(value.z), "r"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(ulonglong2 *ptr, ulonglong2 value) { asm ("st.global.wt.v2.u64 [%0], {%1,%2};" :: "l" (ptr), "l"(value.x), "l"(value.y) : "memory"); }

static __attribute__((device)) __inline__ void __stwt(float *ptr, float value) { asm ("st.global.wt.f32 [%0], %1;" :: "l" (ptr), "f"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(double *ptr, double value) { asm ("st.global.wt.f64 [%0], %1;" :: "l" (ptr), "d"(value) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(float2 *ptr, float2 value) { asm ("st.global.wt.v2.f32 [%0], {%1,%2};" :: "l" (ptr), "f"(value.x), "f"(value.y) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(float4 *ptr, float4 value) { asm ("st.global.wt.v4.f32 [%0], {%1,%2,%3,%4};" :: "l" (ptr), "f"(value.x), "f"(value.y), "f"(value.z), "f"(value.w) : "memory"); }
static __attribute__((device)) __inline__ void __stwt(double2 *ptr, double2 value) { asm ("st.global.wt.v2.f64 [%0], {%1,%2};" :: "l" (ptr), "d"(value.x), "d"(value.y) : "memory"); }
# 553 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.hpp"
static __attribute__((device)) __inline__ unsigned int __funnelshift_l(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __attribute__((device)) __inline__ unsigned int __funnelshift_lc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.l.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}


static __attribute__((device)) __inline__ unsigned int __funnelshift_r(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.wrap.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
static __attribute__((device)) __inline__ unsigned int __funnelshift_rc(unsigned int lo, unsigned int hi, unsigned int shift)
{
    unsigned int ret;
    asm volatile ("shf.r.clamp.b32 %0, %1, %2, %3;" : "=r"(ret) : "r"(lo), "r"(hi), "r"(shift));
    return ret;
}
# 508 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h" 2
# 3297 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_35_intrinsics.h" 1
# 111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_35_intrinsics.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_32_intrinsics.h" 1
# 112 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_35_intrinsics.h" 2
# 3298 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_61_intrinsics.h" 1
# 120 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_61_intrinsics.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_61_intrinsics.hpp" 1
# 121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/sm_61_intrinsics.h" 2
# 3299 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_70_rt.h" 1
# 123 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_70_rt.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_70_rt.hpp" 1
# 124 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_70_rt.h" 2
# 3300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_80_rt.h" 1
# 150 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_80_rt.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_80_rt.hpp" 1
# 151 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/sm_80_rt.h" 2
# 3301 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_functions.h" 1
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_functions.h"
template <typename T> struct __nv_surf_trait { typedef void * cast_type; };

template<> struct __nv_surf_trait<char> { typedef char * cast_type; };
template<> struct __nv_surf_trait<signed char> { typedef signed char * cast_type; };
template<> struct __nv_surf_trait<unsigned char> { typedef unsigned char * cast_type; };
template<> struct __nv_surf_trait<char1> { typedef char1 * cast_type; };
template<> struct __nv_surf_trait<uchar1> { typedef uchar1 * cast_type; };
template<> struct __nv_surf_trait<char2> { typedef char2 * cast_type; };
template<> struct __nv_surf_trait<uchar2> { typedef uchar2 * cast_type; };
template<> struct __nv_surf_trait<char4> { typedef char4 * cast_type; };
template<> struct __nv_surf_trait<uchar4> { typedef uchar4 * cast_type; };
template<> struct __nv_surf_trait<short> { typedef short * cast_type; };
template<> struct __nv_surf_trait<unsigned short> { typedef unsigned short * cast_type; };
template<> struct __nv_surf_trait<short1> { typedef short1 * cast_type; };
template<> struct __nv_surf_trait<ushort1> { typedef ushort1 * cast_type; };
template<> struct __nv_surf_trait<short2> { typedef short2 * cast_type; };
template<> struct __nv_surf_trait<ushort2> { typedef ushort2 * cast_type; };
template<> struct __nv_surf_trait<short4> { typedef short4 * cast_type; };
template<> struct __nv_surf_trait<ushort4> { typedef ushort4 * cast_type; };
template<> struct __nv_surf_trait<int> { typedef int * cast_type; };
template<> struct __nv_surf_trait<unsigned int> { typedef unsigned int * cast_type; };
template<> struct __nv_surf_trait<int1> { typedef int1 * cast_type; };
template<> struct __nv_surf_trait<uint1> { typedef uint1 * cast_type; };
template<> struct __nv_surf_trait<int2> { typedef int2 * cast_type; };
template<> struct __nv_surf_trait<uint2> { typedef uint2 * cast_type; };
template<> struct __nv_surf_trait<int4> { typedef int4 * cast_type; };
template<> struct __nv_surf_trait<uint4> { typedef uint4 * cast_type; };
template<> struct __nv_surf_trait<long long> { typedef long long * cast_type; };
template<> struct __nv_surf_trait<unsigned long long> { typedef unsigned long long * cast_type; };
template<> struct __nv_surf_trait<longlong1> { typedef longlong1 * cast_type; };
template<> struct __nv_surf_trait<ulonglong1> { typedef ulonglong1 * cast_type; };
template<> struct __nv_surf_trait<longlong2> { typedef longlong2 * cast_type; };
template<> struct __nv_surf_trait<ulonglong2> { typedef ulonglong2 * cast_type; };
# 116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_functions.h"
template<> struct __nv_surf_trait<float> { typedef float * cast_type; };
template<> struct __nv_surf_trait<float1> { typedef float1 * cast_type; };
template<> struct __nv_surf_trait<float2> { typedef float2 * cast_type; };
template<> struct __nv_surf_trait<float4> { typedef float4 * cast_type; };


template <typename T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dread(T *res, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1Dread_v2", (void *)res, s, surf, x, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surf1Dread(surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf1Dread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, mode);
  return temp;

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dread(T *res, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf1Dread<T>(surf, x, mode);

}


template <typename T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2Dread_v2", (void *)res, s, surf, x, y, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surf2Dread(surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf2Dread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, mode);
  return temp;

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dread(T *res, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf2Dread<T>(surf, x, y, mode);

}


template <typename T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf3Dread_v2", (void *)res, s, surf, x, y, z, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surf3Dread(surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf3Dread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, z, mode);
  return temp;

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dread(T *res, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf3Dread<T>(surf, x, y, z, mode);

}



template <typename T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1DLayeredread_v2", (void *)res, s, surf, x, layer, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surf1DLayeredread(surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf1DLayeredread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, layer, mode);
  return temp;

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredread(T *res, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf1DLayeredread<T>(surf, x, layer, mode);

}


template <typename T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2DLayeredread_v2", (void *)res, s, surf, x, y, layer, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surf2DLayeredread(surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surf2DLayeredread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, layer, mode);
  return temp;

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredread(T *res, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surf2DLayeredread<T>(surf, x, y, layer, mode);

}


template <typename T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapread_v2", (void *)res, s, surf, x, y, face, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surfCubemapread(surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;

  __nv_tex_surf_handler("__surfCubemapread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, face, mode);
  return temp;

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapread(T *res, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surfCubemapread<T>(surf, x, y, face, mode);

}


template <typename T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapLayeredread_v2", (void *)res, s, surf, x, y, layerFace, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) T surfCubemapLayeredread(surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  T temp;
  __nv_tex_surf_handler("__surfCubemapLayeredread_v2", (typename __nv_surf_trait<T>::cast_type)&temp, (int)sizeof(T), surf, x, y, layerFace, mode);
  return temp;

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredread(T *res, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  *res = surfCubemapLayeredread<T>(surf, x, y, layerFace, mode);

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1Dwrite_v2", (void *)&val, s, surf, x, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1Dwrite(T val, surface<void, 0x01> surf, int x, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1Dwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, mode);

}



template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2Dwrite_v2", (void *)&val, s, surf, x, y, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2Dwrite(T val, surface<void, 0x02> surf, int x, int y, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2Dwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, mode);

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf3Dwrite_v2", (void *)&val, s, surf, x, y, z,mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf3Dwrite(T val, surface<void, 0x03> surf, int x, int y, int z, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf3Dwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, z, mode);

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1DLayeredwrite_v2", (void *)&val, s, surf, x, layer,mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf1DLayeredwrite(T val, surface<void, 0xF1> surf, int x, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf1DLayeredwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, layer, mode);

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2DLayeredwrite_v2", (void *)&val, s, surf, x, y, layer,mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surf2DLayeredwrite(T val, surface<void, 0xF2> surf, int x, int y, int layer, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surf2DLayeredwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, layer, mode);

}


template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapwrite_v2", (void *)&val, s, surf, x, y, face, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapwrite(T val, surface<void, 0x0C> surf, int x, int y, int face, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, face, mode);

}



template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, int s, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapLayeredwrite_v2", (void *)&val, s, surf, x, y, layerFace, mode);

}

template<class T>
static __attribute__((deprecated)) __attribute__((device)) __inline__ __attribute__((always_inline)) void surfCubemapLayeredwrite(T val, surface<void, 0xFC> surf, int x, int y, int layerFace, enum cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__surfCubemapLayeredwrite_v2", (typename __nv_surf_trait<T>::cast_type)&val, (int)sizeof(T), surf, x, y, layerFace, mode);

}
# 3302 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_fetch_functions.h" 1
# 72 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_fetch_functions.h"
template <typename T>
struct __nv_tex_rmet_ret { };

template<> struct __nv_tex_rmet_ret<char> { typedef char type; };
template<> struct __nv_tex_rmet_ret<signed char> { typedef signed char type; };
template<> struct __nv_tex_rmet_ret<unsigned char> { typedef unsigned char type; };
template<> struct __nv_tex_rmet_ret<char1> { typedef char1 type; };
template<> struct __nv_tex_rmet_ret<uchar1> { typedef uchar1 type; };
template<> struct __nv_tex_rmet_ret<char2> { typedef char2 type; };
template<> struct __nv_tex_rmet_ret<uchar2> { typedef uchar2 type; };
template<> struct __nv_tex_rmet_ret<char4> { typedef char4 type; };
template<> struct __nv_tex_rmet_ret<uchar4> { typedef uchar4 type; };

template<> struct __nv_tex_rmet_ret<short> { typedef short type; };
template<> struct __nv_tex_rmet_ret<unsigned short> { typedef unsigned short type; };
template<> struct __nv_tex_rmet_ret<short1> { typedef short1 type; };
template<> struct __nv_tex_rmet_ret<ushort1> { typedef ushort1 type; };
template<> struct __nv_tex_rmet_ret<short2> { typedef short2 type; };
template<> struct __nv_tex_rmet_ret<ushort2> { typedef ushort2 type; };
template<> struct __nv_tex_rmet_ret<short4> { typedef short4 type; };
template<> struct __nv_tex_rmet_ret<ushort4> { typedef ushort4 type; };

template<> struct __nv_tex_rmet_ret<int> { typedef int type; };
template<> struct __nv_tex_rmet_ret<unsigned int> { typedef unsigned int type; };
template<> struct __nv_tex_rmet_ret<int1> { typedef int1 type; };
template<> struct __nv_tex_rmet_ret<uint1> { typedef uint1 type; };
template<> struct __nv_tex_rmet_ret<int2> { typedef int2 type; };
template<> struct __nv_tex_rmet_ret<uint2> { typedef uint2 type; };
template<> struct __nv_tex_rmet_ret<int4> { typedef int4 type; };
template<> struct __nv_tex_rmet_ret<uint4> { typedef uint4 type; };
# 113 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret<float> { typedef float type; };
template<> struct __nv_tex_rmet_ret<float1> { typedef float1 type; };
template<> struct __nv_tex_rmet_ret<float2> { typedef float2 type; };
template<> struct __nv_tex_rmet_ret<float4> { typedef float4 type; };


template <typename T> struct __nv_tex_rmet_cast { typedef T* type; };
# 131 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_fetch_functions.h"
template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1Dfetch(texture<T, 0x01, cudaReadModeElementType> t, int x)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1Dfetch_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x);
  return temp;

}

template <typename T>
struct __nv_tex_rmnf_ret { };

template <> struct __nv_tex_rmnf_ret<char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<signed char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<unsigned char> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<short> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<unsigned short> { typedef float type; };
template <> struct __nv_tex_rmnf_ret<char1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<uchar1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<short1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<ushort1> { typedef float1 type; };
template <> struct __nv_tex_rmnf_ret<char2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<uchar2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<short2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<ushort2> { typedef float2 type; };
template <> struct __nv_tex_rmnf_ret<char4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<uchar4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<short4> { typedef float4 type; };
template <> struct __nv_tex_rmnf_ret<ushort4> { typedef float4 type; };

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1Dfetch(texture<T, 0x01, cudaReadModeNormalizedFloat> t, int x)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1Dfetch_rmnf_v2", &type_dummy, &retval, t, x);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1D(texture<T, 0x01, cudaReadModeElementType> t, float x)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1D_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1D(texture<T, 0x01, cudaReadModeNormalizedFloat> t, float x)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1D_rmnf_v2", &type_dummy, &retval, t, x);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex2D(texture<T, 0x02, cudaReadModeElementType> t, float x, float y)
{

  typename __nv_tex_rmet_ret<T>::type temp;

  __nv_tex_surf_handler("__tex2D_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2D(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2D_rmnf_v2", &type_dummy, &retval, t, x, y);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1DLayered(texture<T, 0xF1, cudaReadModeElementType> t, float x, int layer)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLayered_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, layer);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLayered(texture<T, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLayered_rmnf_v2", &type_dummy, &retval, t, x, layer);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex2DLayered(texture<T, 0xF2, cudaReadModeElementType> t, float x, float y, int layer)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLayered_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y, layer);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLayered(texture<T, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLayered_rmnf_v2", &type_dummy, &retval, t, x, y, layer);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex3D(texture<T, 0x03, cudaReadModeElementType> t, float x, float y, float z)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex3D_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y, z);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex3D(texture<T, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex3D_rmnf_v2", &type_dummy, &retval, t, x, y, z);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type texCubemap(texture<T, 0x0C, cudaReadModeElementType> t, float x, float y, float z)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemap_v2", (typename __nv_tex_rmet_cast<T>::type) &temp, t, x, y, z);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemap(texture<T, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemap_rmnf_v2", &type_dummy, &retval, t, x, y, z);
  return retval;

}


template <typename T>
struct __nv_tex2dgather_ret { };
template <> struct __nv_tex2dgather_ret<char> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<signed char> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char1> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char2> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char3> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<char4> { typedef char4 type; };
template <> struct __nv_tex2dgather_ret<unsigned char> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar1> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar2> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar3> { typedef uchar4 type; };
template <> struct __nv_tex2dgather_ret<uchar4> { typedef uchar4 type; };

template <> struct __nv_tex2dgather_ret<short> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short1> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short2> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short3> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<short4> { typedef short4 type; };
template <> struct __nv_tex2dgather_ret<unsigned short> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort1> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort2> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort3> { typedef ushort4 type; };
template <> struct __nv_tex2dgather_ret<ushort4> { typedef ushort4 type; };

template <> struct __nv_tex2dgather_ret<int> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int1> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int2> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int3> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<int4> { typedef int4 type; };
template <> struct __nv_tex2dgather_ret<unsigned int> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint1> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint2> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint3> { typedef uint4 type; };
template <> struct __nv_tex2dgather_ret<uint4> { typedef uint4 type; };

template <> struct __nv_tex2dgather_ret<float> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float1> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float2> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float3> { typedef float4 type; };
template <> struct __nv_tex2dgather_ret<float4> { typedef float4 type; };

template <typename T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) typename __nv_tex2dgather_ret<T>::type tex2Dgather(texture<T, 0x02, cudaReadModeElementType> t, float x, float y, int comp=0)
{

  T type_dummy;
  typename __nv_tex2dgather_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2Dgather_v2", &type_dummy, &retval, t, x, y, comp);
  return retval;

}


template<typename T> struct __nv_tex2dgather_rmnf_ret { };
template<> struct __nv_tex2dgather_rmnf_ret<char> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<signed char> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<unsigned char> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<char4> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<uchar4> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<signed short> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<unsigned short> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort1> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort2> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort3> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<short4> { typedef float4 type; };
template<> struct __nv_tex2dgather_rmnf_ret<ushort4> { typedef float4 type; };

template <typename T>
static __attribute__((device)) __inline__ __attribute__((always_inline)) typename __nv_tex2dgather_rmnf_ret<T>::type tex2Dgather(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, int comp = 0)
{

  T type_dummy;
  typename __nv_tex2dgather_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2Dgather_rmnf_v2", &type_dummy, &retval, t, x, y, comp);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1DLod(texture<T, 0x01, cudaReadModeElementType> t, float x, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLod(texture<T, 0x01, cudaReadModeNormalizedFloat> t, float x, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLod_rmnf_v2", &type_dummy, &retval, t, x, level);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex2DLod(texture<T, 0x02, cudaReadModeElementType> t, float x, float y, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLod(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLod_rmnf_v2", &type_dummy, &retval, t, x, y, level);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1DLayeredLod(texture<T, 0xF1, cudaReadModeElementType> t, float x, int layer, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLayeredLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, layer, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLayeredLod(texture<T, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLayeredLod_rmnf_v2", &type_dummy, &retval, t, x, layer, level);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex2DLayeredLod(texture<T, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLayeredLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, layer, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLayeredLod(texture<T, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLayeredLod_rmnf_v2", &type_dummy, &retval, t, x, y, layer, level);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex3DLod(texture<T, 0x03, cudaReadModeElementType> t, float x, float y, float z, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex3DLod_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex3DLod(texture<T, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex3DLod_rmnf_v2", &type_dummy, &retval, t, x, y, z, level);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type texCubemapLod(texture<T, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLod_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLod(texture<T, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLod_rmnf_v2", &type_dummy, &retval, t, x, y, z, level);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type texCubemapLayered(texture<T, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLayered_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, layer);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLayered(texture<T, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLayered_rmnf_v2", &type_dummy, &retval, t, x, y, z, layer);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type texCubemapLayeredLod(texture<T, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float level)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLayeredLod_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, layer, level);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLayeredLod(texture<T, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float level)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLayeredLod_rmnf_v2", &type_dummy, &retval, t, x, y, z, layer, level);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type texCubemapGrad(texture<T, 0x0C, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, &dPdx, &dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapGrad(texture<T, 0x0C, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapGrad_rmnf_v2", &type_dummy, &retval, t, x, y, z, &dPdx, &dPdy);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type texCubemapLayeredGrad(texture<T, 0xFC, cudaReadModeElementType> t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__texCubemapLayeredGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, layer, &dPdx, &dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type texCubemapLayeredGrad(texture<T, 0xFC, cudaReadModeNormalizedFloat> t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__texCubemapLayeredGrad_rmnf_v2", &type_dummy, &retval,t, x, y, z, layer, &dPdx, &dPdy);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1DGrad(texture<T, 0x01, cudaReadModeElementType> t, float x, float dPdx, float dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, dPdx, dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DGrad(texture<T, 0x01, cudaReadModeNormalizedFloat> t, float x, float dPdx, float dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DGrad_rmnf_v2", &type_dummy, &retval,t, x,dPdx, dPdy);
  return retval;

}



template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex2DGrad(texture<T, 0x02, cudaReadModeElementType> t, float x, float y, float2 dPdx, float2 dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, &dPdx, &dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DGrad(texture<T, 0x02, cudaReadModeNormalizedFloat> t, float x, float y, float2 dPdx, float2 dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DGrad_rmnf_v2", &type_dummy, &retval,t, x, y, &dPdx, &dPdy);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex1DLayeredGrad(texture<T, 0xF1, cudaReadModeElementType> t, float x, int layer, float dPdx, float dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex1DLayeredGrad_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, layer, dPdx, dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex1DLayeredGrad(texture<T, 0xF1, cudaReadModeNormalizedFloat> t, float x, int layer, float dPdx, float dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex1DLayeredGrad_rmnf_v2", &type_dummy, &retval,t, x, layer, dPdx, dPdy);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex2DLayeredGrad(texture<T, 0xF2, cudaReadModeElementType> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex2DLayeredGrad_v2",(typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, layer, &dPdx, &dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex2DLayeredGrad(texture<T, 0xF2, cudaReadModeNormalizedFloat> t, float x, float y, int layer, float2 dPdx, float2 dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex2DLayeredGrad_rmnf_v2", &type_dummy, &retval,t, x, y, layer, &dPdx, &dPdy);
  return retval;

}


template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmet_ret<T>::type tex3DGrad(texture<T, 0x03, cudaReadModeElementType> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  typename __nv_tex_rmet_ret<T>::type temp;
  __nv_tex_surf_handler("__tex3DGrad_v2", (typename __nv_tex_rmet_cast<T>::type)&temp, t, x, y, z, &dPdx, &dPdy);
  return temp;

}

template <typename T>
static __attribute__((deprecated)) __inline__ __attribute__((always_inline)) __attribute__((device)) typename __nv_tex_rmnf_ret<T>::type tex3DGrad(texture<T, 0x03, cudaReadModeNormalizedFloat> t, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  T type_dummy;
  typename __nv_tex_rmnf_ret<T>::type retval;
  __nv_tex_surf_handler("__tex3DGrad_rmnf_v2", &type_dummy, &retval,t, x, y, z, &dPdx, &dPdy);
  return retval;

}
# 3303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h" 1
# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T> struct __nv_itex_trait { };
template<> struct __nv_itex_trait<char> { typedef void type; };
template<> struct __nv_itex_trait<signed char> { typedef void type; };
template<> struct __nv_itex_trait<char1> { typedef void type; };
template<> struct __nv_itex_trait<char2> { typedef void type; };
template<> struct __nv_itex_trait<char4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned char> { typedef void type; };
template<> struct __nv_itex_trait<uchar1> { typedef void type; };
template<> struct __nv_itex_trait<uchar2> { typedef void type; };
template<> struct __nv_itex_trait<uchar4> { typedef void type; };
template<> struct __nv_itex_trait<short> { typedef void type; };
template<> struct __nv_itex_trait<short1> { typedef void type; };
template<> struct __nv_itex_trait<short2> { typedef void type; };
template<> struct __nv_itex_trait<short4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned short> { typedef void type; };
template<> struct __nv_itex_trait<ushort1> { typedef void type; };
template<> struct __nv_itex_trait<ushort2> { typedef void type; };
template<> struct __nv_itex_trait<ushort4> { typedef void type; };
template<> struct __nv_itex_trait<int> { typedef void type; };
template<> struct __nv_itex_trait<int1> { typedef void type; };
template<> struct __nv_itex_trait<int2> { typedef void type; };
template<> struct __nv_itex_trait<int4> { typedef void type; };
template<> struct __nv_itex_trait<unsigned int> { typedef void type; };
template<> struct __nv_itex_trait<uint1> { typedef void type; };
template<> struct __nv_itex_trait<uint2> { typedef void type; };
template<> struct __nv_itex_trait<uint4> { typedef void type; };
# 100 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template<> struct __nv_itex_trait<float> { typedef void type; };
template<> struct __nv_itex_trait<float1> { typedef void type; };
template<> struct __nv_itex_trait<float2> { typedef void type; };
template<> struct __nv_itex_trait<float4> { typedef void type; };



template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x)
{

   __nv_tex_surf_handler("__itex1Dfetch", ptr, obj, x);

}

template <class T>
static __attribute__((device)) T tex1Dfetch(cudaTextureObject_t texObject, int x)
{

  T ret;
  tex1Dfetch(&ret, texObject, x);
  return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1D(T *ptr, cudaTextureObject_t obj, float x)
{

   __nv_tex_surf_handler("__itex1D", ptr, obj, x);

}


template <class T>
static __attribute__((device)) T tex1D(cudaTextureObject_t texObject, float x)
{

  T ret;
  tex1D(&ret, texObject, x);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2D(T *ptr, cudaTextureObject_t obj, float x, float y)
{

   __nv_tex_surf_handler("__itex2D", ptr, obj, x, y);

}

template <class T>
static __attribute__((device)) T tex2D(cudaTextureObject_t texObject, float x, float y)
{

  T ret;
  tex2D(&ret, texObject, x, y);
  return ret;

}
# 188 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z)
{

   __nv_tex_surf_handler("__itex3D", ptr, obj, x, y, z);

}

template <class T>
static __attribute__((device)) T tex3D(cudaTextureObject_t texObject, float x, float y, float z)
{

  T ret;
  tex3D(&ret, texObject, x, y, z);
  return ret;

}
# 230 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1DLayered(T *ptr, cudaTextureObject_t obj, float x, int layer)
{

   __nv_tex_surf_handler("__itex1DLayered", ptr, obj, x, layer);

}

template <class T>
static __attribute__((device)) T tex1DLayered(cudaTextureObject_t texObject, float x, int layer)
{

  T ret;
  tex1DLayered(&ret, texObject, x, layer);
  return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer)
{

  __nv_tex_surf_handler("__itex2DLayered", ptr, obj, x, y, layer);

}

template <class T>
static __attribute__((device)) T tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer)
{

  T ret;
  tex2DLayered(&ret, texObject, x, y, layer);
  return ret;

}
# 289 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type texCubemap(T *ptr, cudaTextureObject_t obj, float x, float y, float z)
{

  __nv_tex_surf_handler("__itexCubemap", ptr, obj, x, y, z);

}


template <class T>
static __attribute__((device)) T texCubemap(cudaTextureObject_t texObject, float x, float y, float z)
{

  T ret;
  texCubemap(&ret, texObject, x, y, z);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type texCubemapLayered(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer)
{

  __nv_tex_surf_handler("__itexCubemapLayered", ptr, obj, x, y, z, layer);

}

template <class T>
static __attribute__((device)) T texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer)
{

  T ret;
  texCubemapLayered(&ret, texObject, x, y, z, layer);
  return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, int comp = 0)
{

  __nv_tex_surf_handler("__itex2Dgather", ptr, obj, x, y, comp);

}

template <class T>
static __attribute__((device)) T tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0)
{

  T ret;
  tex2Dgather(&ret, to, x, y, comp);
  return ret;

}
# 368 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1DLod(T *ptr, cudaTextureObject_t obj, float x, float level)
{

  __nv_tex_surf_handler("__itex1DLod", ptr, obj, x, level);

}

template <class T>
static __attribute__((device)) T tex1DLod(cudaTextureObject_t texObject, float x, float level)
{

  T ret;
  tex1DLod(&ret, texObject, x, level);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level)
{

  __nv_tex_surf_handler("__itex2DLod", ptr, obj, x, y, level);

}

template <class T>
static __attribute__((device)) T tex2DLod(cudaTextureObject_t texObject, float x, float y, float level)
{

  T ret;
  tex2DLod(&ret, texObject, x, y, level);
  return ret;

}
# 430 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level)
{

  __nv_tex_surf_handler("__itex3DLod", ptr, obj, x, y, z, level);

}

template <class T>
static __attribute__((device)) T tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{

  T ret;
  tex3DLod(&ret, texObject, x, y, z, level);
  return ret;

}
# 472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, int layer, float level)
{

  __nv_tex_surf_handler("__itex1DLayeredLod", ptr, obj, x, layer, level);

}

template <class T>
static __attribute__((device)) T tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level)
{

  T ret;
  tex1DLayeredLod(&ret, texObject, x, layer, level);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float level)
{

  __nv_tex_surf_handler("__itex2DLayeredLod", ptr, obj, x, y, layer, level);

}

template <class T>
static __attribute__((device)) T tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level)
{

  T ret;
  tex2DLayeredLod(&ret, texObject, x, y, layer, level);
  return ret;

}
# 531 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type texCubemapLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level)
{

  __nv_tex_surf_handler("__itexCubemapLod", ptr, obj, x, y, z, level);

}

template <class T>
static __attribute__((device)) T texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level)
{

  T ret;
  texCubemapLod(&ret, texObject, x, y, z, level);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type texCubemapGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  __nv_tex_surf_handler("__itexCubemapGrad_v2", ptr, obj, x, y, z, &dPdx, &dPdy);

}

template <class T>
static __attribute__((device)) T texCubemapGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  T ret;
  texCubemapGrad(&ret, texObject, x, y, z, dPdx, dPdy);
  return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type texCubemapLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float level)
{

  __nv_tex_surf_handler("__itexCubemapLayeredLod", ptr, obj, x, y, z, layer, level);

}

template <class T>
static __attribute__((device)) T texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level)
{

  T ret;
  texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level);
  return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1DGrad(T *ptr, cudaTextureObject_t obj, float x, float dPdx, float dPdy)
{

  __nv_tex_surf_handler("__itex1DGrad", ptr, obj, x, dPdx, dPdy);

}

template <class T>
static __attribute__((device)) T tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy)
{

  T ret;
  tex1DGrad(&ret, texObject, x, dPdx, dPdy);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx, float2 dPdy)
{

  __nv_tex_surf_handler("__itex2DGrad_v2", ptr, obj, x, y, &dPdx, &dPdy);


}

template <class T>
static __attribute__((device)) T tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy)
{

  T ret;
  tex2DGrad(&ret, texObject, x, y, dPdx, dPdy);
  return ret;

}
# 648 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  __nv_tex_surf_handler("__itex3DGrad_v2", ptr, obj, x, y, z, &dPdx, &dPdy);

}

template <class T>
static __attribute__((device)) T tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy)
{

  T ret;
  tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy);
  return ret;

}
# 690 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex1DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy)
{

  __nv_tex_surf_handler("__itex1DLayeredGrad", ptr, obj, x, layer, dPdx, dPdy);

}

template <class T>
static __attribute__((device)) T tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy)
{

  T ret;
  tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy);
  return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type tex2DLayeredGrad(T * ptr, cudaTextureObject_t obj, float x, float y, int layer, float2 dPdx, float2 dPdy)
{

  __nv_tex_surf_handler("__itex2DLayeredGrad_v2", ptr, obj, x, y, layer, &dPdx, &dPdy);

}

template <class T>
static __attribute__((device)) T tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy)
{

  T ret;
  tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy);
  return ret;

}
# 750 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/texture_indirect_functions.h"
template <typename T>
static __attribute__((device)) typename __nv_itex_trait<T>::type texCubemapLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{

  __nv_tex_surf_handler("__itexCubemapLayeredGrad_v2", ptr, obj, x, y, z, layer, &dPdx, &dPdy);

}

template <class T>
static __attribute__((device)) T texCubemapLayeredGrad(cudaTextureObject_t texObject, float x, float y, float z, int layer, float4 dPdx, float4 dPdy)
{

  T ret;
  texCubemapLayeredGrad(&ret, texObject, x, y, z, layer, dPdx, dPdy);
  return ret;

}
# 3304 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_indirect_functions.h" 1
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/surface_indirect_functions.h"
template<typename T> struct __nv_isurf_trait { };
template<> struct __nv_isurf_trait<char> { typedef void type; };
template<> struct __nv_isurf_trait<signed char> { typedef void type; };
template<> struct __nv_isurf_trait<char1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned char> { typedef void type; };
template<> struct __nv_isurf_trait<uchar1> { typedef void type; };
template<> struct __nv_isurf_trait<short> { typedef void type; };
template<> struct __nv_isurf_trait<short1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned short> { typedef void type; };
template<> struct __nv_isurf_trait<ushort1> { typedef void type; };
template<> struct __nv_isurf_trait<int> { typedef void type; };
template<> struct __nv_isurf_trait<int1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned int> { typedef void type; };
template<> struct __nv_isurf_trait<uint1> { typedef void type; };
template<> struct __nv_isurf_trait<long long> { typedef void type; };
template<> struct __nv_isurf_trait<longlong1> { typedef void type; };
template<> struct __nv_isurf_trait<unsigned long long> { typedef void type; };
template<> struct __nv_isurf_trait<ulonglong1> { typedef void type; };
template<> struct __nv_isurf_trait<float> { typedef void type; };
template<> struct __nv_isurf_trait<float1> { typedef void type; };

template<> struct __nv_isurf_trait<char2> { typedef void type; };
template<> struct __nv_isurf_trait<uchar2> { typedef void type; };
template<> struct __nv_isurf_trait<short2> { typedef void type; };
template<> struct __nv_isurf_trait<ushort2> { typedef void type; };
template<> struct __nv_isurf_trait<int2> { typedef void type; };
template<> struct __nv_isurf_trait<uint2> { typedef void type; };
template<> struct __nv_isurf_trait<longlong2> { typedef void type; };
template<> struct __nv_isurf_trait<ulonglong2> { typedef void type; };
template<> struct __nv_isurf_trait<float2> { typedef void type; };

template<> struct __nv_isurf_trait<char4> { typedef void type; };
template<> struct __nv_isurf_trait<uchar4> { typedef void type; };
template<> struct __nv_isurf_trait<short4> { typedef void type; };
template<> struct __nv_isurf_trait<ushort4> { typedef void type; };
template<> struct __nv_isurf_trait<int4> { typedef void type; };
template<> struct __nv_isurf_trait<uint4> { typedef void type; };
template<> struct __nv_isurf_trait<float4> { typedef void type; };


template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf1Dread(T *ptr, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1Dread", ptr, obj, x, mode);

}

template <class T>
static __attribute__((device)) T surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf1Dread(&ret, surfObject, x, boundaryMode);
   return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf2Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2Dread", ptr, obj, x, y, mode);

}

template <class T>
static __attribute__((device)) T surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf2Dread(&ret, surfObject, x, y, boundaryMode);
   return ret;

}


template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf3Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf3Dread", ptr, obj, x, y, z, mode);

}

template <class T>
static __attribute__((device)) T surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf3Dread(&ret, surfObject, x, y, z, boundaryMode);
   return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf1DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1DLayeredread", ptr, obj, x, layer, mode);

}

template <class T>
static __attribute__((device)) T surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode);
   return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf2DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2DLayeredread", ptr, obj, x, y, layer, mode);

}

template <class T>
static __attribute__((device)) T surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode);
   return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surfCubemapread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapread", ptr, obj, x, y, face, mode);

}

template <class T>
static __attribute__((device)) T surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surfCubemapread(&ret, surfObject, x, y, face, boundaryMode);
   return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surfCubemapLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapLayeredread", ptr, obj, x, y, layerface, mode);

}

template <class T>
static __attribute__((device)) T surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{

   T ret;
   surfCubemapLayeredread(&ret, surfObject, x, y, layerface, boundaryMode);
   return ret;

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf1Dwrite(T val, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1Dwrite_v2", &val, obj, x, mode);

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf2Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2Dwrite_v2", &val, obj, x, y, mode);

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf3Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf3Dwrite_v2", &val, obj, x, y, z, mode);

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf1DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf1DLayeredwrite_v2", &val, obj, x, layer, mode);

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surf2DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurf2DLayeredwrite_v2", &val, obj, x, y, layer, mode);

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surfCubemapwrite(T val, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapwrite_v2", &val, obj, x, y, face, mode);

}

template <typename T>
static __attribute__((device)) typename __nv_isurf_trait<T>::type surfCubemapLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap)
{

  __nv_tex_surf_handler("__isurfCubemapLayeredwrite_v2", &val, obj, x, y, layerface, mode);

}
# 3305 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/cudacc_ext.h" 1
# 3306 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/crt/device_functions.h" 2


extern "C" __attribute__((host)) __attribute__((device)) unsigned __cudaPushCallConfiguration(dim3 gridDim,
                                      dim3 blockDim,
                                      size_t sharedMem = 0,
                                      struct CUstream_st *stream = 0);
# 119 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_launch_parameters.h" 1
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/device_launch_parameters.h"
extern "C" {


uint3 __attribute__((device_builtin)) extern const threadIdx;
uint3 __attribute__((device_builtin)) extern const blockIdx;
dim3 __attribute__((device_builtin)) extern const blockDim;
dim3 __attribute__((device_builtin)) extern const gridDim;
int __attribute__((device_builtin)) extern const warpSize;




}
# 120 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 2
# 201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaLaunchKernel(
  const T *func,
  dim3 gridDim,
  dim3 blockDim,
  void **args,
  size_t sharedMem = 0,
  cudaStream_t stream = 0
)
{
    return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream);
}
# 263 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaLaunchCooperativeKernel(
  const T *func,
  dim3 gridDim,
  dim3 blockDim,
  void **args,
  size_t sharedMem = 0,
  cudaStream_t stream = 0
)
{
    return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream);
}
# 307 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
static __inline__ __attribute__((host)) cudaError_t cudaEventCreate(
  cudaEvent_t *event,
  unsigned int flags
)
{
  return ::cudaEventCreateWithFlags(event, flags);
}
# 372 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
static __inline__ __attribute__((host)) cudaError_t cudaMallocHost(
  void **ptr,
  size_t size,
  unsigned int flags
)
{
  return ::cudaHostAlloc(ptr, size, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaHostAlloc(
  T **ptr,
  size_t size,
  unsigned int flags
)
{
  return ::cudaHostAlloc((void**)(void*)ptr, size, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaHostGetDevicePointer(
  T **pDevice,
  void *pHost,
  unsigned int flags
)
{
  return ::cudaHostGetDevicePointer((void**)(void*)pDevice, pHost, flags);
}
# 501 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocManaged(
  T **devPtr,
  size_t size,
  unsigned int flags = 0x01
)
{
  return ::cudaMallocManaged((void**)(void*)devPtr, size, flags);
}
# 591 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaStreamAttachMemAsync(
  cudaStream_t stream,
  T *devPtr,
  size_t length = 0,
  unsigned int flags = 0x04
)
{
  return ::cudaStreamAttachMemAsync(stream, (void*)devPtr, length, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMalloc(
  T **devPtr,
  size_t size
)
{
  return ::cudaMalloc((void**)(void*)devPtr, size);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocHost(
  T **ptr,
  size_t size,
  unsigned int flags = 0
)
{
  return cudaMallocHost((void**)(void*)ptr, size, flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocPitch(
  T **devPtr,
  size_t *pitch,
  size_t width,
  size_t height
)
{
  return ::cudaMallocPitch((void**)(void*)devPtr, pitch, width, height);
}
# 641 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
static __inline__ __attribute__((host)) cudaError_t cudaMallocAsync(
  void **ptr,
  size_t size,
  cudaMemPool_t memPool,
  cudaStream_t stream
)
{
  return ::cudaMallocFromPoolAsync(ptr, size, memPool, stream);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocAsync(
  T **ptr,
  size_t size,
  cudaMemPool_t memPool,
  cudaStream_t stream
)
{
  return ::cudaMallocFromPoolAsync((void**)(void*)ptr, size, memPool, stream);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocAsync(
  T **ptr,
  size_t size,
  cudaStream_t stream
)
{
  return ::cudaMallocAsync((void**)(void*)ptr, size, stream);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMallocFromPoolAsync(
  T **ptr,
  size_t size,
  cudaMemPool_t memPool,
  cudaStream_t stream
)
{
  return ::cudaMallocFromPoolAsync((void**)(void*)ptr, size, memPool, stream);
}
# 720 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyToSymbol(
  const T &symbol,
  const void *src,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyHostToDevice
)
{
  return ::cudaMemcpyToSymbol((const void*)&symbol, src, count, offset, kind);
}
# 774 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyToSymbolAsync(
  const T &symbol,
  const void *src,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyHostToDevice,
        cudaStream_t stream = 0
)
{
  return ::cudaMemcpyToSymbolAsync((const void*)&symbol, src, count, offset, kind, stream);
}
# 822 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyFromSymbol(
        void *dst,
  const T &symbol,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost
)
{
  return ::cudaMemcpyFromSymbol(dst, (const void*)&symbol, count, offset, kind);
}
# 876 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaMemcpyFromSymbolAsync(
        void *dst,
  const T &symbol,
        size_t count,
        size_t offset = 0,
        enum cudaMemcpyKind kind = cudaMemcpyDeviceToHost,
        cudaStream_t stream = 0
)
{
  return ::cudaMemcpyFromSymbolAsync(dst, (const void*)&symbol, count, offset, kind, stream);
}
# 945 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGraphAddMemcpyNodeToSymbol(
    cudaGraphNode_t *pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t *pDependencies,
    size_t numDependencies,
    const T &symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph, pDependencies, numDependencies, (const void*)&symbol, src, count, offset, kind);
}
# 1016 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGraphAddMemcpyNodeFromSymbol(
    cudaGraphNode_t* pGraphNode,
    cudaGraph_t graph,
    const cudaGraphNode_t* pDependencies,
    size_t numDependencies,
    void* dst,
    const T &symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphAddMemcpyNodeFromSymbol(pGraphNode, graph, pDependencies, numDependencies, dst, (const void*)&symbol, count, offset, kind);
}
# 1067 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGraphMemcpyNodeSetParamsToSymbol(
    cudaGraphNode_t node,
    const T &symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphMemcpyNodeSetParamsToSymbol(node, (const void*)&symbol, src, count, offset, kind);
}
# 1115 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGraphMemcpyNodeSetParamsFromSymbol(
    cudaGraphNode_t node,
    void* dst,
    const T &symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphMemcpyNodeSetParamsFromSymbol(node, dst, (const void*)&symbol, count, offset, kind);
}
# 1173 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    const T &symbol,
    const void* src,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
    return ::cudaGraphExecMemcpyNodeSetParamsToSymbol(hGraphExec, node, (const void*)&symbol, src, count, offset, kind);
}
# 1232 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(
    cudaGraphExec_t hGraphExec,
    cudaGraphNode_t node,
    void* dst,
    const T &symbol,
    size_t count,
    size_t offset,
    enum cudaMemcpyKind kind)
{
  return ::cudaGraphExecMemcpyNodeSetParamsFromSymbol(hGraphExec, node, dst, (const void*)&symbol, count, offset, kind);
}
# 1271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaUserObjectCreate(
    cudaUserObject_t *object_out,
    T *objectToWrap,
    unsigned int initialRefcount,
    unsigned int flags)
{
    return ::cudaUserObjectCreate(
            object_out,
            objectToWrap,
            [](void *vpObj) { delete reinterpret_cast<T *>(vpObj); },
            initialRefcount,
            flags);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaUserObjectCreate(
    cudaUserObject_t *object_out,
    T *objectToWrap,
    unsigned int initialRefcount,
    cudaUserObjectFlags flags)
{
    return cudaUserObjectCreate(object_out, objectToWrap, initialRefcount, (unsigned int)flags);
}
# 1321 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGetSymbolAddress(
        void **devPtr,
  const T &symbol
)
{
  return ::cudaGetSymbolAddress(devPtr, (const void*)&symbol);
}
# 1353 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaGetSymbolSize(
        size_t *size,
  const T &symbol
)
{
  return ::cudaGetSymbolSize(size, (const void*)&symbol);
}
# 1397 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTexture(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  const struct cudaChannelFormatDesc &desc,
        size_t size = 
# 1403 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 3 4
                                                (0x7fffffff * 2U + 1U)

# 1404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
)
{
  return ::cudaBindTexture(offset, &tex, devPtr, &desc, size);
}
# 1443 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTexture(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
        size_t size = 
# 1448 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h" 3 4
                                                (0x7fffffff * 2U + 1U)

# 1449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
)
{
  return cudaBindTexture(offset, tex, devPtr, tex.channelDesc, size);
}
# 1500 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTexture2D(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  const struct cudaChannelFormatDesc &desc,
  size_t width,
  size_t height,
  size_t pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch);
}
# 1559 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTexture2D(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex,
  const void *devPtr,
  size_t width,
  size_t height,
  size_t pitch
)
{
  return ::cudaBindTexture2D(offset, &tex, devPtr, &tex.channelDesc, width, height, pitch);
}
# 1602 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindTextureToArray(&tex, array, &desc);
}
# 1641 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTextureToArray(
  const struct texture<T, dim, readMode> &tex,
  cudaArray_const_t array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindTextureToArray(tex, array, desc) : err;
}
# 1683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t mipmappedArray,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc);
}
# 1722 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindTextureToMipmappedArray(
  const struct texture<T, dim, readMode> &tex,
  cudaMipmappedArray_const_t mipmappedArray
)
{
  struct cudaChannelFormatDesc desc;
  cudaArray_t levelArray;
  cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0);

  if (err != cudaSuccess) {
      return err;
  }
  err = ::cudaGetChannelDesc(&desc, levelArray);

  return err == cudaSuccess ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err;
}
# 1765 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaUnbindTexture(
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaUnbindTexture(&tex);
}
# 1801 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim, enum cudaTextureReadMode readMode>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaGetTextureAlignmentOffset(
        size_t *offset,
  const struct texture<T, dim, readMode> &tex
)
{
  return ::cudaGetTextureAlignmentOffset(offset, &tex);
}
# 1853 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncSetCacheConfig(
  T *func,
  enum cudaFuncCache cacheConfig
)
{
  return ::cudaFuncSetCacheConfig((const void*)func, cacheConfig);
}

template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncSetSharedMemConfig(
  T *func,
  enum cudaSharedMemConfig config
)
{
  return ::cudaFuncSetSharedMemConfig((const void*)func, config);
}
# 1901 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(
    int *numBlocks,
    T func,
    int blockSize,
    size_t dynamicSMemSize)
{
    return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void*)func, blockSize, dynamicSMemSize, 0x00);
}
# 1953 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
    int *numBlocks,
    T func,
    int blockSize,
    size_t dynamicSMemSize,
    unsigned int flags)
{
    return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void*)func, blockSize, dynamicSMemSize, flags);
}




class __cudaOccupancyB2DHelper {
  size_t n;
public:
  inline __attribute__((host)) __attribute__((device)) __cudaOccupancyB2DHelper(size_t n_) : n(n_) {}
  inline __attribute__((host)) __attribute__((device)) size_t operator()(int)
  {
      return n;
  }
};
# 2023 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<typename UnaryFunction, class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(
    int *minGridSize,
    int *blockSize,
    T func,
    UnaryFunction blockSizeToDynamicSMemSize,
    int blockSizeLimit = 0,
    unsigned int flags = 0)
{
    cudaError_t status;


    int device;
    struct cudaFuncAttributes attr;


    int maxThreadsPerMultiProcessor;
    int warpSize;
    int devMaxThreadsPerBlock;
    int multiProcessorCount;
    int funcMaxThreadsPerBlock;
    int occupancyLimit;
    int granularity;


    int maxBlockSize = 0;
    int numBlocks = 0;
    int maxOccupancy = 0;


    int blockSizeToTryAligned;
    int blockSizeToTry;
    int blockSizeLimitAligned;
    int occupancyInBlocks;
    int occupancyInThreads;
    size_t dynamicSMemSize;





    if (!minGridSize || !blockSize || !func) {
        return cudaErrorInvalidValue;
    }





    status = ::cudaGetDevice(&device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &maxThreadsPerMultiProcessor,
        cudaDevAttrMaxThreadsPerMultiProcessor,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &warpSize,
        cudaDevAttrWarpSize,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &devMaxThreadsPerBlock,
        cudaDevAttrMaxThreadsPerBlock,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaDeviceGetAttribute(
        &multiProcessorCount,
        cudaDevAttrMultiProcessorCount,
        device);
    if (status != cudaSuccess) {
        return status;
    }

    status = cudaFuncGetAttributes(&attr, func);
    if (status != cudaSuccess) {
        return status;
    }

    funcMaxThreadsPerBlock = attr.maxThreadsPerBlock;





    occupancyLimit = maxThreadsPerMultiProcessor;
    granularity = warpSize;

    if (blockSizeLimit == 0) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (devMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = devMaxThreadsPerBlock;
    }

    if (funcMaxThreadsPerBlock < blockSizeLimit) {
        blockSizeLimit = funcMaxThreadsPerBlock;
    }

    blockSizeLimitAligned = ((blockSizeLimit + (granularity - 1)) / granularity) * granularity;

    for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) {



        if (blockSizeLimit < blockSizeToTryAligned) {
            blockSizeToTry = blockSizeLimit;
        } else {
            blockSizeToTry = blockSizeToTryAligned;
        }

        dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry);

        status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
            &occupancyInBlocks,
            func,
            blockSizeToTry,
            dynamicSMemSize,
            flags);

        if (status != cudaSuccess) {
            return status;
        }

        occupancyInThreads = blockSizeToTry * occupancyInBlocks;

        if (occupancyInThreads > maxOccupancy) {
            maxBlockSize = blockSizeToTry;
            numBlocks = occupancyInBlocks;
            maxOccupancy = occupancyInThreads;
        }



        if (occupancyLimit == maxOccupancy) {
            break;
        }
    }







    *minGridSize = numBlocks * multiProcessorCount;
    *blockSize = maxBlockSize;

    return status;
}
# 2219 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<typename UnaryFunction, class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeVariableSMem(
    int *minGridSize,
    int *blockSize,
    T func,
    UnaryFunction blockSizeToDynamicSMemSize,
    int blockSizeLimit = 0)
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0x00);
}
# 2265 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSize(
    int *minGridSize,
    int *blockSize,
    T func,
    size_t dynamicSMemSize = 0,
    int blockSizeLimit = 0)
{
  return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit, 0x00);
}
# 2303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaOccupancyAvailableDynamicSMemPerBlock(
    size_t *dynamicSmemSize,
    T func,
    int numBlocks,
    int blockSize)
{
    return ::cudaOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, (const void*)func, numBlocks, blockSize);
}
# 2362 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) __attribute__((device)) cudaError_t cudaOccupancyMaxPotentialBlockSizeWithFlags(
    int *minGridSize,
    int *blockSize,
    T func,
    size_t dynamicSMemSize = 0,
    int blockSizeLimit = 0,
    unsigned int flags = 0)
{
    return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit, flags);
}
# 2405 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncGetAttributes(
  struct cudaFuncAttributes *attr,
  T *entry
)
{
  return ::cudaFuncGetAttributes(attr, (const void*)entry);
}
# 2469 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T>
static __inline__ __attribute__((host)) cudaError_t cudaFuncSetAttribute(
  T *entry,
  enum cudaFuncAttribute attr,
  int value
)
{
  return ::cudaFuncSetAttribute((const void*)entry, attr, value);
}
# 2501 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t array,
  const struct cudaChannelFormatDesc &desc
)
{
  return ::cudaBindSurfaceToArray(&surf, array, &desc);
}
# 2532 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
template<class T, int dim>
static __attribute__((deprecated)) __inline__ __attribute__((host)) cudaError_t cudaBindSurfaceToArray(
  const struct surface<T, dim> &surf,
  cudaArray_const_t array
)
{
  struct cudaChannelFormatDesc desc;
  cudaError_t err = ::cudaGetChannelDesc(&desc, array);

  return err == cudaSuccess ? cudaBindSurfaceToArray(surf, array, desc) : err;
}
# 2553 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda_runtime.h"
#pragma GCC diagnostic pop
# 0 "<command-line>" 2
# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stdint.h" 1 3 4
# 9 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 22 "/usr/include/bits/wchar.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/wchar.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4

# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stdint.h" 2 3 4
# 5 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 1
       

# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl.h"
       





# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
       

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h" 1
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdlib.h" 1 3
# 56 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h" 2






# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef uint32_t cuuint32_t;
typedef uint64_t cuuint64_t;
# 247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
extern "C" {







typedef unsigned long long CUdeviceptr_v2;



typedef CUdeviceptr_v2 CUdeviceptr;

typedef int CUdevice_v1;
typedef CUdevice_v1 CUdevice;
typedef struct CUctx_st *CUcontext;
typedef struct CUmod_st *CUmodule;
typedef struct CUfunc_st *CUfunction;
typedef struct CUarray_st *CUarray;
typedef struct CUmipmappedArray_st *CUmipmappedArray;
typedef struct CUtexref_st *CUtexref;
typedef struct CUsurfref_st *CUsurfref;
typedef struct CUevent_st *CUevent;
typedef struct CUstream_st *CUstream;
typedef struct CUgraphicsResource_st *CUgraphicsResource;
typedef unsigned long long CUtexObject_v1;
typedef CUtexObject_v1 CUtexObject;
typedef unsigned long long CUsurfObject_v1;
typedef CUsurfObject_v1 CUsurfObject;
typedef struct CUextMemory_st *CUexternalMemory;
typedef struct CUextSemaphore_st *CUexternalSemaphore;
typedef struct CUgraph_st *CUgraph;
typedef struct CUgraphNode_st *CUgraphNode;
typedef struct CUgraphExec_st *CUgraphExec;
typedef struct CUmemPoolHandle_st *CUmemoryPool;
typedef struct CUuserObject_st *CUuserObject;
# 300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef struct CUipcEventHandle_st {
    char reserved[64];
} CUipcEventHandle_v1;
typedef CUipcEventHandle_v1 CUipcEventHandle;




typedef struct CUipcMemHandle_st {
    char reserved[64];
} CUipcMemHandle_v1;
typedef CUipcMemHandle_v1 CUipcMemHandle;




typedef enum CUipcMem_flags_enum {
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 0x1
} CUipcMem_flags;





typedef enum CUmemAttach_flags_enum {
    CU_MEM_ATTACH_GLOBAL = 0x1,
    CU_MEM_ATTACH_HOST = 0x2,
    CU_MEM_ATTACH_SINGLE = 0x4
} CUmemAttach_flags;




typedef enum CUctx_flags_enum {
    CU_CTX_SCHED_AUTO = 0x00,
    CU_CTX_SCHED_SPIN = 0x01,
    CU_CTX_SCHED_YIELD = 0x02,
    CU_CTX_SCHED_BLOCKING_SYNC = 0x04,
    CU_CTX_BLOCKING_SYNC = 0x04,


    CU_CTX_SCHED_MASK = 0x07,
    CU_CTX_MAP_HOST = 0x08,


    CU_CTX_LMEM_RESIZE_TO_MAX = 0x10,
    CU_CTX_FLAGS_MASK = 0x1f
} CUctx_flags;




typedef enum CUstream_flags_enum {
    CU_STREAM_DEFAULT = 0x0,
    CU_STREAM_NON_BLOCKING = 0x1
} CUstream_flags;
# 380 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef enum CUevent_flags_enum {
    CU_EVENT_DEFAULT = 0x0,
    CU_EVENT_BLOCKING_SYNC = 0x1,
    CU_EVENT_DISABLE_TIMING = 0x2,
    CU_EVENT_INTERPROCESS = 0x4
} CUevent_flags;




typedef enum CUevent_record_flags_enum {
    CU_EVENT_RECORD_DEFAULT = 0x0,
    CU_EVENT_RECORD_EXTERNAL = 0x1


} CUevent_record_flags;




typedef enum CUevent_wait_flags_enum {
    CU_EVENT_WAIT_DEFAULT = 0x0,
    CU_EVENT_WAIT_EXTERNAL = 0x1


} CUevent_wait_flags;




typedef enum CUstreamWaitValue_flags_enum {
    CU_STREAM_WAIT_VALUE_GEQ = 0x0,


    CU_STREAM_WAIT_VALUE_EQ = 0x1,
    CU_STREAM_WAIT_VALUE_AND = 0x2,
    CU_STREAM_WAIT_VALUE_NOR = 0x3,


    CU_STREAM_WAIT_VALUE_FLUSH = 1<<30
# 428 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
} CUstreamWaitValue_flags;




typedef enum CUstreamWriteValue_flags_enum {
    CU_STREAM_WRITE_VALUE_DEFAULT = 0x0,
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 0x1






} CUstreamWriteValue_flags;




typedef enum CUstreamBatchMemOpType_enum {
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1,
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2,
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4,
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5,

    CU_STREAM_MEM_OP_BARRIER = 6,

    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3

} CUstreamBatchMemOpType;





typedef enum CUstreamMemoryBarrier_flags_enum {
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS = 0x0,
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU = 0x1
} CUstreamMemoryBarrier_flags;





typedef union CUstreamBatchMemOpParams_union {
    CUstreamBatchMemOpType operation;
    struct CUstreamMemOpWaitValueParams_st {
        CUstreamBatchMemOpType operation;
        CUdeviceptr address;
        union {
            cuuint32_t value;
            cuuint64_t value64;
        };
        unsigned int flags;
        CUdeviceptr alias;
    } waitValue;
    struct CUstreamMemOpWriteValueParams_st {
        CUstreamBatchMemOpType operation;
        CUdeviceptr address;
        union {
            cuuint32_t value;
            cuuint64_t value64;
        };
        unsigned int flags;
        CUdeviceptr alias;
    } writeValue;
    struct CUstreamMemOpFlushRemoteWritesParams_st {
        CUstreamBatchMemOpType operation;
        unsigned int flags;
    } flushRemoteWrites;

    struct CUstreamMemOpMemoryBarrierParams_st {
        CUstreamBatchMemOpType operation;
        unsigned int flags;
    } memoryBarrier;

    cuuint64_t pad[6];
} CUstreamBatchMemOpParams_v1;
typedef CUstreamBatchMemOpParams_v1 CUstreamBatchMemOpParams;


typedef struct CUDA_BATCH_MEM_OP_NODE_PARAMS_st {
    CUcontext ctx;
    unsigned int count;
    CUstreamBatchMemOpParams *paramArray;
    unsigned int flags;
} CUDA_BATCH_MEM_OP_NODE_PARAMS;





typedef enum CUoccupancy_flags_enum {
    CU_OCCUPANCY_DEFAULT = 0x0,
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 0x1
} CUoccupancy_flags;




typedef enum CUstreamUpdateCaptureDependencies_flags_enum {
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = 0x0,
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = 0x1
} CUstreamUpdateCaptureDependencies_flags;




typedef enum CUarray_format_enum {
    CU_AD_FORMAT_UNSIGNED_INT8 = 0x01,
    CU_AD_FORMAT_UNSIGNED_INT16 = 0x02,
    CU_AD_FORMAT_UNSIGNED_INT32 = 0x03,
    CU_AD_FORMAT_SIGNED_INT8 = 0x08,
    CU_AD_FORMAT_SIGNED_INT16 = 0x09,
    CU_AD_FORMAT_SIGNED_INT32 = 0x0a,
    CU_AD_FORMAT_HALF = 0x10,
    CU_AD_FORMAT_FLOAT = 0x20,
    CU_AD_FORMAT_NV12 = 0xb0,
    CU_AD_FORMAT_UNORM_INT8X1 = 0xc0,
    CU_AD_FORMAT_UNORM_INT8X2 = 0xc1,
    CU_AD_FORMAT_UNORM_INT8X4 = 0xc2,
    CU_AD_FORMAT_UNORM_INT16X1 = 0xc3,
    CU_AD_FORMAT_UNORM_INT16X2 = 0xc4,
    CU_AD_FORMAT_UNORM_INT16X4 = 0xc5,
    CU_AD_FORMAT_SNORM_INT8X1 = 0xc6,
    CU_AD_FORMAT_SNORM_INT8X2 = 0xc7,
    CU_AD_FORMAT_SNORM_INT8X4 = 0xc8,
    CU_AD_FORMAT_SNORM_INT16X1 = 0xc9,
    CU_AD_FORMAT_SNORM_INT16X2 = 0xca,
    CU_AD_FORMAT_SNORM_INT16X4 = 0xcb,
    CU_AD_FORMAT_BC1_UNORM = 0x91,
    CU_AD_FORMAT_BC1_UNORM_SRGB = 0x92,
    CU_AD_FORMAT_BC2_UNORM = 0x93,
    CU_AD_FORMAT_BC2_UNORM_SRGB = 0x94,
    CU_AD_FORMAT_BC3_UNORM = 0x95,
    CU_AD_FORMAT_BC3_UNORM_SRGB = 0x96,
    CU_AD_FORMAT_BC4_UNORM = 0x97,
    CU_AD_FORMAT_BC4_SNORM = 0x98,
    CU_AD_FORMAT_BC5_UNORM = 0x99,
    CU_AD_FORMAT_BC5_SNORM = 0x9a,
    CU_AD_FORMAT_BC6H_UF16 = 0x9b,
    CU_AD_FORMAT_BC6H_SF16 = 0x9c,
    CU_AD_FORMAT_BC7_UNORM = 0x9d,
    CU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e
} CUarray_format;




typedef enum CUaddress_mode_enum {
    CU_TR_ADDRESS_MODE_WRAP = 0,
    CU_TR_ADDRESS_MODE_CLAMP = 1,
    CU_TR_ADDRESS_MODE_MIRROR = 2,
    CU_TR_ADDRESS_MODE_BORDER = 3
} CUaddress_mode;




typedef enum CUfilter_mode_enum {
    CU_TR_FILTER_MODE_POINT = 0,
    CU_TR_FILTER_MODE_LINEAR = 1
} CUfilter_mode;




typedef enum CUdevice_attribute_enum {
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6,
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8,
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8,
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9,
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10,
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12,
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12,
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13,
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14,
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15,
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16,
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17,
    CU_DEVICE_ATTRIBUTE_INTEGRATED = 18,
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19,
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29,
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32,
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33,
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34,
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35,
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36,
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37,
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38,
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43,
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49,
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50,
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75,
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76,
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77,
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78,
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79,
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81,
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82,
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84,
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85,
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86,
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88,
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89,
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90,
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = 92,
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 93,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 94,
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95,
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96,
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97,
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98,
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99,
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100,
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101,
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = 102,
    CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 102,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104,
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105,
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106,
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107,
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108,
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110,
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111,
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112,
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113,
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114,
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = 117,
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = 118,
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = 119,




    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = 121,


    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2 = 122,
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2 = 123,


    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = 124,

    CU_DEVICE_ATTRIBUTE_MAX
} CUdevice_attribute;




typedef struct CUdevprop_st {
    int maxThreadsPerBlock;
    int maxThreadsDim[3];
    int maxGridSize[3];
    int sharedMemPerBlock;
    int totalConstantMemory;
    int SIMDWidth;
    int memPitch;
    int regsPerBlock;
    int clockRate;
    int textureAlign;
} CUdevprop_v1;
typedef CUdevprop_v1 CUdevprop;




typedef enum CUpointer_attribute_enum {
    CU_POINTER_ATTRIBUTE_CONTEXT = 1,
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    CU_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    CU_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    CU_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = 10,
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    CU_POINTER_ATTRIBUTE_MAPPED = 13,
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17

    ,
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE = 18,
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = 19,
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = 20

} CUpointer_attribute;




typedef enum CUfunction_attribute_enum {





    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,






    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,





    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,




    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,




    CU_FUNC_ATTRIBUTE_NUM_REGS = 4,
# 824 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_FUNC_ATTRIBUTE_PTX_VERSION = 5,
# 833 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6,





    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,







    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
# 856 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
# 929 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_FUNC_ATTRIBUTE_MAX
} CUfunction_attribute;




typedef enum CUfunc_cache_enum {
    CU_FUNC_CACHE_PREFER_NONE = 0x00,
    CU_FUNC_CACHE_PREFER_SHARED = 0x01,
    CU_FUNC_CACHE_PREFER_L1 = 0x02,
    CU_FUNC_CACHE_PREFER_EQUAL = 0x03
} CUfunc_cache;




typedef enum CUsharedconfig_enum {
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0x00,
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 0x01,
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 0x02
} CUsharedconfig;




typedef enum CUshared_carveout_enum {
    CU_SHAREDMEM_CARVEOUT_DEFAULT = -1,
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100,
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0
} CUshared_carveout;




typedef enum CUmemorytype_enum {
    CU_MEMORYTYPE_HOST = 0x01,
    CU_MEMORYTYPE_DEVICE = 0x02,
    CU_MEMORYTYPE_ARRAY = 0x03,
    CU_MEMORYTYPE_UNIFIED = 0x04
} CUmemorytype;




typedef enum CUcomputemode_enum {
    CU_COMPUTEMODE_DEFAULT = 0,
    CU_COMPUTEMODE_PROHIBITED = 2,
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3
} CUcomputemode;




typedef enum CUmem_advise_enum {
    CU_MEM_ADVISE_SET_READ_MOSTLY = 1,
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2,
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3,
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4,
    CU_MEM_ADVISE_SET_ACCESSED_BY = 5,
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6
} CUmem_advise;

typedef enum CUmem_range_attribute_enum {
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = 1,
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = 2,
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = 3,
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = 4
} CUmem_range_attribute;




typedef enum CUjit_option_enum
{





    CU_JIT_MAX_REGISTERS = 0,
# 1023 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_THREADS_PER_BLOCK,







    CU_JIT_WALL_TIME,
# 1040 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_INFO_LOG_BUFFER,
# 1049 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES,
# 1058 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_ERROR_LOG_BUFFER,
# 1067 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES,







    CU_JIT_OPTIMIZATION_LEVEL,







    CU_JIT_TARGET_FROM_CUCONTEXT,







    CU_JIT_TARGET,
# 1100 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_FALLBACK_STRATEGY,







    CU_JIT_GENERATE_DEBUG_INFO,






    CU_JIT_LOG_VERBOSE,






    CU_JIT_GENERATE_LINE_INFO,







    CU_JIT_CACHE_MODE,





    CU_JIT_NEW_SM3X_OPT,




    CU_JIT_FAST_COMPILE,
# 1155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_GLOBAL_SYMBOL_NAMES,
# 1164 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES,







    CU_JIT_GLOBAL_SYMBOL_COUNT,







    CU_JIT_LTO,
# 1189 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_FTZ,
# 1199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_PREC_DIV,
# 1209 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_PREC_SQRT,
# 1218 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_FMA,
# 1236 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_REFERENCED_KERNEL_NAMES,






    CU_JIT_REFERENCED_KERNEL_COUNT,
# 1260 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_REFERENCED_VARIABLE_NAMES,






    CU_JIT_REFERENCED_VARIABLE_COUNT,
# 1279 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES,


    CU_JIT_NUM_OPTIONS

} CUjit_option;




typedef enum CUjit_target_enum
{

    CU_TARGET_COMPUTE_20 = 20,
    CU_TARGET_COMPUTE_21 = 21,


    CU_TARGET_COMPUTE_30 = 30,
    CU_TARGET_COMPUTE_32 = 32,
    CU_TARGET_COMPUTE_35 = 35,
    CU_TARGET_COMPUTE_37 = 37,


    CU_TARGET_COMPUTE_50 = 50,
    CU_TARGET_COMPUTE_52 = 52,
    CU_TARGET_COMPUTE_53 = 53,


    CU_TARGET_COMPUTE_60 = 60,
    CU_TARGET_COMPUTE_61 = 61,
    CU_TARGET_COMPUTE_62 = 62,


    CU_TARGET_COMPUTE_70 = 70,
    CU_TARGET_COMPUTE_72 = 72,

    CU_TARGET_COMPUTE_75 = 75,

    CU_TARGET_COMPUTE_80 = 80,
    CU_TARGET_COMPUTE_86 = 86,
    CU_TARGET_COMPUTE_87 = 87,




} CUjit_target;




typedef enum CUjit_fallback_enum
{
    CU_PREFER_PTX = 0,

    CU_PREFER_BINARY

} CUjit_fallback;




typedef enum CUjit_cacheMode_enum
{
    CU_JIT_CACHE_OPTION_NONE = 0,
    CU_JIT_CACHE_OPTION_CG,
    CU_JIT_CACHE_OPTION_CA
} CUjit_cacheMode;




typedef enum CUjitInputType_enum
{




    CU_JIT_INPUT_CUBIN = 0,





    CU_JIT_INPUT_PTX,





    CU_JIT_INPUT_FATBINARY,





    CU_JIT_INPUT_OBJECT,





    CU_JIT_INPUT_LIBRARY,





    CU_JIT_INPUT_NVVM,

    CU_JIT_NUM_INPUT_TYPES
} CUjitInputType;

typedef struct CUlinkState_st *CUlinkState;




typedef enum CUgraphicsRegisterFlags_enum {
    CU_GRAPHICS_REGISTER_FLAGS_NONE = 0x00,
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 0x01,
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 0x02,
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 0x04,
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 0x08
} CUgraphicsRegisterFlags;




typedef enum CUgraphicsMapResourceFlags_enum {
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0x00,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 0x01,
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02
} CUgraphicsMapResourceFlags;




typedef enum CUarray_cubemap_face_enum {
    CU_CUBEMAP_FACE_POSITIVE_X = 0x00,
    CU_CUBEMAP_FACE_NEGATIVE_X = 0x01,
    CU_CUBEMAP_FACE_POSITIVE_Y = 0x02,
    CU_CUBEMAP_FACE_NEGATIVE_Y = 0x03,
    CU_CUBEMAP_FACE_POSITIVE_Z = 0x04,
    CU_CUBEMAP_FACE_NEGATIVE_Z = 0x05
} CUarray_cubemap_face;




typedef enum CUlimit_enum {
    CU_LIMIT_STACK_SIZE = 0x00,
    CU_LIMIT_PRINTF_FIFO_SIZE = 0x01,
    CU_LIMIT_MALLOC_HEAP_SIZE = 0x02,
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 0x03,
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 0x04,
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = 0x05,
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = 0x06,
    CU_LIMIT_MAX
} CUlimit;




typedef enum CUresourcetype_enum {
    CU_RESOURCE_TYPE_ARRAY = 0x00,
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01,
    CU_RESOURCE_TYPE_LINEAR = 0x02,
    CU_RESOURCE_TYPE_PITCH2D = 0x03
} CUresourcetype;
# 1459 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef void ( *CUhostFn)(void *userData);




typedef enum CUaccessProperty_enum {
    CU_ACCESS_PROPERTY_NORMAL = 0,
    CU_ACCESS_PROPERTY_STREAMING = 1,
    CU_ACCESS_PROPERTY_PERSISTING = 2
} CUaccessProperty;
# 1482 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef struct CUaccessPolicyWindow_st {
    void *base_ptr;
    size_t num_bytes;
    float hitRatio;
    CUaccessProperty hitProp;
    CUaccessProperty missProp;
} CUaccessPolicyWindow_v1;
typedef CUaccessPolicyWindow_v1 CUaccessPolicyWindow;




typedef struct CUDA_KERNEL_NODE_PARAMS_st {
    CUfunction func;
    unsigned int gridDimX;
    unsigned int gridDimY;
    unsigned int gridDimZ;
    unsigned int blockDimX;
    unsigned int blockDimY;
    unsigned int blockDimZ;
    unsigned int sharedMemBytes;
    void **kernelParams;
    void **extra;
} CUDA_KERNEL_NODE_PARAMS_v1;
typedef CUDA_KERNEL_NODE_PARAMS_v1 CUDA_KERNEL_NODE_PARAMS;




typedef struct CUDA_MEMSET_NODE_PARAMS_st {
    CUdeviceptr dst;
    size_t pitch;
    unsigned int value;
    unsigned int elementSize;
    size_t width;
    size_t height;
} CUDA_MEMSET_NODE_PARAMS_v1;
typedef CUDA_MEMSET_NODE_PARAMS_v1 CUDA_MEMSET_NODE_PARAMS;




typedef struct CUDA_HOST_NODE_PARAMS_st {
    CUhostFn fn;
    void* userData;
} CUDA_HOST_NODE_PARAMS_v1;
typedef CUDA_HOST_NODE_PARAMS_v1 CUDA_HOST_NODE_PARAMS;




typedef enum CUgraphNodeType_enum {
    CU_GRAPH_NODE_TYPE_KERNEL = 0,
    CU_GRAPH_NODE_TYPE_MEMCPY = 1,
    CU_GRAPH_NODE_TYPE_MEMSET = 2,
    CU_GRAPH_NODE_TYPE_HOST = 3,
    CU_GRAPH_NODE_TYPE_GRAPH = 4,
    CU_GRAPH_NODE_TYPE_EMPTY = 5,
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = 6,
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = 7,
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = 8,
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = 9,
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = 10,
    CU_GRAPH_NODE_TYPE_MEM_FREE = 11

    ,
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP = 12

} CUgraphNodeType;
# 1578 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef enum CUsynchronizationPolicy_enum {
    CU_SYNC_POLICY_AUTO = 1,
    CU_SYNC_POLICY_SPIN = 2,
    CU_SYNC_POLICY_YIELD = 3,
    CU_SYNC_POLICY_BLOCKING_SYNC = 4
} CUsynchronizationPolicy;
# 1690 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef enum CUkernelNodeAttrID_enum {
    CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1
  , CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE = 2

  , CU_KERNEL_NODE_ATTRIBUTE_PRIORITY = 8

} CUkernelNodeAttrID;
# 1710 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef union CUkernelNodeAttrValue_union {
    CUaccessPolicyWindow accessPolicyWindow;
    int cooperative;

    int priority;

} CUkernelNodeAttrValue_v1;



typedef CUkernelNodeAttrValue_v1 CUkernelNodeAttrValue;




typedef enum CUstreamCaptureStatus_enum {
    CU_STREAM_CAPTURE_STATUS_NONE = 0,
    CU_STREAM_CAPTURE_STATUS_ACTIVE = 1,
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2

} CUstreamCaptureStatus;





typedef enum CUstreamCaptureMode_enum {
    CU_STREAM_CAPTURE_MODE_GLOBAL = 0,
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = 1,
    CU_STREAM_CAPTURE_MODE_RELAXED = 2
} CUstreamCaptureMode;





typedef enum CUstreamAttrID_enum {
    CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1,
    CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3
} CUstreamAttrID;
# 1760 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef union CUstreamAttrValue_union {
    CUaccessPolicyWindow accessPolicyWindow;
    CUsynchronizationPolicy syncPolicy;
} CUstreamAttrValue_v1;



typedef CUstreamAttrValue_v1 CUstreamAttrValue;




typedef enum CUdriverProcAddress_flags_enum {
    CU_GET_PROC_ADDRESS_DEFAULT = 0,
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = 1 << 0,
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = 1 << 1
} CUdriverProcAddress_flags;




typedef enum CUexecAffinityType_enum {
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = 0,
    CU_EXEC_AFFINITY_TYPE_MAX
} CUexecAffinityType;




typedef struct CUexecAffinitySmCount_st {
    unsigned int val;
} CUexecAffinitySmCount_v1;
typedef CUexecAffinitySmCount_v1 CUexecAffinitySmCount;




typedef struct CUexecAffinityParam_st {
    CUexecAffinityType type;
    union {
        CUexecAffinitySmCount smCount;
    } param;
} CUexecAffinityParam_v1;
typedef CUexecAffinityParam_v1 CUexecAffinityParam;




typedef enum cudaError_enum {





    CUDA_SUCCESS = 0,





    CUDA_ERROR_INVALID_VALUE = 1,





    CUDA_ERROR_OUT_OF_MEMORY = 2,





    CUDA_ERROR_NOT_INITIALIZED = 3,




    CUDA_ERROR_DEINITIALIZED = 4,






    CUDA_ERROR_PROFILER_DISABLED = 5,







    CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6,






    CUDA_ERROR_PROFILER_ALREADY_STARTED = 7,






    CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8,






    CUDA_ERROR_STUB_LIBRARY = 34,






    CUDA_ERROR_DEVICE_UNAVAILABLE = 46,





    CUDA_ERROR_NO_DEVICE = 100,






    CUDA_ERROR_INVALID_DEVICE = 101,




    CUDA_ERROR_DEVICE_NOT_LICENSED = 102,





    CUDA_ERROR_INVALID_IMAGE = 200,
# 1914 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_INVALID_CONTEXT = 201,
# 1923 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202,




    CUDA_ERROR_MAP_FAILED = 205,




    CUDA_ERROR_UNMAP_FAILED = 206,





    CUDA_ERROR_ARRAY_IS_MAPPED = 207,




    CUDA_ERROR_ALREADY_MAPPED = 208,







    CUDA_ERROR_NO_BINARY_FOR_GPU = 209,




    CUDA_ERROR_ALREADY_ACQUIRED = 210,




    CUDA_ERROR_NOT_MAPPED = 211,





    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212,





    CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213,





    CUDA_ERROR_ECC_UNCORRECTABLE = 214,





    CUDA_ERROR_UNSUPPORTED_LIMIT = 215,






    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216,





    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217,




    CUDA_ERROR_INVALID_PTX = 218,




    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219,





    CUDA_ERROR_NVLINK_UNCORRECTABLE = 220,




    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = 221,





    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = 222,




    CUDA_ERROR_JIT_COMPILATION_DISABLED = 223,





    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = 224,





    CUDA_ERROR_INVALID_SOURCE = 300,




    CUDA_ERROR_FILE_NOT_FOUND = 301,




    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302,




    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303,




    CUDA_ERROR_OPERATING_SYSTEM = 304,





    CUDA_ERROR_INVALID_HANDLE = 400,





    CUDA_ERROR_ILLEGAL_STATE = 401,






    CUDA_ERROR_NOT_FOUND = 500,







    CUDA_ERROR_NOT_READY = 600,
# 2099 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_ILLEGAL_ADDRESS = 700,
# 2110 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701,
# 2120 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_LAUNCH_TIMEOUT = 702,





    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703,






    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704,






    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705,





    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708,






    CUDA_ERROR_CONTEXT_IS_DESTROYED = 709,







    CUDA_ERROR_ASSERT = 710,






    CUDA_ERROR_TOO_MANY_PEERS = 711,





    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712,





    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713,
# 2189 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_HARDWARE_STACK_ERROR = 714,







    CUDA_ERROR_ILLEGAL_INSTRUCTION = 715,
# 2206 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_MISALIGNED_ADDRESS = 716,
# 2217 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_INVALID_ADDRESS_SPACE = 717,







    CUDA_ERROR_INVALID_PC = 718,
# 2236 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_LAUNCH_FAILED = 719,
# 2245 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720,




    CUDA_ERROR_NOT_PERMITTED = 800,





    CUDA_ERROR_NOT_SUPPORTED = 801,
# 2265 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_SYSTEM_NOT_READY = 802,






    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = 803,
# 2281 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = 804,




    CUDA_ERROR_MPS_CONNECTION_FAILED = 805,




    CUDA_ERROR_MPS_RPC_FAILURE = 806,





    CUDA_ERROR_MPS_SERVER_NOT_READY = 807,




    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = 808,




    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = 809,





    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900,





    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901,





    CUDA_ERROR_STREAM_CAPTURE_MERGE = 902,




    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903,





    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904,






    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905,





    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906,





    CUDA_ERROR_CAPTURED_EVENT = 907,






    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = 908,




    CUDA_ERROR_TIMEOUT = 909,





    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = 910,
# 2383 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_EXTERNAL_DEVICE = 911,
# 2395 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CUDA_ERROR_UNKNOWN = 999
} CUresult;




typedef enum CUdevice_P2PAttribute_enum {
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 0x01,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 0x02,
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 0x03,
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = 0x04,
    CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED = 0x04
} CUdevice_P2PAttribute;







typedef void ( *CUstreamCallback)(CUstream hStream, CUresult status, void *userData);







typedef size_t ( *CUoccupancyB2DSize)(int blockSize);
# 2488 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef struct CUDA_MEMCPY2D_st {
    size_t srcXInBytes;
    size_t srcY;

    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    size_t srcPitch;

    size_t dstXInBytes;
    size_t dstY;

    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    size_t dstPitch;

    size_t WidthInBytes;
    size_t Height;
} CUDA_MEMCPY2D_v2;
typedef CUDA_MEMCPY2D_v2 CUDA_MEMCPY2D;




typedef struct CUDA_MEMCPY3D_st {
    size_t srcXInBytes;
    size_t srcY;
    size_t srcZ;
    size_t srcLOD;
    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    void *reserved0;
    size_t srcPitch;
    size_t srcHeight;

    size_t dstXInBytes;
    size_t dstY;
    size_t dstZ;
    size_t dstLOD;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    void *reserved1;
    size_t dstPitch;
    size_t dstHeight;

    size_t WidthInBytes;
    size_t Height;
    size_t Depth;
} CUDA_MEMCPY3D_v2;
typedef CUDA_MEMCPY3D_v2 CUDA_MEMCPY3D;




typedef struct CUDA_MEMCPY3D_PEER_st {
    size_t srcXInBytes;
    size_t srcY;
    size_t srcZ;
    size_t srcLOD;
    CUmemorytype srcMemoryType;
    const void *srcHost;
    CUdeviceptr srcDevice;
    CUarray srcArray;
    CUcontext srcContext;
    size_t srcPitch;
    size_t srcHeight;

    size_t dstXInBytes;
    size_t dstY;
    size_t dstZ;
    size_t dstLOD;
    CUmemorytype dstMemoryType;
    void *dstHost;
    CUdeviceptr dstDevice;
    CUarray dstArray;
    CUcontext dstContext;
    size_t dstPitch;
    size_t dstHeight;

    size_t WidthInBytes;
    size_t Height;
    size_t Depth;
} CUDA_MEMCPY3D_PEER_v1;
typedef CUDA_MEMCPY3D_PEER_v1 CUDA_MEMCPY3D_PEER;




typedef struct CUDA_ARRAY_DESCRIPTOR_st
{
    size_t Width;
    size_t Height;

    CUarray_format Format;
    unsigned int NumChannels;
} CUDA_ARRAY_DESCRIPTOR_v2;
typedef CUDA_ARRAY_DESCRIPTOR_v2 CUDA_ARRAY_DESCRIPTOR;




typedef struct CUDA_ARRAY3D_DESCRIPTOR_st
{
    size_t Width;
    size_t Height;
    size_t Depth;

    CUarray_format Format;
    unsigned int NumChannels;
    unsigned int Flags;
} CUDA_ARRAY3D_DESCRIPTOR_v2;
typedef CUDA_ARRAY3D_DESCRIPTOR_v2 CUDA_ARRAY3D_DESCRIPTOR;
# 2616 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef struct CUDA_ARRAY_SPARSE_PROPERTIES_st {
    struct {
        unsigned int width;
        unsigned int height;
        unsigned int depth;
    } tileExtent;




    unsigned int miptailFirstLevel;



    unsigned long long miptailSize;



    unsigned int flags;
    unsigned int reserved[4];
} CUDA_ARRAY_SPARSE_PROPERTIES_v1;
typedef CUDA_ARRAY_SPARSE_PROPERTIES_v1 CUDA_ARRAY_SPARSE_PROPERTIES;





typedef struct CUDA_ARRAY_MEMORY_REQUIREMENTS_st {
    size_t size;
    size_t alignment;
    unsigned int reserved[4];
} CUDA_ARRAY_MEMORY_REQUIREMENTS_v1;
typedef CUDA_ARRAY_MEMORY_REQUIREMENTS_v1 CUDA_ARRAY_MEMORY_REQUIREMENTS;





typedef struct CUDA_RESOURCE_DESC_st
{
    CUresourcetype resType;

    union {
        struct {
            CUarray hArray;
        } array;
        struct {
            CUmipmappedArray hMipmappedArray;
        } mipmap;
        struct {
            CUdeviceptr devPtr;
            CUarray_format format;
            unsigned int numChannels;
            size_t sizeInBytes;
        } linear;
        struct {
            CUdeviceptr devPtr;
            CUarray_format format;
            unsigned int numChannels;
            size_t width;
            size_t height;
            size_t pitchInBytes;
        } pitch2D;
        struct {
            int reserved[32];
        } reserved;
    } res;

    unsigned int flags;
} CUDA_RESOURCE_DESC_v1;
typedef CUDA_RESOURCE_DESC_v1 CUDA_RESOURCE_DESC;




typedef struct CUDA_TEXTURE_DESC_st {
    CUaddress_mode addressMode[3];
    CUfilter_mode filterMode;
    unsigned int flags;
    unsigned int maxAnisotropy;
    CUfilter_mode mipmapFilterMode;
    float mipmapLevelBias;
    float minMipmapLevelClamp;
    float maxMipmapLevelClamp;
    float borderColor[4];
    int reserved[12];
} CUDA_TEXTURE_DESC_v1;
typedef CUDA_TEXTURE_DESC_v1 CUDA_TEXTURE_DESC;




typedef enum CUresourceViewFormat_enum
{
    CU_RES_VIEW_FORMAT_NONE = 0x00,
    CU_RES_VIEW_FORMAT_UINT_1X8 = 0x01,
    CU_RES_VIEW_FORMAT_UINT_2X8 = 0x02,
    CU_RES_VIEW_FORMAT_UINT_4X8 = 0x03,
    CU_RES_VIEW_FORMAT_SINT_1X8 = 0x04,
    CU_RES_VIEW_FORMAT_SINT_2X8 = 0x05,
    CU_RES_VIEW_FORMAT_SINT_4X8 = 0x06,
    CU_RES_VIEW_FORMAT_UINT_1X16 = 0x07,
    CU_RES_VIEW_FORMAT_UINT_2X16 = 0x08,
    CU_RES_VIEW_FORMAT_UINT_4X16 = 0x09,
    CU_RES_VIEW_FORMAT_SINT_1X16 = 0x0a,
    CU_RES_VIEW_FORMAT_SINT_2X16 = 0x0b,
    CU_RES_VIEW_FORMAT_SINT_4X16 = 0x0c,
    CU_RES_VIEW_FORMAT_UINT_1X32 = 0x0d,
    CU_RES_VIEW_FORMAT_UINT_2X32 = 0x0e,
    CU_RES_VIEW_FORMAT_UINT_4X32 = 0x0f,
    CU_RES_VIEW_FORMAT_SINT_1X32 = 0x10,
    CU_RES_VIEW_FORMAT_SINT_2X32 = 0x11,
    CU_RES_VIEW_FORMAT_SINT_4X32 = 0x12,
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = 0x13,
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = 0x14,
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = 0x15,
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = 0x16,
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = 0x17,
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = 0x18,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 0x19,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 0x1a,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 0x1b,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 0x1c,
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = 0x1d,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 0x1e,
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = 0x1f,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 0x20,
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = 0x21,
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 0x22
} CUresourceViewFormat;




typedef struct CUDA_RESOURCE_VIEW_DESC_st
{
    CUresourceViewFormat format;
    size_t width;
    size_t height;
    size_t depth;
    unsigned int firstMipmapLevel;
    unsigned int lastMipmapLevel;
    unsigned int firstLayer;
    unsigned int lastLayer;
    unsigned int reserved[16];
} CUDA_RESOURCE_VIEW_DESC_v1;
typedef CUDA_RESOURCE_VIEW_DESC_v1 CUDA_RESOURCE_VIEW_DESC;




typedef struct CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st {
    unsigned long long p2pToken;
    unsigned int vaSpaceToken;
} CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1;
typedef CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1 CUDA_POINTER_ATTRIBUTE_P2P_TOKENS;





typedef enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum {
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = 0x0,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = 0x1,
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 0x3
} CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS;




typedef struct CUDA_LAUNCH_PARAMS_st {
    CUfunction function;
    unsigned int gridDimX;
    unsigned int gridDimY;
    unsigned int gridDimZ;
    unsigned int blockDimX;
    unsigned int blockDimY;
    unsigned int blockDimZ;
    unsigned int sharedMemBytes;
    CUstream hStream;
    void **kernelParams;
} CUDA_LAUNCH_PARAMS_v1;
typedef CUDA_LAUNCH_PARAMS_v1 CUDA_LAUNCH_PARAMS;




typedef enum CUexternalMemoryHandleType_enum {



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = 6,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7,



    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = 8
} CUexternalMemoryHandleType;
# 2877 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {



    CUexternalMemoryHandleType type;
    union {





        int fd;
# 2904 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
        struct {



            void *handle;




            const void *name;
        } win32;




        const void *nvSciBufObject;
    } handle;



    unsigned long long size;



    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1;
typedef CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1 CUDA_EXTERNAL_MEMORY_HANDLE_DESC;




typedef struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {



    unsigned long long offset;



    unsigned long long size;



    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1;
typedef CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1 CUDA_EXTERNAL_MEMORY_BUFFER_DESC;




typedef struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {




    unsigned long long offset;



    CUDA_ARRAY3D_DESCRIPTOR arrayDesc;



    unsigned int numLevels;
    unsigned int reserved[16];
} CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1;
typedef CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1 CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC;




typedef enum CUexternalSemaphoreHandleType_enum {



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = 5,



 CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = 6,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = 7,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = 8,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9,



    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10
} CUexternalSemaphoreHandleType;




typedef struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {



    CUexternalSemaphoreHandleType type;
    union {






        int fd;
# 3051 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
        struct {



            void *handle;




            const void *name;
        } win32;



        const void* nvSciSyncObj;
    } handle;



    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1;
typedef CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1 CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC;




typedef struct CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st {
    struct {



        struct {



            unsigned long long value;
        } fence;
        union {




            void *fence;
            unsigned long long reserved;
        } nvSciSync;



        struct {



            unsigned long long key;
        } keyedMutex;
        unsigned int reserved[12];
    } params;
# 3118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1;
typedef CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1 CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS;




typedef struct CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st {
    struct {



        struct {



            unsigned long long value;
        } fence;




        union {
            void *fence;
            unsigned long long reserved;
        } nvSciSync;



        struct {



            unsigned long long key;



            unsigned int timeoutMs;
        } keyedMutex;
        unsigned int reserved[10];
    } params;
# 3169 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    unsigned int flags;
    unsigned int reserved[16];
} CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1;
typedef CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1 CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS;




typedef struct CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st {
    CUexternalSemaphore* extSemArray;
    const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS* paramsArray;
    unsigned int numExtSems;
} CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1;
typedef CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1 CUDA_EXT_SEM_SIGNAL_NODE_PARAMS;




typedef struct CUDA_EXT_SEM_WAIT_NODE_PARAMS_st {
    CUexternalSemaphore* extSemArray;
    const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS* paramsArray;
    unsigned int numExtSems;
} CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1;
typedef CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1 CUDA_EXT_SEM_WAIT_NODE_PARAMS;

typedef unsigned long long CUmemGenericAllocationHandle_v1;
typedef CUmemGenericAllocationHandle_v1 CUmemGenericAllocationHandle;




typedef enum CUmemAllocationHandleType_enum {
    CU_MEM_HANDLE_TYPE_NONE = 0x0,
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = 0x1,
    CU_MEM_HANDLE_TYPE_WIN32 = 0x2,
    CU_MEM_HANDLE_TYPE_WIN32_KMT = 0x4,
    CU_MEM_HANDLE_TYPE_MAX = 0x7FFFFFFF
} CUmemAllocationHandleType;




typedef enum CUmemAccess_flags_enum {
    CU_MEM_ACCESS_FLAGS_PROT_NONE = 0x0,
    CU_MEM_ACCESS_FLAGS_PROT_READ = 0x1,
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = 0x3,
    CU_MEM_ACCESS_FLAGS_PROT_MAX = 0x7FFFFFFF
} CUmemAccess_flags;




typedef enum CUmemLocationType_enum {
    CU_MEM_LOCATION_TYPE_INVALID = 0x0,
    CU_MEM_LOCATION_TYPE_DEVICE = 0x1,
    CU_MEM_LOCATION_TYPE_MAX = 0x7FFFFFFF
} CUmemLocationType;




typedef enum CUmemAllocationType_enum {
    CU_MEM_ALLOCATION_TYPE_INVALID = 0x0,




    CU_MEM_ALLOCATION_TYPE_PINNED = 0x1,
    CU_MEM_ALLOCATION_TYPE_MAX = 0x7FFFFFFF
} CUmemAllocationType;




typedef enum CUmemAllocationGranularity_flags_enum {
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = 0x0,
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = 0x1
} CUmemAllocationGranularity_flags;





typedef enum CUmemRangeHandleType_enum
{
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = 0x1,
    CU_MEM_RANGE_HANDLE_TYPE_MAX = 0x7FFFFFFF
} CUmemRangeHandleType;





typedef enum CUarraySparseSubresourceType_enum {
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1
} CUarraySparseSubresourceType;




typedef enum CUmemOperationType_enum {
    CU_MEM_OPERATION_TYPE_MAP = 1,
    CU_MEM_OPERATION_TYPE_UNMAP = 2
} CUmemOperationType;




typedef enum CUmemHandleType_enum {
    CU_MEM_HANDLE_TYPE_GENERIC = 0
} CUmemHandleType;




typedef struct CUarrayMapInfo_st {
    CUresourcetype resourceType;

    union {
        CUmipmappedArray mipmap;
        CUarray array;
    } resource;

    CUarraySparseSubresourceType subresourceType;

    union {
        struct {
            unsigned int level;
            unsigned int layer;
            unsigned int offsetX;
            unsigned int offsetY;
            unsigned int offsetZ;
            unsigned int extentWidth;
            unsigned int extentHeight;
            unsigned int extentDepth;
        } sparseLevel;
        struct {
            unsigned int layer;
            unsigned long long offset;
            unsigned long long size;
        } miptail;
    } subresource;

    CUmemOperationType memOperationType;
    CUmemHandleType memHandleType;

    union {
        CUmemGenericAllocationHandle memHandle;
    } memHandle;

    unsigned long long offset;
    unsigned int deviceBitMask;
    unsigned int flags;
    unsigned int reserved[2];
} CUarrayMapInfo_v1;
typedef CUarrayMapInfo_v1 CUarrayMapInfo;




typedef struct CUmemLocation_st {
    CUmemLocationType type;
    int id;
} CUmemLocation_v1;
typedef CUmemLocation_v1 CUmemLocation;




typedef enum CUmemAllocationCompType_enum {
    CU_MEM_ALLOCATION_COMP_NONE = 0x0,
    CU_MEM_ALLOCATION_COMP_GENERIC = 0x1
} CUmemAllocationCompType;
# 3352 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef struct CUmemAllocationProp_st {

    CUmemAllocationType type;

    CUmemAllocationHandleType requestedHandleTypes;

    CUmemLocation location;







    void *win32HandleMetaData;
    struct {
# 3378 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
         unsigned char compressionType;
         unsigned char gpuDirectRDMACapable;

         unsigned short usage;
         unsigned char reserved[4];
    } allocFlags;
} CUmemAllocationProp_v1;
typedef CUmemAllocationProp_v1 CUmemAllocationProp;




typedef struct CUmemAccessDesc_st {
    CUmemLocation location;
    CUmemAccess_flags flags;
} CUmemAccessDesc_v1;
typedef CUmemAccessDesc_v1 CUmemAccessDesc;

typedef enum CUgraphExecUpdateResult_enum {
    CU_GRAPH_EXEC_UPDATE_SUCCESS = 0x0,
    CU_GRAPH_EXEC_UPDATE_ERROR = 0x1,
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = 0x2,
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = 0x3,
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = 0x4,
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = 0x5,
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = 0x6,
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = 0x7,
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED = 0x8
} CUgraphExecUpdateResult;




typedef enum CUmemPool_attribute_enum {
# 3420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1,






    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC,







    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES,
# 3445 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD,





    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT,






    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH,





    CU_MEMPOOL_ATTR_USED_MEM_CURRENT,






    CU_MEMPOOL_ATTR_USED_MEM_HIGH
} CUmemPool_attribute;




typedef struct CUmemPoolProps_st {
    CUmemAllocationType allocType;
    CUmemAllocationHandleType handleTypes;
    CUmemLocation location;






    void *win32SecurityAttributes;
    unsigned char reserved[64];
} CUmemPoolProps_v1;
typedef CUmemPoolProps_v1 CUmemPoolProps;




typedef struct CUmemPoolPtrExportData_st {
    unsigned char reserved[64];
} CUmemPoolPtrExportData_v1;
typedef CUmemPoolPtrExportData_v1 CUmemPoolPtrExportData;




typedef struct CUDA_MEM_ALLOC_NODE_PARAMS_st {




    CUmemPoolProps poolProps;
    const CUmemAccessDesc *accessDescs;
    size_t accessDescCount;
    size_t bytesize;
    CUdeviceptr dptr;
} CUDA_MEM_ALLOC_NODE_PARAMS;

typedef enum CUgraphMem_attribute_enum {




    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT,






    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH,






    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT,






    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH
} CUgraphMem_attribute;
# 3714 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef enum CUflushGPUDirectRDMAWritesOptions_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = 1<<0,
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = 1<<1
} CUflushGPUDirectRDMAWritesOptions;




typedef enum CUGPUDirectRDMAWritesOrdering_enum {
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = 0,
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = 100,
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200
} CUGPUDirectRDMAWritesOrdering;




typedef enum CUflushGPUDirectRDMAWritesScope_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = 100,
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200
} CUflushGPUDirectRDMAWritesScope;




typedef enum CUflushGPUDirectRDMAWritesTarget_enum {
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = 0
} CUflushGPUDirectRDMAWritesTarget;




typedef enum CUgraphDebugDot_flags_enum {
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = 1<<0,
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = 1<<1,
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = 1<<2,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = 1<<3,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = 1<<4,
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = 1<<5,
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = 1<<6,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = 1<<7,
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = 1<<8,
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = 1<<9,
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = 1<<10,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = 1<<11,
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = 1<<12

    ,
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = 1<<13

} CUgraphDebugDot_flags;




typedef enum CUuserObject_flags_enum {
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1
} CUuserObject_flags;




typedef enum CUuserObjectRetain_flags_enum {
    CU_GRAPH_USER_OBJECT_MOVE = 1
} CUuserObjectRetain_flags;




typedef enum CUgraphInstantiate_flags_enum {
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = 1





  , CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = 8


} CUgraphInstantiate_flags;
# 3840 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGetErrorString(CUresult error, const char **pStr);
# 3861 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGetErrorName(CUresult error, const char **pStr);
# 3895 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuInit(unsigned int Flags);
# 3933 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDriverGetVersion(int *driverVersion);
# 3976 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGet(CUdevice *device, int ordinal);
# 4005 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetCount(int *count);
# 4037 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetName(char *name, int len, CUdevice dev);
# 4070 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetUuid(CUuuid *uuid, CUdevice dev);
# 4099 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetUuid_v2(CUuuid *uuid, CUdevice dev);
# 4128 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetLuid(char *luid, unsigned int *deviceNodeMask, CUdevice dev);
# 4157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceTotalMem_v2(size_t *bytes, CUdevice dev);
# 4188 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetTexture1DLinearMaxWidth(size_t *maxWidthInElements, CUarray_format format, unsigned numChannels, CUdevice dev);
# 4413 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetAttribute(int *pi, CUdevice_attribute attrib, CUdevice dev);
# 4462 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetNvSciSyncAttributes(void *nvSciSyncAttrList, CUdevice dev, int flags);
# 4480 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceSetMemPool(CUdevice dev, CUmemoryPool pool);
# 4496 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetMemPool(CUmemoryPool *pool, CUdevice dev);
# 4514 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetDefaultMemPool(CUmemoryPool *pool_out, CUdevice dev);
# 4546 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuFlushGPUDirectRDMAWrites(CUflushGPUDirectRDMAWritesTarget target, CUflushGPUDirectRDMAWritesScope scope);
# 4625 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuDeviceGetProperties(CUdevprop *prop, CUdevice dev);
# 4659 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuDeviceComputeCapability(int *major, int *minor, CUdevice dev);
# 4726 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDevicePrimaryCtxRetain(CUcontext *pctx, CUdevice dev);
# 4767 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDevicePrimaryCtxRelease_v2(CUdevice dev);
# 4832 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDevicePrimaryCtxSetFlags_v2(CUdevice dev, unsigned int flags);
# 4858 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDevicePrimaryCtxGetState(CUdevice dev, unsigned int *flags, int *active);
# 4898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDevicePrimaryCtxReset_v2(CUdevice dev);
# 4931 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetExecAffinitySupport(int *pi, CUexecAffinityType type, CUdevice dev);
# 5040 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxCreate_v2(CUcontext *pctx, unsigned int flags, CUdevice dev);
# 5147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxCreate_v3(CUcontext *pctx, CUexecAffinityParam *paramsArray, int numParams, unsigned int flags, CUdevice dev);
# 5192 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxDestroy_v2(CUcontext ctx);
# 5226 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxPushCurrent_v2(CUcontext ctx);
# 5260 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxPopCurrent_v2(CUcontext *pctx);
# 5290 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxSetCurrent(CUcontext ctx);
# 5313 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetCurrent(CUcontext *pctx);
# 5343 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetDevice(CUdevice *device);
# 5371 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetFlags(unsigned int *flags);
# 5401 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxSynchronize(void);
# 5500 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxSetLimit(CUlimit limit, size_t value);
# 5542 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetLimit(size_t *pvalue, CUlimit limit);
# 5586 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetCacheConfig(CUfunc_cache *pconfig);
# 5637 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxSetCacheConfig(CUfunc_cache config);
# 5679 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetSharedMemConfig(CUsharedconfig *pConfig);
# 5732 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxSetSharedMemConfig(CUsharedconfig config);
# 5770 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetApiVersion(CUcontext ctx, unsigned int *version);
# 5810 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetStreamPriorityRange(int *leastPriority, int *greatestPriority);
# 5826 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxResetPersistingL2Cache(void);
# 5850 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxGetExecAffinity(CUexecAffinityParam *pExecAffinity, CUexecAffinityType type);
# 5906 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuCtxAttach(CUcontext *pctx, unsigned int flags);
# 5942 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuCtxDetach(CUcontext ctx);
# 5998 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleLoad(CUmodule *module, const char *fname);
# 6036 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleLoadData(CUmodule *module, const void *image);
# 6080 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleLoadDataEx(CUmodule *module, const void *image, unsigned int numOptions, CUjit_option *options, void **optionValues);
# 6123 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleLoadFatBinary(CUmodule *module, const void *fatCubin);
# 6149 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleUnload(CUmodule hmod);
# 6179 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleGetFunction(CUfunction *hfunc, CUmodule hmod, const char *name);
# 6214 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleGetGlobal_v2(CUdeviceptr *dptr, size_t *bytes, CUmodule hmod, const char *name);
# 6248 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleGetTexRef(CUtexref *pTexRef, CUmodule hmod, const char *name);
# 6280 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleGetSurfRef(CUsurfref *pSurfRef, CUmodule hmod, const char *name);
# 6320 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult
cuLinkCreate_v2(unsigned int numOptions, CUjit_option *options, void **optionValues, CUlinkState *stateOut);
# 6358 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult
cuLinkAddData_v2(CUlinkState state, CUjitInputType type, void *data, size_t size, const char *name,
    unsigned int numOptions, CUjit_option *options, void **optionValues);
# 6398 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult
cuLinkAddFile_v2(CUlinkState state, CUjitInputType type, const char *path,
    unsigned int numOptions, CUjit_option *options, void **optionValues);
# 6425 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult
cuLinkComplete(CUlinkState state, void **cubinOut, size_t *sizeOut);
# 6439 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult
cuLinkDestroy(CUlinkState state);
# 6498 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemGetInfo_v2(size_t *free, size_t *total);
# 6532 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAlloc_v2(CUdeviceptr *dptr, size_t bytesize);
# 6594 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAllocPitch_v2(CUdeviceptr *dptr, size_t *pPitch, size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes);
# 6630 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemFree_v2(CUdeviceptr dptr);
# 6664 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemGetAddressRange_v2(CUdeviceptr *pbase, size_t *psize, CUdeviceptr dptr);
# 6711 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAllocHost_v2(void **pp, size_t bytesize);
# 6741 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemFreeHost(void *p);
# 6820 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemHostAlloc(void **pp, size_t bytesize, unsigned int Flags);
# 6873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemHostGetDevicePointer_v2(CUdeviceptr *pdptr, void *p, unsigned int Flags);
# 6900 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemHostGetFlags(unsigned int *pFlags, void *p);
# 7010 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAllocManaged(CUdeviceptr *dptr, size_t bytesize, unsigned int flags);
# 7039 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetByPCIBusId(CUdevice *dev, const char *pciBusId);
# 7071 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetPCIBusId(char *pciBusId, int len, CUdevice dev);
# 7116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuIpcGetEventHandle(CUipcEventHandle *pHandle, CUevent event);
# 7156 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuIpcOpenEventHandle(CUevent *phEvent, CUipcEventHandle handle);
# 7197 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuIpcGetMemHandle(CUipcMemHandle *pHandle, CUdeviceptr dptr);
# 7255 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuIpcOpenMemHandle_v2(CUdeviceptr *pdptr, CUipcMemHandle handle, unsigned int Flags);
# 7289 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuIpcCloseMemHandle(CUdeviceptr dptr);
# 7376 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemHostRegister_v2(void *p, size_t bytesize, unsigned int Flags);
# 7402 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemHostUnregister(void *p);
# 7442 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount);
# 7472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyPeer(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount);
# 7508 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyHtoD_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount);
# 7544 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyDtoH_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount);
# 7580 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyDtoD_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount);
# 7616 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyDtoA_v2(CUarray dstArray, size_t dstOffset, CUdeviceptr srcDevice, size_t ByteCount);
# 7654 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyAtoD_v2(CUdeviceptr dstDevice, CUarray srcArray, size_t srcOffset, size_t ByteCount);
# 7691 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyHtoA_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount);
# 7728 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyAtoH_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount);
# 7768 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyAtoA_v2(CUarray dstArray, size_t dstOffset, CUarray srcArray, size_t srcOffset, size_t ByteCount);
# 7932 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy2D_v2(const CUDA_MEMCPY2D *pCopy);
# 8094 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy2DUnaligned_v2(const CUDA_MEMCPY2D *pCopy);
# 8263 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy3D_v2(const CUDA_MEMCPY3D *pCopy);
# 8287 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy3DPeer(const CUDA_MEMCPY3D_PEER *pCopy);
# 8332 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyAsync(CUdeviceptr dst, CUdeviceptr src, size_t ByteCount, CUstream hStream);
# 8365 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyPeerAsync(CUdeviceptr dstDevice, CUcontext dstContext, CUdeviceptr srcDevice, CUcontext srcContext, size_t ByteCount, CUstream hStream);
# 8406 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyHtoDAsync_v2(CUdeviceptr dstDevice, const void *srcHost, size_t ByteCount, CUstream hStream);
# 8447 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyDtoHAsync_v2(void *dstHost, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
# 8488 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyDtoDAsync_v2(CUdeviceptr dstDevice, CUdeviceptr srcDevice, size_t ByteCount, CUstream hStream);
# 8530 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyHtoAAsync_v2(CUarray dstArray, size_t dstOffset, const void *srcHost, size_t ByteCount, CUstream hStream);
# 8572 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpyAtoHAsync_v2(void *dstHost, CUarray srcArray, size_t srcOffset, size_t ByteCount, CUstream hStream);
# 8741 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy2DAsync_v2(const CUDA_MEMCPY2D *pCopy, CUstream hStream);
# 8915 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy3DAsync_v2(const CUDA_MEMCPY3D *pCopy, CUstream hStream);
# 8941 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemcpy3DPeerAsync(const CUDA_MEMCPY3D_PEER *pCopy, CUstream hStream);
# 8976 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD8_v2(CUdeviceptr dstDevice, unsigned char uc, size_t N);
# 9011 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD16_v2(CUdeviceptr dstDevice, unsigned short us, size_t N);
# 9046 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD32_v2(CUdeviceptr dstDevice, unsigned int ui, size_t N);
# 9086 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD2D8_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height);
# 9127 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD2D16_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height);
# 9168 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD2D32_v2(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height);
# 9205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD8Async(CUdeviceptr dstDevice, unsigned char uc, size_t N, CUstream hStream);
# 9242 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD16Async(CUdeviceptr dstDevice, unsigned short us, size_t N, CUstream hStream);
# 9278 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD32Async(CUdeviceptr dstDevice, unsigned int ui, size_t N, CUstream hStream);
# 9320 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD2D8Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, CUstream hStream);
# 9363 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD2D16Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, CUstream hStream);
# 9406 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemsetD2D32Async(CUdeviceptr dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, CUstream hStream);
# 9510 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArrayCreate_v2(CUarray *pHandle, const CUDA_ARRAY_DESCRIPTOR *pAllocateArray);
# 9544 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArrayGetDescriptor_v2(CUDA_ARRAY_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
# 9568 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES *sparseProperties, CUarray array);
# 9593 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMipmappedArrayGetSparseProperties(CUDA_ARRAY_SPARSE_PROPERTIES *sparseProperties, CUmipmappedArray mipmap);
# 9617 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS *memoryRequirements, CUarray array, CUdevice device);
# 9641 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMipmappedArrayGetMemoryRequirements(CUDA_ARRAY_MEMORY_REQUIREMENTS *memoryRequirements, CUmipmappedArray mipmap, CUdevice device);
# 9675 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArrayGetPlane(CUarray *pPlaneArray, CUarray hArray, unsigned int planeIdx);
# 9706 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArrayDestroy(CUarray hArray);
# 9886 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArray3DCreate_v2(CUarray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pAllocateArray);
# 9924 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuArray3DGetDescriptor_v2(CUDA_ARRAY3D_DESCRIPTOR *pArrayDescriptor, CUarray hArray);
# 10066 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMipmappedArrayCreate(CUmipmappedArray *pHandle, const CUDA_ARRAY3D_DESCRIPTOR *pMipmappedArrayDesc, unsigned int numMipmapLevels);
# 10096 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMipmappedArrayGetLevel(CUarray *pLevelArray, CUmipmappedArray hMipmappedArray, unsigned int level);
# 10121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMipmappedArrayDestroy(CUmipmappedArray hMipmappedArray);
# 10162 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAddressReserve(CUdeviceptr *ptr, size_t size, size_t alignment, CUdeviceptr addr, unsigned long long flags);
# 10183 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAddressFree(CUdeviceptr ptr, size_t size);
# 10222 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemCreate(CUmemGenericAllocationHandle *handle, size_t size, const CUmemAllocationProp *prop, unsigned long long flags);
# 10249 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemRelease(CUmemGenericAllocationHandle handle);
# 10293 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemMap(CUdeviceptr ptr, size_t size, size_t offset, CUmemGenericAllocationHandle handle, unsigned long long flags);
# 10434 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemMapArrayAsync(CUarrayMapInfo *mapInfoList, unsigned int count, CUstream hStream);
# 10463 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemUnmap(CUdeviceptr ptr, size_t size);
# 10488 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemSetAccess(CUdeviceptr ptr, size_t size, const CUmemAccessDesc *desc, size_t count);
# 10507 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemGetAccess(unsigned long long *flags, const CUmemLocation *location, CUdeviceptr ptr);
# 10540 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemExportToShareableHandle(void *shareableHandle, CUmemGenericAllocationHandle handle, CUmemAllocationHandleType handleType, unsigned long long flags);
# 10567 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemImportFromShareableHandle(CUmemGenericAllocationHandle *handle, void *osHandle, CUmemAllocationHandleType shHandleType);
# 10589 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemGetAllocationGranularity(size_t *granularity, const CUmemAllocationProp *prop, CUmemAllocationGranularity_flags option);
# 10606 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemGetAllocationPropertiesFromHandle(CUmemAllocationProp *prop, CUmemGenericAllocationHandle handle);
# 10630 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemRetainAllocationHandle(CUmemGenericAllocationHandle *handle, void *addr);
# 10687 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemFreeAsync(CUdeviceptr dptr, CUstream hStream);
# 10720 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAllocAsync(CUdeviceptr *dptr, size_t bytesize, CUstream hStream);
# 10746 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolTrimTo(CUmemoryPool pool, size_t minBytesToKeep);
# 10789 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolSetAttribute(CUmemoryPool pool, CUmemPool_attribute attr, void *value);
# 10836 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolGetAttribute(CUmemoryPool pool, CUmemPool_attribute attr, void *value);
# 10853 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolSetAccess(CUmemoryPool pool, const CUmemAccessDesc *map, size_t count);
# 10867 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolGetAccess(CUmemAccess_flags *flags, CUmemoryPool memPool, CUmemLocation *location);
# 10889 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolCreate(CUmemoryPool *pool, const CUmemPoolProps *poolProps);
# 10912 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolDestroy(CUmemoryPool pool);
# 10950 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAllocFromPoolAsync(CUdeviceptr *dptr, size_t bytesize, CUmemoryPool pool, CUstream hStream);
# 10979 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolExportToShareableHandle(void *handle_out, CUmemoryPool pool, CUmemAllocationHandleType handleType, unsigned long long flags);
# 11003 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolImportFromShareableHandle(
        CUmemoryPool *pool_out,
        void *handle,
        CUmemAllocationHandleType handleType,
        unsigned long long flags);
# 11027 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolExportPointer(CUmemPoolPtrExportData *shareData_out, CUdeviceptr ptr);
# 11056 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPoolImportPointer(CUdeviceptr *ptr_out, CUmemoryPool pool, CUmemPoolPtrExportData *shareData);
# 11341 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuPointerGetAttribute(void *data, CUpointer_attribute attribute, CUdeviceptr ptr);
# 11409 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemPrefetchAsync(CUdeviceptr devPtr, size_t count, CUdevice dstDevice, CUstream hStream);
# 11523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemAdvise(CUdeviceptr devPtr, size_t count, CUmem_advise advice, CUdevice device);
# 11581 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemRangeGetAttribute(void *data, size_t dataSize, CUmem_range_attribute attribute, CUdeviceptr devPtr, size_t count);
# 11621 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemRangeGetAttributes(void **data, size_t *dataSizes, CUmem_range_attribute *attributes, size_t numAttributes, CUdeviceptr devPtr, size_t count);
# 11663 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuPointerSetAttribute(const void *value, CUpointer_attribute attribute, CUdeviceptr ptr);
# 11712 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuPointerGetAttributes(unsigned int numAttributes, CUpointer_attribute *attributes, void **data, CUdeviceptr ptr);
# 11763 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamCreate(CUstream *phStream, unsigned int Flags);
# 11812 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamCreateWithPriority(CUstream *phStream, unsigned int flags, int priority);
# 11843 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamGetPriority(CUstream hStream, int *priority);
# 11871 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamGetFlags(CUstream hStream, unsigned int *flags);
# 11915 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamGetCtx(CUstream hStream, CUcontext *pctx);
# 11952 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWaitEvent(CUstream hStream, CUevent hEvent, unsigned int Flags);
# 12027 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamAddCallback(CUstream hStream, CUstreamCallback callback, void *userData, unsigned int flags);
# 12065 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamBeginCapture_v2(CUstream hStream, CUstreamCaptureMode mode);
# 12118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuThreadExchangeStreamCaptureMode(CUstreamCaptureMode *mode);
# 12148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamEndCapture(CUstream hStream, CUgraph *phGraph);
# 12188 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamIsCapturing(CUstream hStream, CUstreamCaptureStatus *captureStatus);
# 12216 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamGetCaptureInfo(CUstream hStream, CUstreamCaptureStatus *captureStatus_out, cuuint64_t *id_out);
# 12270 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamGetCaptureInfo_v2(CUstream hStream, CUstreamCaptureStatus *captureStatus_out,
        cuuint64_t *id_out, CUgraph *graph_out, const CUgraphNode **dependencies_out, size_t *numDependencies_out);
# 12303 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamUpdateCaptureDependencies(CUstream hStream, CUgraphNode *dependencies, size_t numDependencies, unsigned int flags);
# 12391 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamAttachMemAsync(CUstream hStream, CUdeviceptr dptr, size_t length, unsigned int flags);
# 12421 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamQuery(CUstream hStream);
# 12450 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamSynchronize(CUstream hStream);
# 12480 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamDestroy_v2(CUstream hStream);
# 12500 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamCopyAttributes(CUstream dst, CUstream src);
# 12521 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamGetAttribute(CUstream hStream, CUstreamAttrID attr,
                                      CUstreamAttrValue *value_out);
# 12544 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamSetAttribute(CUstream hStream, CUstreamAttrID attr,
                                      const CUstreamAttrValue *value);
# 12601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventCreate(CUevent *phEvent, unsigned int Flags);
# 12643 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventRecord(CUevent hEvent, CUstream hStream);
# 12692 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventRecordWithFlags(CUevent hEvent, CUstream hStream, unsigned int flags);
# 12724 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventQuery(CUevent hEvent);
# 12755 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventSynchronize(CUevent hEvent);
# 12784 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventDestroy_v2(CUevent hEvent);
# 12828 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuEventElapsedTime(float *pMilliseconds, CUevent hStart, CUevent hEnd);
# 13006 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuImportExternalMemory(CUexternalMemory *extMem_out, const CUDA_EXTERNAL_MEMORY_HANDLE_DESC *memHandleDesc);
# 13060 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuExternalMemoryGetMappedBuffer(CUdeviceptr *devPtr, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_BUFFER_DESC *bufferDesc);
# 13116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuExternalMemoryGetMappedMipmappedArray(CUmipmappedArray *mipmap, CUexternalMemory extMem, const CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC *mipmapDesc);
# 13138 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDestroyExternalMemory(CUexternalMemory extMem);
# 13295 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuImportExternalSemaphore(CUexternalSemaphore *extSem_out, const CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC *semHandleDesc);
# 13362 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuSignalExternalSemaphoresAsync(const CUexternalSemaphore *extSemArray, const CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS *paramsArray, unsigned int numExtSems, CUstream stream);
# 13438 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuWaitExternalSemaphoresAsync(const CUexternalSemaphore *extSemArray, const CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS *paramsArray, unsigned int numExtSems, CUstream stream);
# 13459 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDestroyExternalSemaphore(CUexternalSemaphore extSem);
# 13638 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWaitValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);
# 13683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWaitValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);
# 13718 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWriteValue32(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);
# 13752 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWriteValue64(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);
# 13797 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamBatchMemOp(CUstream stream, unsigned int count, CUstreamBatchMemOpParams *paramArray, unsigned int flags);
# 13844 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWaitValue32_v2(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);
# 13889 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWaitValue64_v2(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);
# 13918 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWriteValue32_v2(CUstream stream, CUdeviceptr addr, cuuint32_t value, unsigned int flags);
# 13949 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamWriteValue64_v2(CUstream stream, CUdeviceptr addr, cuuint64_t value, unsigned int flags);
# 13992 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuStreamBatchMemOp_v2(CUstream stream, unsigned int count, CUstreamBatchMemOpParams *paramArray, unsigned int flags);
# 14090 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuFuncGetAttribute(int *pi, CUfunction_attribute attrib, CUfunction hfunc);
# 14155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuFuncSetAttribute(CUfunction hfunc, CUfunction_attribute attrib, int value);
# 14199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuFuncSetCacheConfig(CUfunction hfunc, CUfunc_cache config);
# 14251 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuFuncSetSharedMemConfig(CUfunction hfunc, CUsharedconfig config);
# 14277 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuFuncGetModule(CUmodule *hmod, CUfunction hfunc);
# 14386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuLaunchKernel(CUfunction f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                CUstream hStream,
                                void **kernelParams,
                                void **extra);
# 14664 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuLaunchCooperativeKernel(CUfunction f,
                                unsigned int gridDimX,
                                unsigned int gridDimY,
                                unsigned int gridDimZ,
                                unsigned int blockDimX,
                                unsigned int blockDimY,
                                unsigned int blockDimZ,
                                unsigned int sharedMemBytes,
                                CUstream hStream,
                                void **kernelParams);
# 14810 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuLaunchCooperativeKernelMultiDevice(CUDA_LAUNCH_PARAMS *launchParamsList, unsigned int numDevices, unsigned int flags);
# 14875 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuLaunchHostFunc(CUstream hStream, CUhostFn fn, void *userData);
# 14925 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuFuncSetBlockShape(CUfunction hfunc, int x, int y, int z);
# 14959 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuFuncSetSharedSize(CUfunction hfunc, unsigned int bytes);
# 14991 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuParamSetSize(CUfunction hfunc, unsigned int numbytes);
# 15024 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuParamSeti(CUfunction hfunc, int offset, unsigned int value);
# 15057 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuParamSetf(CUfunction hfunc, int offset, float value);
# 15092 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuParamSetv(CUfunction hfunc, int offset, void *ptr, unsigned int numbytes);
# 15144 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuLaunch(CUfunction f);
# 15198 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuLaunchGrid(CUfunction f, int grid_width, int grid_height);
# 15260 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuLaunchGridAsync(CUfunction f, int grid_width, int grid_height, CUstream hStream);
# 15285 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuParamSetTexRef(CUfunction hfunc, int texunit, CUtexref hTexRef);
# 15331 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphCreate(CUgraph *phGraph, unsigned int flags);
# 15431 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddKernelNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_KERNEL_NODE_PARAMS *nodeParams);
# 15463 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphKernelNodeGetParams(CUgraphNode hNode, CUDA_KERNEL_NODE_PARAMS *nodeParams);
# 15486 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphKernelNodeSetParams(CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS *nodeParams);
# 15534 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddMemcpyNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_MEMCPY3D *copyParams, CUcontext ctx);
# 15557 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphMemcpyNodeGetParams(CUgraphNode hNode, CUDA_MEMCPY3D *nodeParams);
# 15580 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphMemcpyNodeSetParams(CUgraphNode hNode, const CUDA_MEMCPY3D *nodeParams);
# 15622 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddMemsetNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_MEMSET_NODE_PARAMS *memsetParams, CUcontext ctx);
# 15645 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphMemsetNodeGetParams(CUgraphNode hNode, CUDA_MEMSET_NODE_PARAMS *nodeParams);
# 15668 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphMemsetNodeSetParams(CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS *nodeParams);
# 15709 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddHostNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_HOST_NODE_PARAMS *nodeParams);
# 15732 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphHostNodeGetParams(CUgraphNode hNode, CUDA_HOST_NODE_PARAMS *nodeParams);
# 15755 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphHostNodeSetParams(CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS *nodeParams);
# 15795 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddChildGraphNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUgraph childGraph);
# 15822 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphChildGraphNodeGetGraph(CUgraphNode hNode, CUgraph *phGraph);
# 15860 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddEmptyNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies);
# 15901 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddEventRecordNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUevent event);
# 15926 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphEventRecordNodeGetEvent(CUgraphNode hNode, CUevent *event_out);
# 15951 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphEventRecordNodeSetEvent(CUgraphNode hNode, CUevent event);
# 15993 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddEventWaitNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUevent event);
# 16018 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphEventWaitNodeGetEvent(CUgraphNode hNode, CUevent *event_out);
# 16043 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphEventWaitNodeSetEvent(CUgraphNode hNode, CUevent event);
# 16091 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddExternalSemaphoresSignalNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *nodeParams);
# 16122 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExternalSemaphoresSignalNodeGetParams(CUgraphNode hNode, CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *params_out);
# 16147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExternalSemaphoresSignalNodeSetParams(CUgraphNode hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *nodeParams);
# 16195 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddExternalSemaphoresWaitNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_EXT_SEM_WAIT_NODE_PARAMS *nodeParams);
# 16226 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExternalSemaphoresWaitNodeGetParams(CUgraphNode hNode, CUDA_EXT_SEM_WAIT_NODE_PARAMS *params_out);
# 16251 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExternalSemaphoresWaitNodeSetParams(CUgraphNode hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS *nodeParams);
# 16309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddBatchMemOpNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, const CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams);
# 16337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphBatchMemOpNodeGetParams(CUgraphNode hNode, CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams_out);
# 16363 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphBatchMemOpNodeSetParams(CUgraphNode hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams);
# 16409 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecBatchMemOpNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_BATCH_MEM_OP_NODE_PARAMS *nodeParams);
# 16484 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddMemAllocNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUDA_MEM_ALLOC_NODE_PARAMS *nodeParams);
# 16509 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphMemAllocNodeGetParams(CUgraphNode hNode, CUDA_MEM_ALLOC_NODE_PARAMS *params_out);
# 16566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddMemFreeNode(CUgraphNode *phGraphNode, CUgraph hGraph, const CUgraphNode *dependencies, size_t numDependencies, CUdeviceptr dptr);
# 16588 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphMemFreeNodeGetParams(CUgraphNode hNode, CUdeviceptr *dptr_out);
# 16608 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGraphMemTrim(CUdevice device);
# 16636 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetGraphMemAttribute(CUdevice device, CUgraphMem_attribute attr, void* value);
# 16661 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceSetGraphMemAttribute(CUdevice device, CUgraphMem_attribute attr, void* value);
# 16686 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphClone(CUgraph *phGraphClone, CUgraph originalGraph);
# 16712 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphNodeFindInClone(CUgraphNode *phNode, CUgraphNode hOriginalNode, CUgraph hClonedGraph);
# 16743 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphNodeGetType(CUgraphNode hNode, CUgraphNodeType *type);
# 16774 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphGetNodes(CUgraph hGraph, CUgraphNode *nodes, size_t *numNodes);
# 16805 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphGetRootNodes(CUgraph hGraph, CUgraphNode *rootNodes, size_t *numRootNodes);
# 16839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphGetEdges(CUgraph hGraph, CUgraphNode *from, CUgraphNode *to, size_t *numEdges);
# 16870 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphNodeGetDependencies(CUgraphNode hNode, CUgraphNode *dependencies, size_t *numDependencies);
# 16902 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphNodeGetDependentNodes(CUgraphNode hNode, CUgraphNode *dependentNodes, size_t *numDependentNodes);
# 16931 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphAddDependencies(CUgraph hGraph, const CUgraphNode *from, const CUgraphNode *to, size_t numDependencies);
# 16963 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphRemoveDependencies(CUgraph hGraph, const CUgraphNode *from, const CUgraphNode *to, size_t numDependencies);
# 16990 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphDestroyNode(CUgraphNode hNode);
# 17028 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphInstantiate_v2(CUgraphExec *phGraphExec, CUgraph hGraph, CUgraphNode *phErrorNode, char *logBuffer, size_t bufferSize);
# 17077 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphInstantiateWithFlags(CUgraphExec *phGraphExec, CUgraph hGraph, unsigned long long flags);
# 17245 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecKernelNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_KERNEL_NODE_PARAMS *nodeParams);
# 17291 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecMemcpyNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_MEMCPY3D *copyParams, CUcontext ctx);
# 17337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecMemsetNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_MEMSET_NODE_PARAMS *memsetParams, CUcontext ctx);
# 17374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecHostNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_HOST_NODE_PARAMS *nodeParams);
# 17417 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecChildGraphNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, CUgraph childGraph);
# 17457 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecEventRecordNodeSetEvent(CUgraphExec hGraphExec, CUgraphNode hNode, CUevent event);
# 17497 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecEventWaitNodeSetEvent(CUgraphExec hGraphExec, CUgraphNode hNode, CUevent event);
# 17540 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecExternalSemaphoresSignalNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_EXT_SEM_SIGNAL_NODE_PARAMS *nodeParams);
# 17583 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecExternalSemaphoresWaitNodeSetParams(CUgraphExec hGraphExec, CUgraphNode hNode, const CUDA_EXT_SEM_WAIT_NODE_PARAMS *nodeParams);
# 17656 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphNodeSetEnabled(CUgraphExec hGraphExec, CUgraphNode hNode, unsigned int isEnabled);
# 17717 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphNodeGetEnabled(CUgraphExec hGraphExec, CUgraphNode hNode, unsigned int *isEnabled);
# 17743 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphUpload(CUgraphExec hGraphExec, CUstream hStream);
# 17773 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphLaunch(CUgraphExec hGraphExec, CUstream hStream);
# 17798 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecDestroy(CUgraphExec hGraphExec);
# 17818 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphDestroy(CUgraph hGraph);
# 17974 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphExecUpdate(CUgraphExec hGraphExec, CUgraph hGraph, CUgraphNode *hErrorNode_out, CUgraphExecUpdateResult *updateResult_out);
# 17994 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphKernelNodeCopyAttributes(CUgraphNode dst, CUgraphNode src);
# 18015 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphKernelNodeGetAttribute(CUgraphNode hNode, CUkernelNodeAttrID attr,
                                      CUkernelNodeAttrValue *value_out);
# 18037 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphKernelNodeSetAttribute(CUgraphNode hNode, CUkernelNodeAttrID attr,
                                      const CUkernelNodeAttrValue *value);
# 18057 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphDebugDotPrint(CUgraph hGraph, const char *path, unsigned int flags);
# 18093 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuUserObjectCreate(CUuserObject *object_out, void *ptr, CUhostFn destroy,
                                    unsigned int initialRefcount, unsigned int flags);
# 18118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuUserObjectRetain(CUuserObject object, unsigned int count);
# 18146 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuUserObjectRelease(CUuserObject object, unsigned int count);
# 18174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphRetainUserObject(CUgraph graph, CUuserObject object, unsigned int count, unsigned int flags);
# 18199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphReleaseUserObject(CUgraph graph, CUuserObject object, unsigned int count);
# 18238 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessor(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize);
# 18280 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *numBlocks, CUfunction func, int blockSize, size_t dynamicSMemSize, unsigned int flags);
# 18332 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuOccupancyMaxPotentialBlockSize(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit);
# 18378 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuOccupancyMaxPotentialBlockSizeWithFlags(int *minGridSize, int *blockSize, CUfunction func, CUoccupancyB2DSize blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags);
# 18401 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuOccupancyAvailableDynamicSMemPerBlock(size_t *dynamicSmemSize, CUfunction func, int numBlocks, int blockSize);
# 18446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetArray(CUtexref hTexRef, CUarray hArray, unsigned int Flags);
# 18476 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetMipmappedArray(CUtexref hTexRef, CUmipmappedArray hMipmappedArray, unsigned int Flags);
# 18522 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetAddress_v2(size_t *ByteOffset, CUtexref hTexRef, CUdeviceptr dptr, size_t bytes);
# 18577 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetAddress2D_v3(CUtexref hTexRef, const CUDA_ARRAY_DESCRIPTOR *desc, CUdeviceptr dptr, size_t Pitch);
# 18612 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetFormat(CUtexref hTexRef, CUarray_format fmt, int NumPackedComponents);
# 18658 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetAddressMode(CUtexref hTexRef, int dim, CUaddress_mode am);
# 18694 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetFilterMode(CUtexref hTexRef, CUfilter_mode fm);
# 18730 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetMipmapFilterMode(CUtexref hTexRef, CUfilter_mode fm);
# 18759 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetMipmapLevelBias(CUtexref hTexRef, float bias);
# 18790 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetMipmapLevelClamp(CUtexref hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp);
# 18820 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetMaxAnisotropy(CUtexref hTexRef, unsigned int maxAniso);
# 18856 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetBorderColor(CUtexref hTexRef, float *pBorderColor);
# 18901 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefSetFlags(CUtexref hTexRef, unsigned int Flags);
# 18928 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetAddress_v2(CUdeviceptr *pdptr, CUtexref hTexRef);
# 18955 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetArray(CUarray *phArray, CUtexref hTexRef);
# 18982 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetMipmappedArray(CUmipmappedArray *phMipmappedArray, CUtexref hTexRef);
# 19010 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetAddressMode(CUaddress_mode *pam, CUtexref hTexRef, int dim);
# 19036 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);
# 19064 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetFormat(CUarray_format *pFormat, int *pNumChannels, CUtexref hTexRef);
# 19090 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetMipmapFilterMode(CUfilter_mode *pfm, CUtexref hTexRef);
# 19116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetMipmapLevelBias(float *pbias, CUtexref hTexRef);
# 19143 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetMipmapLevelClamp(float *pminMipmapLevelClamp, float *pmaxMipmapLevelClamp, CUtexref hTexRef);
# 19169 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetMaxAnisotropy(int *pmaxAniso, CUtexref hTexRef);
# 19198 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetBorderColor(float *pBorderColor, CUtexref hTexRef);
# 19223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefGetFlags(unsigned int *pFlags, CUtexref hTexRef);
# 19248 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefCreate(CUtexref *pTexRef);
# 19268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuTexRefDestroy(CUtexref hTexRef);
# 19312 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuSurfRefSetArray(CUsurfref hSurfRef, CUarray hArray, unsigned int Flags);
# 19335 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
__attribute__((deprecated)) CUresult cuSurfRefGetArray(CUarray *phArray, CUsurfref hSurfRef);
# 19575 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuTexObjectCreate(CUtexObject *pTexObject, const CUDA_RESOURCE_DESC *pResDesc, const CUDA_TEXTURE_DESC *pTexDesc, const CUDA_RESOURCE_VIEW_DESC *pResViewDesc);
# 19595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuTexObjectDestroy(CUtexObject texObject);
# 19616 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuTexObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUtexObject texObject);
# 19637 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuTexObjectGetTextureDesc(CUDA_TEXTURE_DESC *pTexDesc, CUtexObject texObject);
# 19659 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuTexObjectGetResourceViewDesc(CUDA_RESOURCE_VIEW_DESC *pResViewDesc, CUtexObject texObject);
# 19702 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuSurfObjectCreate(CUsurfObject *pSurfObject, const CUDA_RESOURCE_DESC *pResDesc);
# 19722 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuSurfObjectDestroy(CUsurfObject surfObject);
# 19743 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuSurfObjectGetResourceDesc(CUDA_RESOURCE_DESC *pResDesc, CUsurfObject surfObject);
# 19785 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceCanAccessPeer(int *canAccessPeer, CUdevice dev, CUdevice peerDev);
# 19838 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxEnablePeerAccess(CUcontext peerContext, unsigned int Flags);
# 19865 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuCtxDisablePeerAccess(CUcontext peerContext);
# 19905 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuDeviceGetP2PAttribute(int* value, CUdevice_P2PAttribute attrib, CUdevice srcDevice, CUdevice dstDevice);
# 19949 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsUnregisterResource(CUgraphicsResource resource);
# 19989 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsSubResourceGetMappedArray(CUarray *pArray, CUgraphicsResource resource, unsigned int arrayIndex, unsigned int mipLevel);
# 20020 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsResourceGetMappedMipmappedArray(CUmipmappedArray *pMipmappedArray, CUgraphicsResource resource);
# 20054 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsResourceGetMappedPointer_v2(CUdeviceptr *pDevPtr, size_t *pSize, CUgraphicsResource resource);
# 20095 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsResourceSetMapFlags_v2(CUgraphicsResource resource, unsigned int flags);
# 20135 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsMapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);
# 20172 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGraphicsUnmapResources(unsigned int count, CUgraphicsResource *resources, CUstream hStream);
# 20239 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuGetProcAddress(const char *symbol, void **pfn, int cudaVersion, cuuint64_t flags);
# 20249 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
typedef enum CUmoduleLoadingMode_enum {
    CU_MODULE_EAGER_LOADING = 0x1,
    CU_MODULE_LAZY_LOADING = 0x2,
} CUmoduleLoadingMode;
# 20270 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuModuleGetLoadingMode(CUmoduleLoadingMode *mode);
# 20305 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
CUresult cuMemGetHandleForAddressRange(void *handle, CUdeviceptr dptr, size_t size, CUmemRangeHandleType handleType, unsigned long long flags);


CUresult cuGetExportTable(const void **ppExportTable, const CUuuid *pExportTableId);
# 20681 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/cuda.h"
}
# 20 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/driver_types.h" 1
# 21 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix.h" 1
# 41 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix.h"
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_device.h" 1
# 43 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_device.h"
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h" 1
# 39 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h" 1
# 37 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 38 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h" 2
# 50 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef unsigned long long CUdeviceptr;






typedef struct OptixDeviceContext_t* OptixDeviceContext;


typedef struct OptixModule_t* OptixModule;


typedef struct OptixProgramGroup_t* OptixProgramGroup;


typedef struct OptixPipeline_t* OptixPipeline;


typedef struct OptixDenoiser_t* OptixDenoiser;


typedef unsigned long long OptixTraversableHandle;


typedef unsigned int OptixVisibilityMask;
# 109 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef enum OptixResult
{
    OPTIX_SUCCESS = 0,
    OPTIX_ERROR_INVALID_VALUE = 7001,
    OPTIX_ERROR_HOST_OUT_OF_MEMORY = 7002,
    OPTIX_ERROR_INVALID_OPERATION = 7003,
    OPTIX_ERROR_FILE_IO_ERROR = 7004,
    OPTIX_ERROR_INVALID_FILE_FORMAT = 7005,
    OPTIX_ERROR_DISK_CACHE_INVALID_PATH = 7010,
    OPTIX_ERROR_DISK_CACHE_PERMISSION_ERROR = 7011,
    OPTIX_ERROR_DISK_CACHE_DATABASE_ERROR = 7012,
    OPTIX_ERROR_DISK_CACHE_INVALID_DATA = 7013,
    OPTIX_ERROR_LAUNCH_FAILURE = 7050,
    OPTIX_ERROR_INVALID_DEVICE_CONTEXT = 7051,
    OPTIX_ERROR_CUDA_NOT_INITIALIZED = 7052,
    OPTIX_ERROR_VALIDATION_FAILURE = 7053,
    OPTIX_ERROR_INVALID_PTX = 7200,
    OPTIX_ERROR_INVALID_LAUNCH_PARAMETER = 7201,
    OPTIX_ERROR_INVALID_PAYLOAD_ACCESS = 7202,
    OPTIX_ERROR_INVALID_ATTRIBUTE_ACCESS = 7203,
    OPTIX_ERROR_INVALID_FUNCTION_USE = 7204,
    OPTIX_ERROR_INVALID_FUNCTION_ARGUMENTS = 7205,
    OPTIX_ERROR_PIPELINE_OUT_OF_CONSTANT_MEMORY = 7250,
    OPTIX_ERROR_PIPELINE_LINK_ERROR = 7251,
    OPTIX_ERROR_INTERNAL_COMPILER_ERROR = 7299,
    OPTIX_ERROR_DENOISER_MODEL_NOT_SET = 7300,
    OPTIX_ERROR_DENOISER_NOT_INITIALIZED = 7301,
    OPTIX_ERROR_ACCEL_NOT_COMPATIBLE = 7400,
    OPTIX_ERROR_NOT_SUPPORTED = 7800,
    OPTIX_ERROR_UNSUPPORTED_ABI_VERSION = 7801,
    OPTIX_ERROR_FUNCTION_TABLE_SIZE_MISMATCH = 7802,
    OPTIX_ERROR_INVALID_ENTRY_FUNCTION_OPTIONS = 7803,
    OPTIX_ERROR_LIBRARY_NOT_FOUND = 7804,
    OPTIX_ERROR_ENTRY_SYMBOL_NOT_FOUND = 7805,
    OPTIX_ERROR_LIBRARY_UNLOAD_FAILURE = 7806,
    OPTIX_ERROR_CUDA_ERROR = 7900,
    OPTIX_ERROR_INTERNAL_ERROR = 7990,
    OPTIX_ERROR_UNKNOWN = 7999,
} OptixResult;




typedef enum OptixDeviceProperty
{

    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_TRACE_DEPTH = 0x2001,



    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_TRAVERSABLE_GRAPH_DEPTH = 0x2002,



    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_PRIMITIVES_PER_GAS = 0x2003,



    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCES_PER_IAS = 0x2004,



    OPTIX_DEVICE_PROPERTY_RTCORE_VERSION = 0x2005,


    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_INSTANCE_ID = 0x2006,



    OPTIX_DEVICE_PROPERTY_LIMIT_NUM_BITS_INSTANCE_VISIBILITY_MASK = 0x2007,



    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_SBT_RECORDS_PER_GAS = 0x2008,


    OPTIX_DEVICE_PROPERTY_LIMIT_MAX_SBT_OFFSET = 0x2009,
} OptixDeviceProperty;
# 212 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef void ( *OptixLogCallback )( unsigned int level, const char* tag, const char* message, void* cbdata );
# 221 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef enum OptixDeviceContextValidationMode
{
    OPTIX_DEVICE_CONTEXT_VALIDATION_MODE_OFF = 0,
    OPTIX_DEVICE_CONTEXT_VALIDATION_MODE_ALL = 0xFFFFFFFF
} OptixDeviceContextValidationMode;




typedef struct OptixDeviceContextOptions
{

    OptixLogCallback logCallbackFunction;

    void* logCallbackData;

    int logCallbackLevel;

    OptixDeviceContextValidationMode validationMode;
} OptixDeviceContextOptions;




typedef enum OptixGeometryFlags
{

    OPTIX_GEOMETRY_FLAG_NONE = 0,



    OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT = 1u << 0,




    OPTIX_GEOMETRY_FLAG_REQUIRE_SINGLE_ANYHIT_CALL = 1u << 1
} OptixGeometryFlags;






typedef enum OptixHitKind
{

    OPTIX_HIT_KIND_TRIANGLE_FRONT_FACE = 0xFE,

    OPTIX_HIT_KIND_TRIANGLE_BACK_FACE = 0xFF
} OptixHitKind;


typedef enum OptixIndicesFormat
{

    OPTIX_INDICES_FORMAT_NONE = 0,

    OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3 = 0x2102,

    OPTIX_INDICES_FORMAT_UNSIGNED_INT3 = 0x2103
} OptixIndicesFormat;


typedef enum OptixVertexFormat
{
    OPTIX_VERTEX_FORMAT_NONE = 0,
    OPTIX_VERTEX_FORMAT_FLOAT3 = 0x2121,
    OPTIX_VERTEX_FORMAT_FLOAT2 = 0x2122,
    OPTIX_VERTEX_FORMAT_HALF3 = 0x2123,
    OPTIX_VERTEX_FORMAT_HALF2 = 0x2124,
    OPTIX_VERTEX_FORMAT_SNORM16_3 = 0x2125,
    OPTIX_VERTEX_FORMAT_SNORM16_2 = 0x2126
} OptixVertexFormat;


typedef enum OptixTransformFormat
{
    OPTIX_TRANSFORM_FORMAT_NONE = 0,
    OPTIX_TRANSFORM_FORMAT_MATRIX_FLOAT12 = 0x21E1,
} OptixTransformFormat;




typedef struct OptixBuildInputTriangleArray
{







    const CUdeviceptr* vertexBuffers;


    unsigned int numVertices;


    OptixVertexFormat vertexFormat;



    unsigned int vertexStrideInBytes;




    CUdeviceptr indexBuffer;


    unsigned int numIndexTriplets;


    OptixIndicesFormat indexFormat;



    unsigned int indexStrideInBytes;




    CUdeviceptr preTransform;




    const unsigned int* flags;


    unsigned int numSbtRecords;




    CUdeviceptr sbtIndexOffsetBuffer;


    unsigned int sbtIndexOffsetSizeInBytes;



    unsigned int sbtIndexOffsetStrideInBytes;



    unsigned int primitiveIndexOffset;


    OptixTransformFormat transformFormat;
} OptixBuildInputTriangleArray;



typedef enum OptixPrimitiveType
{

    OPTIX_PRIMITIVE_TYPE_CUSTOM = 0x2500,

    OPTIX_PRIMITIVE_TYPE_ROUND_QUADRATIC_BSPLINE = 0x2501,

    OPTIX_PRIMITIVE_TYPE_ROUND_CUBIC_BSPLINE = 0x2502,

    OPTIX_PRIMITIVE_TYPE_ROUND_LINEAR = 0x2503,

    OPTIX_PRIMITIVE_TYPE_TRIANGLE = 0x2531,
} OptixPrimitiveType;




typedef enum OptixPrimitiveTypeFlags
{

    OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM = 1 << 0,

    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_QUADRATIC_BSPLINE = 1 << 1,

    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_CUBIC_BSPLINE = 1 << 2,

    OPTIX_PRIMITIVE_TYPE_FLAGS_ROUND_LINEAR = 1 << 3,

    OPTIX_PRIMITIVE_TYPE_FLAGS_TRIANGLE = 1 << 31,
} OptixPrimitiveTypeFlags;
# 425 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef struct OptixBuildInputCurveArray
{


    OptixPrimitiveType curveType;

    unsigned int numPrimitives;





    const CUdeviceptr* vertexBuffers;

    unsigned int numVertices;


    unsigned int vertexStrideInBytes;



    const CUdeviceptr* widthBuffers;


    unsigned int widthStrideInBytes;


    const CUdeviceptr* normalBuffers;

    unsigned int normalStrideInBytes;






    CUdeviceptr indexBuffer;


    unsigned int indexStrideInBytes;



    unsigned int flag;



    unsigned int primitiveIndexOffset;
} OptixBuildInputCurveArray;


typedef struct OptixAabb
{
    float minX;
    float minY;
    float minZ;
    float maxX;
    float maxY;
    float maxZ;
} OptixAabb;




typedef struct OptixBuildInputCustomPrimitiveArray
{




    const CUdeviceptr* aabbBuffers;



    unsigned int numPrimitives;




    unsigned int strideInBytes;




    const unsigned int* flags;


    unsigned int numSbtRecords;




    CUdeviceptr sbtIndexOffsetBuffer;


    unsigned int sbtIndexOffsetSizeInBytes;



    unsigned int sbtIndexOffsetStrideInBytes;



    unsigned int primitiveIndexOffset;
} OptixBuildInputCustomPrimitiveArray;




typedef struct OptixBuildInputInstanceArray
{







    CUdeviceptr instances;


    unsigned int numInstances;
} OptixBuildInputInstanceArray;




typedef enum OptixBuildInputType
{

    OPTIX_BUILD_INPUT_TYPE_TRIANGLES = 0x2141,

    OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES = 0x2142,

    OPTIX_BUILD_INPUT_TYPE_INSTANCES = 0x2143,

    OPTIX_BUILD_INPUT_TYPE_INSTANCE_POINTERS = 0x2144,

    OPTIX_BUILD_INPUT_TYPE_CURVES = 0x2145
} OptixBuildInputType;






typedef struct OptixBuildInput
{

    OptixBuildInputType type;

    union
    {

        OptixBuildInputTriangleArray triangleArray;

        OptixBuildInputCurveArray curveArray;

        OptixBuildInputCustomPrimitiveArray customPrimitiveArray;

        OptixBuildInputInstanceArray instanceArray;
        char pad[1024];
    };
} OptixBuildInput;







static_assert( sizeof( OptixBuildInput ) == 8 + 1024, "OptixBuildInput has wrong size" );





typedef enum OptixInstanceFlags
{

    OPTIX_INSTANCE_FLAG_NONE = 0,




    OPTIX_INSTANCE_FLAG_DISABLE_TRIANGLE_FACE_CULLING = 1u << 0,



    OPTIX_INSTANCE_FLAG_FLIP_TRIANGLE_FACING = 1u << 1,




    OPTIX_INSTANCE_FLAG_DISABLE_ANYHIT = 1u << 2,





    OPTIX_INSTANCE_FLAG_ENFORCE_ANYHIT = 1u << 3,


    OPTIX_INSTANCE_FLAG_DISABLE_TRANSFORM = 1u << 6,
} OptixInstanceFlags;




typedef struct OptixInstance
{

    float transform[12];


    unsigned int instanceId;




    unsigned int sbtOffset;



    unsigned int visibilityMask;


    unsigned int flags;


    OptixTraversableHandle traversableHandle;


    unsigned int pad[2];
} OptixInstance;




typedef enum OptixBuildFlags
{

    OPTIX_BUILD_FLAG_NONE = 0,



    OPTIX_BUILD_FLAG_ALLOW_UPDATE = 1u << 0,

    OPTIX_BUILD_FLAG_ALLOW_COMPACTION = 1u << 1,

    OPTIX_BUILD_FLAG_PREFER_FAST_TRACE = 1u << 2,

    OPTIX_BUILD_FLAG_PREFER_FAST_BUILD = 1u << 3,


    OPTIX_BUILD_FLAG_ALLOW_RANDOM_VERTEX_ACCESS = 1u << 4,
} OptixBuildFlags;
# 694 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef enum OptixBuildOperation
{

    OPTIX_BUILD_OPERATION_BUILD = 0x2161,

    OPTIX_BUILD_OPERATION_UPDATE = 0x2162,
} OptixBuildOperation;




typedef enum OptixMotionFlags
{
    OPTIX_MOTION_FLAG_NONE = 0,
    OPTIX_MOTION_FLAG_START_VANISH = 1u << 0,
    OPTIX_MOTION_FLAG_END_VANISH = 1u << 1
} OptixMotionFlags;





typedef struct OptixMotionOptions
{


    unsigned short numKeys;


    unsigned short flags;


    float timeBegin;


    float timeEnd;
} OptixMotionOptions;




typedef struct OptixAccelBuildOptions
{

    unsigned int buildFlags;





    OptixBuildOperation operation;


    OptixMotionOptions motionOptions;
} OptixAccelBuildOptions;






typedef struct OptixAccelBufferSizes
{


    size_t outputSizeInBytes;



    size_t tempSizeInBytes;





    size_t tempUpdateSizeInBytes;
} OptixAccelBufferSizes;




typedef enum OptixAccelPropertyType
{

    OPTIX_PROPERTY_TYPE_COMPACTED_SIZE = 0x2181,


    OPTIX_PROPERTY_TYPE_AABBS = 0x2182,
} OptixAccelPropertyType;




typedef struct OptixAccelEmitDesc
{

    CUdeviceptr result;


    OptixAccelPropertyType type;
} OptixAccelEmitDesc;




typedef struct OptixAccelRelocationInfo
{

    unsigned long long info[4];
} OptixAccelRelocationInfo;






typedef struct OptixStaticTransform
{

    OptixTraversableHandle child;


    unsigned int pad[2];


    float transform[12];



    float invTransform[12];
} OptixStaticTransform;
# 850 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef struct OptixMatrixMotionTransform
{

    OptixTraversableHandle child;


    OptixMotionOptions motionOptions;


    unsigned int pad[3];


    float transform[2][12];
} OptixMatrixMotionTransform;
# 891 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef struct OptixSRTData
{


    float sx, a, b, pvx, sy, c, pvy, sz, pvz, qx, qy, qz, qw, tx, ty, tz;

} OptixSRTData;



static_assert( sizeof( OptixSRTData ) == 16 * 4, "OptixSRTData has wrong size" );
# 928 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef struct OptixSRTMotionTransform
{

    OptixTraversableHandle child;


    OptixMotionOptions motionOptions;


    unsigned int pad[3];


    OptixSRTData srtData[2];
} OptixSRTMotionTransform;



static_assert( sizeof( OptixSRTMotionTransform ) == 8 + 12 + 12 + 2 * 16 * 4, "OptixSRTMotionTransform has wrong size" );





typedef enum OptixTraversableType
{

    OPTIX_TRAVERSABLE_TYPE_STATIC_TRANSFORM = 0x21C1,

    OPTIX_TRAVERSABLE_TYPE_MATRIX_MOTION_TRANSFORM = 0x21C2,

    OPTIX_TRAVERSABLE_TYPE_SRT_MOTION_TRANSFORM = 0x21C3,
} OptixTraversableType;




typedef enum OptixPixelFormat
{
    OPTIX_PIXEL_FORMAT_HALF3 = 0x2201,
    OPTIX_PIXEL_FORMAT_HALF4 = 0x2202,
    OPTIX_PIXEL_FORMAT_FLOAT3 = 0x2203,
    OPTIX_PIXEL_FORMAT_FLOAT4 = 0x2204,
    OPTIX_PIXEL_FORMAT_UCHAR3 = 0x2205,
    OPTIX_PIXEL_FORMAT_UCHAR4 = 0x2206
} OptixPixelFormat;




typedef struct OptixImage2D
{

    CUdeviceptr data;

    unsigned int width;

    unsigned int height;

    unsigned int rowStrideInBytes;


    unsigned int pixelStrideInBytes;

    OptixPixelFormat format;
} OptixImage2D;







typedef enum OptixDenoiserInputKind
{
    OPTIX_DENOISER_INPUT_RGB = 0x2301,
    OPTIX_DENOISER_INPUT_RGB_ALBEDO = 0x2302,
    OPTIX_DENOISER_INPUT_RGB_ALBEDO_NORMAL = 0x2303,
} OptixDenoiserInputKind;




typedef enum OptixDenoiserModelKind
{


    OPTIX_DENOISER_MODEL_KIND_USER = 0x2321,


    OPTIX_DENOISER_MODEL_KIND_LDR = 0x2322,


    OPTIX_DENOISER_MODEL_KIND_HDR = 0x2323,


    OPTIX_DENOISER_MODEL_KIND_AOV = 0x2324,

} OptixDenoiserModelKind;




typedef struct OptixDenoiserOptions
{

    OptixDenoiserInputKind inputKind;
} OptixDenoiserOptions;






typedef struct OptixDenoiserParams
{

    unsigned int denoiseAlpha;




    CUdeviceptr hdrIntensity;





    float blendFactor;





    CUdeviceptr hdrAverageColor;
} OptixDenoiserParams;




typedef struct OptixDenoiserSizes
{
    size_t stateSizeInBytes;
    size_t withOverlapScratchSizeInBytes;
    size_t withoutOverlapScratchSizeInBytes;
    unsigned int overlapWindowSizeInPixels;
} OptixDenoiserSizes;





typedef enum OptixRayFlags
{

    OPTIX_RAY_FLAG_NONE = 0u,





    OPTIX_RAY_FLAG_DISABLE_ANYHIT = 1u << 0,





    OPTIX_RAY_FLAG_ENFORCE_ANYHIT = 1u << 1,



    OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT = 1u << 2,


    OPTIX_RAY_FLAG_DISABLE_CLOSESTHIT = 1u << 3,





    OPTIX_RAY_FLAG_CULL_BACK_FACING_TRIANGLES = 1u << 4,





    OPTIX_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES = 1u << 5,






    OPTIX_RAY_FLAG_CULL_DISABLED_ANYHIT = 1u << 6,






    OPTIX_RAY_FLAG_CULL_ENFORCED_ANYHIT = 1u << 7
} OptixRayFlags;






typedef enum OptixTransformType
{
    OPTIX_TRANSFORM_TYPE_NONE = 0,
    OPTIX_TRANSFORM_TYPE_STATIC_TRANSFORM = 1,
    OPTIX_TRANSFORM_TYPE_MATRIX_MOTION_TRANSFORM = 2,
    OPTIX_TRANSFORM_TYPE_SRT_MOTION_TRANSFORM = 3,
    OPTIX_TRANSFORM_TYPE_INSTANCE = 4,
} OptixTransformType;



typedef enum OptixTraversableGraphFlags
{


    OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_ANY = 0,




    OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS = 1u << 0,





    OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_LEVEL_INSTANCING = 1u << 1,
} OptixTraversableGraphFlags;




typedef enum OptixCompileOptimizationLevel
{

    OPTIX_COMPILE_OPTIMIZATION_DEFAULT = 0,

    OPTIX_COMPILE_OPTIMIZATION_LEVEL_0 = 0x2340,

    OPTIX_COMPILE_OPTIMIZATION_LEVEL_1 = 0x2341,

    OPTIX_COMPILE_OPTIMIZATION_LEVEL_2 = 0x2342,

    OPTIX_COMPILE_OPTIMIZATION_LEVEL_3 = 0x2343,
} OptixCompileOptimizationLevel;




typedef enum OptixCompileDebugLevel
{

    OPTIX_COMPILE_DEBUG_LEVEL_DEFAULT = 0,

    OPTIX_COMPILE_DEBUG_LEVEL_NONE = 0x2350,

    OPTIX_COMPILE_DEBUG_LEVEL_LINEINFO = 0x2351,

    OPTIX_COMPILE_DEBUG_LEVEL_FULL = 0x2352,
} OptixCompileDebugLevel;
# 1229 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
typedef struct OptixModuleCompileBoundValueEntry {
    size_t pipelineParamOffsetInBytes;
    size_t sizeInBytes;
    const void* boundValuePtr;
    const char* annotation;

} OptixModuleCompileBoundValueEntry;





typedef struct OptixModuleCompileOptions
{


    int maxRegisterCount;


    OptixCompileOptimizationLevel optLevel;


    OptixCompileDebugLevel debugLevel;


    const OptixModuleCompileBoundValueEntry* boundValues;


    unsigned int numBoundValues;

} OptixModuleCompileOptions;


typedef enum OptixProgramGroupKind
{


    OPTIX_PROGRAM_GROUP_KIND_RAYGEN = 0x2421,



    OPTIX_PROGRAM_GROUP_KIND_MISS = 0x2422,



    OPTIX_PROGRAM_GROUP_KIND_EXCEPTION = 0x2423,



    OPTIX_PROGRAM_GROUP_KIND_HITGROUP = 0x2424,



    OPTIX_PROGRAM_GROUP_KIND_CALLABLES = 0x2425
} OptixProgramGroupKind;


typedef enum OptixProgramGroupFlags
{

    OPTIX_PROGRAM_GROUP_FLAGS_NONE = 0
} OptixProgramGroupFlags;







typedef struct OptixProgramGroupSingleModule
{

    OptixModule module;

    const char* entryFunctionName;
} OptixProgramGroupSingleModule;






typedef struct OptixProgramGroupHitgroup
{

    OptixModule moduleCH;

    const char* entryFunctionNameCH;

    OptixModule moduleAH;

    const char* entryFunctionNameAH;

    OptixModule moduleIS;

    const char* entryFunctionNameIS;
} OptixProgramGroupHitgroup;






typedef struct OptixProgramGroupCallables
{

    OptixModule moduleDC;

    const char* entryFunctionNameDC;

    OptixModule moduleCC;

    const char* entryFunctionNameCC;
} OptixProgramGroupCallables;


typedef struct OptixProgramGroupDesc
{

    OptixProgramGroupKind kind;


    unsigned int flags;

    union
    {

        OptixProgramGroupSingleModule raygen;

        OptixProgramGroupSingleModule miss;

        OptixProgramGroupSingleModule exception;

        OptixProgramGroupCallables callables;

        OptixProgramGroupHitgroup hitgroup;
    };
} OptixProgramGroupDesc;




typedef struct OptixProgramGroupOptions
{

    int placeholder;
} OptixProgramGroupOptions;


typedef enum OptixExceptionCodes
{


    OPTIX_EXCEPTION_CODE_STACK_OVERFLOW = -1,



    OPTIX_EXCEPTION_CODE_TRACE_DEPTH_EXCEEDED = -2,





    OPTIX_EXCEPTION_CODE_TRAVERSAL_DEPTH_EXCEEDED = -3,






    OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_TRAVERSABLE = -5,





    OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_MISS_SBT = -6,
# 1423 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_types.h"
    OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_HIT_SBT = -7,



    OPTIX_EXCEPTION_CODE_UNSUPPORTED_PRIMITIVE_TYPE = -8,





    OPTIX_EXCEPTION_CODE_INVALID_RAY = -9,






    OPTIX_EXCEPTION_CODE_CALLABLE_PARAMETER_MISMATCH = -10,


    OPTIX_EXCEPTION_CODE_BUILTIN_IS_MISMATCH = -11,





    OPTIX_EXCEPTION_CODE_CALLABLE_INVALID_SBT = -12,



    OPTIX_EXCEPTION_CODE_CALLABLE_NO_DC_SBT_RECORD = -13,



    OPTIX_EXCEPTION_CODE_CALLABLE_NO_CC_SBT_RECORD = -14,







    OPTIX_EXCEPTION_CODE_UNSUPPORTED_SINGLE_LEVEL_GAS = -15,
} OptixExceptionCodes;




typedef enum OptixExceptionFlags
{

    OPTIX_EXCEPTION_FLAG_NONE = 0,


    OPTIX_EXCEPTION_FLAG_STACK_OVERFLOW = 1u << 0,


    OPTIX_EXCEPTION_FLAG_TRACE_DEPTH = 1u << 1,



    OPTIX_EXCEPTION_FLAG_USER = 1u << 2,


    OPTIX_EXCEPTION_FLAG_DEBUG = 1u << 3
} OptixExceptionFlags;






typedef struct OptixPipelineCompileOptions
{

    int usesMotionBlur;


    unsigned int traversableGraphFlags;


    int numPayloadValues;



    int numAttributeValues;


    unsigned int exceptionFlags;




    const char* pipelineLaunchParamsVariableName;



    unsigned int usesPrimitiveTypeFlags;
} OptixPipelineCompileOptions;




typedef struct OptixPipelineLinkOptions
{


    unsigned int maxTraceDepth;


    OptixCompileDebugLevel debugLevel;
} OptixPipelineLinkOptions;




typedef struct OptixShaderBindingTable
{


    CUdeviceptr raygenRecord;



    CUdeviceptr exceptionRecord;




    CUdeviceptr missRecordBase;
    unsigned int missRecordStrideInBytes;
    unsigned int missRecordCount;





    CUdeviceptr hitgroupRecordBase;
    unsigned int hitgroupRecordStrideInBytes;
    unsigned int hitgroupRecordCount;






    CUdeviceptr callablesRecordBase;
    unsigned int callablesRecordStrideInBytes;
    unsigned int callablesRecordCount;


} OptixShaderBindingTable;




typedef struct OptixStackSizes
{

    unsigned int cssRG;

    unsigned int cssMS;

    unsigned int cssCH;

    unsigned int cssAH;

    unsigned int cssIS;

    unsigned int cssCC;

    unsigned int dssDC;

} OptixStackSizes;


typedef enum OptixQueryFunctionTableOptions
{

    OPTIX_QUERY_FUNCTION_TABLE_OPTION_DUMMY = 0

} OptixQueryFunctionTableOptions;


typedef OptixResult( OptixQueryFunctionTable_t )( int abiId,
                                                  unsigned int numOptions,
                                                  OptixQueryFunctionTableOptions* ,
                                                  const void** ,
                                                  void* functionTable,
                                                  size_t sizeOfTable );





typedef struct OptixBuiltinISOptions
{
    OptixPrimitiveType builtinISModuleType;
    int usesMotionBlur;
} OptixBuiltinISOptions;






typedef struct OptixInvalidRayExceptionDetails
{
    float3 origin;
    float3 direction;
    float tmin;
    float tmax;
    float time;
} OptixInvalidRayExceptionDetails;







typedef struct OptixParameterMismatchExceptionDetails
{

    unsigned int expectedParameterCount;

    unsigned int passedArgumentCount;

    unsigned int sbtIndex;

    char* callableName;
} OptixParameterMismatchExceptionDetails;
# 40 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h" 2
# 61 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4,
                                                   unsigned int& p5 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4,
                                                   unsigned int& p5,
                                                   unsigned int& p6 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4,
                                                   unsigned int& p5,
                                                   unsigned int& p6,
                                                   unsigned int& p7 );


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_0( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_1( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_2( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_3( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_4( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_5( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_6( unsigned int p );

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_7( unsigned int p );


static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_0();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_1();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_2();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_3();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_4();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_5();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_6();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_7();


static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixUndefinedValue();






static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetWorldRayOrigin();






static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetWorldRayDirection();




static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetObjectRayOrigin();




static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetObjectRayDirection();




static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetRayTmin();





static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetRayTmax();





static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetRayTime();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetRayFlags();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetRayVisibilityMask();






static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetTriangleVertexData( OptixTraversableHandle gas, unsigned int primIdx, unsigned int sbtGASIndex, float time, float3 data[3]);







static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetLinearCurveVertexData( OptixTraversableHandle gas, unsigned int primIdx, unsigned int sbtGASIndex, float time, float4 data[2] );







static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetQuadraticBSplineVertexData( OptixTraversableHandle gas, unsigned int primIdx, unsigned int sbtGASIndex, float time, float4 data[3] );







static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetCubicBSplineVertexData( OptixTraversableHandle gas, unsigned int primIdx, unsigned int sbtGASIndex, float time, float4 data[4] );



static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTraversableHandle optixGetGASTraversableHandle();


static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetGASMotionTimeBegin( OptixTraversableHandle gas );


static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetGASMotionTimeEnd( OptixTraversableHandle gas );


static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetGASMotionStepCount( OptixTraversableHandle gas );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetWorldToObjectTransformMatrix( float m[12] );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetObjectToWorldTransformMatrix( float m[12] );





static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformPointFromWorldToObjectSpace( float3 point );





static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformVectorFromWorldToObjectSpace( float3 vec );





static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformNormalFromWorldToObjectSpace( float3 normal );





static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformPointFromObjectToWorldSpace( float3 point );





static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformVectorFromObjectToWorldSpace( float3 vec );





static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformNormalFromObjectToWorldSpace( float3 normal );




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetTransformListSize();




static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTraversableHandle optixGetTransformListHandle( unsigned int index );



static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTransformType optixGetTransformTypeFromHandle( OptixTraversableHandle handle );




static __inline__ __attribute__((always_inline)) __attribute__((device)) const OptixStaticTransform* optixGetStaticTransformFromHandle( OptixTraversableHandle handle );




static __inline__ __attribute__((always_inline)) __attribute__((device)) const OptixSRTMotionTransform* optixGetSRTMotionTransformFromHandle( OptixTraversableHandle handle );




static __inline__ __attribute__((always_inline)) __attribute__((device)) const OptixMatrixMotionTransform* optixGetMatrixMotionTransformFromHandle( OptixTraversableHandle handle );




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetInstanceIdFromHandle( OptixTraversableHandle handle );




static __inline__ __attribute__((always_inline)) __attribute__((device)) const float4* optixGetInstanceTransformFromHandle( OptixTraversableHandle handle );




static __inline__ __attribute__((always_inline)) __attribute__((device)) const float4* optixGetInstanceInverseTransformFromHandle( OptixTraversableHandle handle );
# 467 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind, unsigned int a0 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind, unsigned int a0, unsigned int a1 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind, unsigned int a0, unsigned int a1, unsigned int a2 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4,
                                                                unsigned int a5 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4,
                                                                unsigned int a5,
                                                                unsigned int a6 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4,
                                                                unsigned int a5,
                                                                unsigned int a6,
                                                                unsigned int a7 );


static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_0();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_1();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_2();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_3();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_4();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_5();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_6();

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_7();




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTerminateRay();




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixIgnoreIntersection();
# 583 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPrimitiveIndex();






static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetSbtGASIndex();
# 600 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetInstanceId();






static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetInstanceIndex();
# 617 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetHitKind();


static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixPrimitiveType optixGetPrimitiveType( unsigned int hitKind );


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsFrontFaceHit( unsigned int hitKind );


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsBackFaceHit( unsigned int hitKind );


static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixPrimitiveType optixGetPrimitiveType();


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsFrontFaceHit();


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsBackFaceHit();


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsTriangleHit();


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsTriangleFrontFaceHit();


static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsTriangleBackFaceHit();





static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 optixGetTriangleBarycentrics();





static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetCurveParameter();




static __inline__ __attribute__((always_inline)) __attribute__((device)) uint3 optixGetLaunchIndex();


static __inline__ __attribute__((always_inline)) __attribute__((device)) uint3 optixGetLaunchDimensions();


static __inline__ __attribute__((always_inline)) __attribute__((device)) CUdeviceptr optixGetSbtDataPointer();
# 680 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1,
                                                            unsigned int exceptionDetail2 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1,
                                                            unsigned int exceptionDetail2,
                                                            unsigned int exceptionDetail3 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1,
                                                            unsigned int exceptionDetail2,
                                                            unsigned int exceptionDetail3,
                                                            unsigned int exceptionDetail4 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1,
                                                            unsigned int exceptionDetail2,
                                                            unsigned int exceptionDetail3,
                                                            unsigned int exceptionDetail4,
                                                            unsigned int exceptionDetail5 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1,
                                                            unsigned int exceptionDetail2,
                                                            unsigned int exceptionDetail3,
                                                            unsigned int exceptionDetail4,
                                                            unsigned int exceptionDetail5,
                                                            unsigned int exceptionDetail6 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode,
                                                            unsigned int exceptionDetail0,
                                                            unsigned int exceptionDetail1,
                                                            unsigned int exceptionDetail2,
                                                            unsigned int exceptionDetail3,
                                                            unsigned int exceptionDetail4,
                                                            unsigned int exceptionDetail5,
                                                            unsigned int exceptionDetail6,
                                                            unsigned int exceptionDetail7 );




static __inline__ __attribute__((always_inline)) __attribute__((device)) int optixGetExceptionCode();







static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_0();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_1();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_2();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_3();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_4();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_5();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_6();




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_7();






static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTraversableHandle optixGetExceptionInvalidTraversable();






static __inline__ __attribute__((always_inline)) __attribute__((device)) int optixGetExceptionInvalidSbtOffset();
# 827 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixInvalidRayExceptionDetails optixGetExceptionInvalidRay();
# 841 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixParameterMismatchExceptionDetails optixGetExceptionParameterMismatch();
# 853 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) char* optixGetExceptionLineInfo();
# 869 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
template <typename ReturnT, typename... ArgTypes>
static __inline__ __attribute__((always_inline)) __attribute__((device)) ReturnT optixDirectCall( unsigned int sbtIndex, ArgTypes... args );
# 888 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h"
template <typename ReturnT, typename... ArgTypes>
static __inline__ __attribute__((always_inline)) __attribute__((device)) ReturnT optixContinuationCall( unsigned int sbtIndex, ArgTypes... args );



# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl.h" 1
# 36 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl.h"
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl_exception.h" 1
# 37 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl_exception.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
# 96 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3

# 96 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 38 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl_exception.h" 2



# 40 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl_exception.h"
namespace optix_impl {

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpStaticTransformFromHandle( OptixTraversableHandle handle )
    {
        const OptixStaticTransform* traversable = optixGetStaticTransformFromHandle( handle );
        if( traversable )
        {
            const uint3 index = optixGetLaunchIndex();
            printf( "(%4i,%4i,%4i)     OptixStaticTransform@%p = {\n"
                    "                       child        = %p,\n"
                    "                       transform    = { %f,%f,%f,%f,\n"
                    "                                        %f,%f,%f,%f,\n"
                    "                                        %f,%f,%f,%f } }\n",
                index.x,index.y,index.z,
                traversable,
                (void*)traversable->child,
                traversable->transform[0], traversable->transform[1], traversable->transform[2], traversable->transform[3],
                traversable->transform[4], traversable->transform[5], traversable->transform[6], traversable->transform[7],
                traversable->transform[8], traversable->transform[9], traversable->transform[10], traversable->transform[11] );
        }
    }

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpMotionMatrixTransformFromHandle( OptixTraversableHandle handle )
    {
        const OptixMatrixMotionTransform* traversable = optixGetMatrixMotionTransformFromHandle( handle );
        if( traversable )
        {
            const uint3 index = optixGetLaunchIndex();
            printf( "(%4i,%4i,%4i)     OptixMatrixMotionTransform@%p = {\n"
                    "                       child         = %p,\n"
                    "                       motionOptions = { numKeys = %i, flags = %i, timeBegin = %f, timeEnd = %f },\n"
                    "                       transform     = { { %f,%f,%f,%f,\n"
                    "                                           %f,%f,%f,%f,\n"
                    "                                           %f,%f,%f,%f }, ... }\n",
                index.x,index.y,index.z,
                traversable,
                (void*)traversable->child,
                (int)traversable->motionOptions.numKeys, (int)traversable->motionOptions.flags, traversable->motionOptions.timeBegin, traversable->motionOptions.timeEnd,
                traversable->transform[0][0], traversable->transform[0][1], traversable->transform[0][2], traversable->transform[0][3],
                traversable->transform[0][4], traversable->transform[0][5], traversable->transform[0][6], traversable->transform[0][7],
                traversable->transform[0][8], traversable->transform[0][9], traversable->transform[0][10], traversable->transform[0][11] );
        }
    }

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpSrtMatrixTransformFromHandle( OptixTraversableHandle handle )
    {
        const OptixSRTMotionTransform* traversable = optixGetSRTMotionTransformFromHandle( handle );
        if( traversable )
        {
            const uint3 index = optixGetLaunchIndex();
            printf( "(%4i,%4i,%4i)     OptixSRTMotionTransform@%p = {\n"
                    "                       child         = %p,\n"
                    "                       motionOptions = { numKeys = %i, flags = %i, timeBegin = %f, timeEnd = %f },\n"
                    "                       srtData       = { { sx  = %f,  a = %f,   b = %f, pvx = %f,\n"
                    "                                           sy  = %f,  c = %f, pvy = %f,  sz = %f,\n"
                    "                                           pvz = %f, qx = %f,  qy = %f,  qz = %f,\n"
                    "                                           qw  = %f, tx = %f,  ty = %f,  tz = %f }, ... }\n",
                index.x,index.y,index.z,
                traversable,
                (void*)traversable->child,
                (int)traversable->motionOptions.numKeys, (int)traversable->motionOptions.flags, traversable->motionOptions.timeBegin, traversable->motionOptions.timeEnd,
                traversable->srtData[0].sx, traversable->srtData[0].a, traversable->srtData[0].b, traversable->srtData[0].pvx,
                traversable->srtData[0].sy, traversable->srtData[0].c, traversable->srtData[0].pvy,traversable->srtData[0].sz,
                traversable->srtData[0].pvz,traversable->srtData[0].qx,traversable->srtData[0].qy, traversable->srtData[0].qz,
                traversable->srtData[0].qw, traversable->srtData[0].tx,traversable->srtData[0].ty, traversable->srtData[0].tz );
        }
    }

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpInstanceFromHandle( OptixTraversableHandle handle )
    {
        if( optixGetTransformTypeFromHandle( handle ) == OPTIX_TRANSFORM_TYPE_INSTANCE )
        {
            unsigned int instanceId = optixGetInstanceIdFromHandle( handle );
            const float4* transform = optixGetInstanceTransformFromHandle( handle );

            const uint3 index = optixGetLaunchIndex();
            printf( "(%4i,%4i,%4i)     OptixInstance = {\n"
                    "                       instanceId = %i,\n"
                    "                       transform  = { %f,%f,%f,%f,\n"
                    "                                      %f,%f,%f,%f,\n"
                    "                                      %f,%f,%f,%f } }\n",
                index.x,index.y,index.z,
                instanceId,
                transform[0].x, transform[0].y, transform[0].z, transform[0].w,
                transform[1].x, transform[1].y, transform[1].z, transform[1].w,
                transform[2].x, transform[2].y, transform[2].z, transform[2].w );
        }
    }

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpTransform( OptixTraversableHandle handle )
    {
        const OptixTransformType type = optixGetTransformTypeFromHandle( handle );
        const uint3 index = optixGetLaunchIndex();

        switch( type )
        {
            case OPTIX_TRANSFORM_TYPE_NONE:
                break;
            case OPTIX_TRANSFORM_TYPE_STATIC_TRANSFORM:
                optixDumpStaticTransformFromHandle( handle );
                break;
            case OPTIX_TRANSFORM_TYPE_MATRIX_MOTION_TRANSFORM:
                optixDumpMotionMatrixTransformFromHandle( handle );
                break;
            case OPTIX_TRANSFORM_TYPE_SRT_MOTION_TRANSFORM:
                optixDumpSrtMatrixTransformFromHandle( handle );
                break;
            case OPTIX_TRANSFORM_TYPE_INSTANCE:
                optixDumpInstanceFromHandle( handle );
                break;
            default:
                break;
        }
    }

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpTransformList()
    {
        const int tlistSize = optixGetTransformListSize();
        const uint3 index = optixGetLaunchIndex();

        printf("(%4i,%4i,%4i) transform list of size %i:\n", index.x,index.y,index.z, tlistSize);

        for( unsigned int i = 0 ; i < tlistSize ; ++i )
        {
            OptixTraversableHandle handle = optixGetTransformListHandle( i );
            printf("(%4i,%4i,%4i)   transform[%i] = %p\n", index.x, index.y, index.z, i, (void*)handle);
            optixDumpTransform(handle);
        }
    }

    static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixDumpExceptionDetails()
    {
        bool dumpTlist = false;
        const int exceptionCode = optixGetExceptionCode();
        const uint3 index = optixGetLaunchIndex();

        if( exceptionCode == OPTIX_EXCEPTION_CODE_STACK_OVERFLOW )
        {
            printf("(%4i,%4i,%4i) error: stack overflow\n", index.x,index.y,index.z);
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_TRACE_DEPTH_EXCEEDED )
        {
            printf("(%4i,%4i,%4i) error: trace depth exceeded\n", index.x,index.y,index.z);
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_TRAVERSAL_DEPTH_EXCEEDED )
        {
            printf("(%4i,%4i,%4i) error: traversal depth exceeded\n", index.x,index.y,index.z);
            dumpTlist = true;
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_TRAVERSABLE )
        {
            OptixTraversableHandle handle = optixGetExceptionInvalidTraversable();
            printf("(%4i,%4i,%4i) error: invalid traversable %p\n", index.x,index.y,index.z, (void*)handle);
            dumpTlist = true;
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_MISS_SBT )
        {
            int sbtOffset = optixGetExceptionInvalidSbtOffset();
            printf("(%4i,%4i,%4i) error: invalid miss sbt of %i\n", index.x,index.y,index.z, sbtOffset);
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_TRAVERSAL_INVALID_HIT_SBT )
        {
            int sbtOffset = optixGetExceptionInvalidSbtOffset();
            printf("(%4i,%4i,%4i) error: invalid hit sbt of %i at primitive with gas sbt index %i\n", index.x,index.y,index.z, sbtOffset, optixGetSbtGASIndex() );
            dumpTlist = true;
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_UNSUPPORTED_PRIMITIVE_TYPE )
        {
            dumpTlist = true;
            printf( "(%4i,%4i,%4i) error: shader encountered unsupported builtin type\n"
                    "       call location:   %s\n", index.x, index.y, index.z, optixGetExceptionLineInfo() );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_INVALID_RAY )
        {
            OptixInvalidRayExceptionDetails ray = optixGetExceptionInvalidRay();
            printf( "(%4i,%4i,%4i) error: encountered ray with nan or inf values:\n", index.x, index.y, index.z );
            printf(
                "       origin:          [%f, %f, %f]\n"
                "       direction:       [%f, %f, %f]\n"
                "       tmin:            %f\n"
                "       tmax:            %f\n"
                "       rayTime:         %f\n"
                "       call location:   %s\n",
                ray.origin.x, ray.origin.y, ray.origin.z, ray.direction.x, ray.direction.y,
                ray.direction.z, ray.tmin, ray.tmax, ray.time, optixGetExceptionLineInfo() );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_CALLABLE_PARAMETER_MISMATCH )
        {
             OptixParameterMismatchExceptionDetails details = optixGetExceptionParameterMismatch();
             printf( "(%4i,%4i,%4i) error: parameter mismatch in callable call.\n", index.x, index.y, index.z );
             printf(
                "       passed packed arguments:       %u 32 Bit values\n"
                "       expected packed parameters:    %u 32 Bit values\n"
                "       SBT index:                     %u\n"
                "       called function:               %s\n"
                "       call location:                 %s\n",
                details.passedArgumentCount, details.expectedParameterCount, details.sbtIndex,
                details.callableName, optixGetExceptionLineInfo() );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_BUILTIN_IS_MISMATCH )
        {
            dumpTlist = true;
            printf("(%4i,%4i,%4i) error: mismatch between builtin IS shader and build input\n"
                   "       call location:   %s\n", index.x,index.y,index.z, optixGetExceptionLineInfo() );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_CALLABLE_INVALID_SBT )
        {
            int sbtOffset = optixGetExceptionInvalidSbtOffset();
            printf( "(%4i,%4i,%4i) error: invalid sbt offset of %i for callable program\n", index.x, index.y, index.z, sbtOffset );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_CALLABLE_NO_DC_SBT_RECORD )
        {
            int sbtOffset = optixGetExceptionInvalidSbtOffset();
            printf( "(%4i,%4i,%4i) error: invalid sbt offset of %i for direct callable program\n", index.x, index.y, index.z, sbtOffset );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_CALLABLE_NO_CC_SBT_RECORD )
        {
            int sbtOffset = optixGetExceptionInvalidSbtOffset();
            printf( "(%4i,%4i,%4i) error: invalid sbt offset of %i for continuation callable program\n", index.x, index.y, index.z, sbtOffset );
        }
        else if( exceptionCode == OPTIX_EXCEPTION_CODE_UNSUPPORTED_SINGLE_LEVEL_GAS )
        {
            OptixTraversableHandle handle = optixGetExceptionInvalidTraversable();
            printf("(%4i,%4i,%4i) error: unsupported single GAS traversable graph %p\n", index.x,index.y,index.z, (void*)handle);
            dumpTlist = true;
        }
        else if( exceptionCode >= 0 )
        {
            dumpTlist = true;
            printf( "(%4i,%4i,%4i) error: user exception with error code %i\n"
                    "       call location:   %s\n", index.x, index.y, index.z, exceptionCode, optixGetExceptionLineInfo() );
        }
        else
        {
            printf("(%4i,%4i,%4i) error: unknown exception with error code %i\n", index.x,index.y,index.z, exceptionCode);
        }

        if( dumpTlist )
            optixDumpTransformList();
    }

}
# 37 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl_transformations.h" 1
# 36 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl_transformations.h"
namespace optix_impl {

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 optixAddFloat4( const float4& a, const float4& b )
{
    return make_float4( a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 optixMulFloat4( const float4& a, float b )
{
    return make_float4( a.x * b, a.y * b, a.z * b, a.w * b );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint4 optixLdg( unsigned long long addr )
{
    const uint4* ptr;
    asm volatile( "cvta.to.global.u64 %0, %1;" : "=l"( ptr ) : "l"( addr ) );
    uint4 ret;
    asm volatile( "ld.global.v4.u32 {%0,%1,%2,%3}, [%4];"
                  : "=r"( ret.x ), "=r"( ret.y ), "=r"( ret.z ), "=r"( ret.w )
                  : "l"( ptr ) );
    return ret;
}

template <class T>
static __inline__ __attribute__((always_inline)) __attribute__((device)) T optixLoadReadOnlyAlign16( const T* ptr )
{
    T v;
    for( int ofs = 0; ofs < sizeof( T ); ofs += 16 )
        *(uint4*)( (char*)&v + ofs ) = optixLdg( (unsigned long long)( (char*)ptr + ofs ) );
    return v;
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) float4 optixMultiplyRowMatrix( const float4 vec, const float4 m0, const float4 m1, const float4 m2 )
{
    float4 result;

    result.x = vec.x * m0.x + vec.y * m1.x + vec.z * m2.x;
    result.y = vec.x * m0.y + vec.y * m1.y + vec.z * m2.y;
    result.z = vec.x * m0.z + vec.y * m1.z + vec.z * m2.z;
    result.w = vec.x * m0.w + vec.y * m1.w + vec.z * m2.w + vec.w;

    return result;
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetMatrixFromSrt( float4& m0, float4& m1, float4& m2, const OptixSRTData& srt )
{
    const float4 q = {srt.qx, srt.qy, srt.qz, srt.qw};


    const float inv_sql = 1.f / ( srt.qx * srt.qx + srt.qy * srt.qy + srt.qz * srt.qz + srt.qw * srt.qw );
    const float4 nq = optixMulFloat4( q, inv_sql );

    const float sqw = q.w * nq.w;
    const float sqx = q.x * nq.x;
    const float sqy = q.y * nq.y;
    const float sqz = q.z * nq.z;

    const float xy = q.x * nq.y;
    const float zw = q.z * nq.w;
    const float xz = q.x * nq.z;
    const float yw = q.y * nq.w;
    const float yz = q.y * nq.z;
    const float xw = q.x * nq.w;

    m0.x = ( sqx - sqy - sqz + sqw );
    m0.y = 2.0f * ( xy - zw );
    m0.z = 2.0f * ( xz + yw );

    m1.x = 2.0f * ( xy + zw );
    m1.y = ( -sqx + sqy - sqz + sqw );
    m1.z = 2.0f * ( yz - xw );

    m2.x = 2.0f * ( xz - yw );
    m2.y = 2.0f * ( yz + xw );
    m2.z = ( -sqx - sqy + sqz + sqw );

    m0.w = m0.x * srt.pvx + m0.y * srt.pvy + m0.z * srt.pvz + srt.tx;
    m1.w = m1.x * srt.pvx + m1.y * srt.pvy + m1.z * srt.pvz + srt.ty;
    m2.w = m2.x * srt.pvx + m2.y * srt.pvy + m2.z * srt.pvz + srt.tz;

    m0.z = m0.x * srt.b + m0.y * srt.c + m0.z * srt.sz;
    m1.z = m1.x * srt.b + m1.y * srt.c + m1.z * srt.sz;
    m2.z = m2.x * srt.b + m2.y * srt.c + m2.z * srt.sz;

    m0.y = m0.x * srt.a + m0.y * srt.sy;
    m1.y = m1.x * srt.a + m1.y * srt.sy;
    m2.y = m2.x * srt.a + m2.y * srt.sy;

    m0.x = m0.x * srt.sx;
    m1.x = m1.x * srt.sx;
    m2.x = m2.x * srt.sx;
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixInvertMatrix( float4& m0, float4& m1, float4& m2 )
{
    const float det3 =
        m0.x * ( m1.y * m2.z - m1.z * m2.y ) - m0.y * ( m1.x * m2.z - m1.z * m2.x ) + m0.z * ( m1.x * m2.y - m1.y * m2.x );

    const float inv_det3 = 1.0f / det3;

    float inv3[3][3];
    inv3[0][0] = inv_det3 * ( m1.y * m2.z - m2.y * m1.z );
    inv3[0][1] = inv_det3 * ( m0.z * m2.y - m2.z * m0.y );
    inv3[0][2] = inv_det3 * ( m0.y * m1.z - m1.y * m0.z );

    inv3[1][0] = inv_det3 * ( m1.z * m2.x - m2.z * m1.x );
    inv3[1][1] = inv_det3 * ( m0.x * m2.z - m2.x * m0.z );
    inv3[1][2] = inv_det3 * ( m0.z * m1.x - m1.z * m0.x );

    inv3[2][0] = inv_det3 * ( m1.x * m2.y - m2.x * m1.y );
    inv3[2][1] = inv_det3 * ( m0.y * m2.x - m2.y * m0.x );
    inv3[2][2] = inv_det3 * ( m0.x * m1.y - m1.x * m0.y );

    const float b[3] = {m0.w, m1.w, m2.w};

    m0.x = inv3[0][0];
    m0.y = inv3[0][1];
    m0.z = inv3[0][2];
    m0.w = -inv3[0][0] * b[0] - inv3[0][1] * b[1] - inv3[0][2] * b[2];

    m1.x = inv3[1][0];
    m1.y = inv3[1][1];
    m1.z = inv3[1][2];
    m1.w = -inv3[1][0] * b[0] - inv3[1][1] * b[1] - inv3[1][2] * b[2];

    m2.x = inv3[2][0];
    m2.y = inv3[2][1];
    m2.z = inv3[2][2];
    m2.w = -inv3[2][0] * b[0] - inv3[2][1] * b[1] - inv3[2][2] * b[2];
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixLoadInterpolatedMatrixKey( float4& m0, float4& m1, float4& m2, const float4* matrix, const float t1 )
{
    m0 = optixLoadReadOnlyAlign16( &matrix[0] );
    m1 = optixLoadReadOnlyAlign16( &matrix[1] );
    m2 = optixLoadReadOnlyAlign16( &matrix[2] );


    if( t1 > 0.0f )
    {
        const float t0 = 1.0f - t1;
        m0 = optixAddFloat4( optixMulFloat4( m0, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &matrix[3] ), t1 ) );
        m1 = optixAddFloat4( optixMulFloat4( m1, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &matrix[4] ), t1 ) );
        m2 = optixAddFloat4( optixMulFloat4( m2, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &matrix[5] ), t1 ) );
    }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixLoadInterpolatedSrtKey( float4& srt0,
                                                                    float4& srt1,
                                                                    float4& srt2,
                                                                    float4& srt3,
                                                                    const float4* srt,
                                                                    const float t1 )
{
    srt0 = optixLoadReadOnlyAlign16( &srt[0] );
    srt1 = optixLoadReadOnlyAlign16( &srt[1] );
    srt2 = optixLoadReadOnlyAlign16( &srt[2] );
    srt3 = optixLoadReadOnlyAlign16( &srt[3] );


    if( t1 > 0.0f )
    {
        const float t0 = 1.0f - t1;
        srt0 = optixAddFloat4( optixMulFloat4( srt0, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &srt[4] ), t1 ) );
        srt1 = optixAddFloat4( optixMulFloat4( srt1, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &srt[5] ), t1 ) );
        srt2 = optixAddFloat4( optixMulFloat4( srt2, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &srt[6] ), t1 ) );
        srt3 = optixAddFloat4( optixMulFloat4( srt3, t0 ), optixMulFloat4( optixLoadReadOnlyAlign16( &srt[7] ), t1 ) );

        float inv_length = 1.f / sqrt( srt2.y * srt2.y + srt2.z * srt2.z + srt2.w * srt2.w + srt3.x * srt3.x );
        srt2.y *= inv_length;
        srt2.z *= inv_length;
        srt2.w *= inv_length;
        srt3.x *= inv_length;
    }
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixResolveMotionKey( float& localt, int& key, const OptixMotionOptions& options, const float globalt )
{
    const float timeBegin = options.timeBegin;
    const float timeEnd = options.timeEnd;
    const float numIntervals = (float)( options.numKeys - 1 );




    const float time = max( 0.f, min( numIntervals, ( globalt - timeBegin ) * numIntervals / ( timeEnd - timeBegin ) ) );
    const float fltKey = floorf( time );

    localt = time - fltKey;
    key = (int)fltKey;
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetInterpolatedTransformation( float4& trf0,
                                                                           float4& trf1,
                                                                           float4& trf2,
                                                                           const OptixMatrixMotionTransform* transformData,
                                                                           const float time )
{

    float keyTime;
    int key;
    optixResolveMotionKey( keyTime, key, optixLoadReadOnlyAlign16( transformData ).motionOptions, time );


    const float4* transform = (const float4*)( &transformData->transform[key][0] );


    optixLoadInterpolatedMatrixKey( trf0, trf1, trf2, transform, keyTime );
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetInterpolatedTransformation( float4& trf0,
                                                                           float4& trf1,
                                                                           float4& trf2,
                                                                           const OptixSRTMotionTransform* transformData,
                                                                           const float time )
{

    float keyTime;
    int key;
    optixResolveMotionKey( keyTime, key, optixLoadReadOnlyAlign16( transformData ).motionOptions, time );


    const float4* dataPtr = reinterpret_cast<const float4*>( &transformData->srtData[key] );


    float4 data[4];
    optixLoadInterpolatedSrtKey( data[0], data[1], data[2], data[3], dataPtr, keyTime );

    OptixSRTData srt = {data[0].x, data[0].y, data[0].z, data[0].w, data[1].x, data[1].y, data[1].z, data[1].w,
                        data[2].x, data[2].y, data[2].z, data[2].w, data[3].x, data[3].y, data[3].z, data[3].w};


    optixGetMatrixFromSrt( trf0, trf1, trf2, srt );
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetInterpolatedTransformationFromHandle( float4& trf0,
                                                                                     float4& trf1,
                                                                                     float4& trf2,
                                                                                     const OptixTraversableHandle handle,
                                                                                     const float time,
                                                                                     const bool objectToWorld )
{
    const OptixTransformType type = optixGetTransformTypeFromHandle( handle );

    if( type == OPTIX_TRANSFORM_TYPE_MATRIX_MOTION_TRANSFORM || type == OPTIX_TRANSFORM_TYPE_SRT_MOTION_TRANSFORM )
    {
        if( type == OPTIX_TRANSFORM_TYPE_MATRIX_MOTION_TRANSFORM )
        {
            const OptixMatrixMotionTransform* transformData = optixGetMatrixMotionTransformFromHandle( handle );
            optixGetInterpolatedTransformation( trf0, trf1, trf2, transformData, time );
        }
        else
        {
            const OptixSRTMotionTransform* transformData = optixGetSRTMotionTransformFromHandle( handle );
            optixGetInterpolatedTransformation( trf0, trf1, trf2, transformData, time );
        }

        if( !objectToWorld )
            optixInvertMatrix( trf0, trf1, trf2 );
    }
    else if( type == OPTIX_TRANSFORM_TYPE_INSTANCE || type == OPTIX_TRANSFORM_TYPE_STATIC_TRANSFORM )
    {
        const float4* transform;

        if( type == OPTIX_TRANSFORM_TYPE_INSTANCE )
        {
            transform = ( objectToWorld ) ? optixGetInstanceTransformFromHandle( handle ) :
                                            optixGetInstanceInverseTransformFromHandle( handle );
        }
        else
        {
            const OptixStaticTransform* traversable = optixGetStaticTransformFromHandle( handle );
            transform = (const float4*)( ( objectToWorld ) ? traversable->transform : traversable->invTransform );
        }

        trf0 = optixLoadReadOnlyAlign16( &transform[0] );
        trf1 = optixLoadReadOnlyAlign16( &transform[1] );
        trf2 = optixLoadReadOnlyAlign16( &transform[2] );
    }
    else
    {
        trf0 = {1.0f, 0.0f, 0.0f, 0.0f};
        trf1 = {0.0f, 1.0f, 0.0f, 0.0f};
        trf2 = {0.0f, 0.0f, 1.0f, 0.0f};
    }
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetWorldToObjectTransformMatrix( float4& m0, float4& m1, float4& m2 )
{
    const unsigned int size = optixGetTransformListSize();
    const float time = optixGetRayTime();

#pragma unroll 1
    for( unsigned int i = 0; i < size; ++i )
    {
        OptixTraversableHandle handle = optixGetTransformListHandle( i );

        float4 trf0, trf1, trf2;
        optixGetInterpolatedTransformationFromHandle( trf0, trf1, trf2, handle, time, false );

        if( i == 0 )
        {
            m0 = trf0;
            m1 = trf1;
            m2 = trf2;
        }
        else
        {

            float4 tmp0 = m0, tmp1 = m1, tmp2 = m2;
            m0 = optixMultiplyRowMatrix( trf0, tmp0, tmp1, tmp2 );
            m1 = optixMultiplyRowMatrix( trf1, tmp0, tmp1, tmp2 );
            m2 = optixMultiplyRowMatrix( trf2, tmp0, tmp1, tmp2 );
        }
    }
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetObjectToWorldTransformMatrix( float4& m0, float4& m1, float4& m2 )
{
    const int size = optixGetTransformListSize();
    const float time = optixGetRayTime();

#pragma unroll 1
    for( int i = size - 1; i >= 0; --i )
    {
        OptixTraversableHandle handle = optixGetTransformListHandle( i );

        float4 trf0, trf1, trf2;
        optixGetInterpolatedTransformationFromHandle( trf0, trf1, trf2, handle, time, true );

        if( i == size - 1 )
        {
            m0 = trf0;
            m1 = trf1;
            m2 = trf2;
        }
        else
        {

            float4 tmp0 = m0, tmp1 = m1, tmp2 = m2;
            m0 = optixMultiplyRowMatrix( trf0, tmp0, tmp1, tmp2 );
            m1 = optixMultiplyRowMatrix( trf1, tmp0, tmp1, tmp2 );
            m2 = optixMultiplyRowMatrix( trf2, tmp0, tmp1, tmp2 );
        }
    }
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformPoint( const float4& m0, const float4& m1, const float4& m2, const float3& p )
{
    float3 result;
    result.x = m0.x * p.x + m0.y * p.y + m0.z * p.z + m0.w;
    result.y = m1.x * p.x + m1.y * p.y + m1.z * p.z + m1.w;
    result.z = m2.x * p.x + m2.y * p.y + m2.z * p.z + m2.w;
    return result;
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformVector( const float4& m0, const float4& m1, const float4& m2, const float3& v )
{
    float3 result;
    result.x = m0.x * v.x + m0.y * v.y + m0.z * v.z;
    result.y = m1.x * v.x + m1.y * v.y + m1.z * v.z;
    result.z = m2.x * v.x + m2.y * v.y + m2.z * v.z;
    return result;
}



static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformNormal( const float4& m0, const float4& m1, const float4& m2, const float3& n )
{
    float3 result;
    result.x = m0.x * n.x + m1.x * n.y + m2.x * n.z;
    result.y = m0.y * n.x + m1.y * n.y + m2.y * n.z;
    result.z = m0.z * n.x + m1.z * n.y + m2.z * n.z;
    return result;
}

}
# 38 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl.h" 2

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    asm volatile(
        "call _optix_trace_0"
        ", (%0, %1, %2, %3, %4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14"
        ");"
        :

        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ), "r"( missSBTIndex )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out;
    asm volatile(
        "call (%0), _optix_trace_1"
        ", (%1, %2, %3, %4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15"
        ", %16"
        ");"
        : "=r"( p0_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ), "f"( rayTime ),
          "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ), "r"( missSBTIndex ), "r"( p0 )
        : );
    p0 = p0_out;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out;
    asm volatile(
        "call (%0, %1), _optix_trace_2"
        ", (%2, %3, %4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16"
        ", %17, %18"
        ");"
        : "=r"( p0_out ), "=r"( p1_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 )
        : );
    p0 = p0_out;
    p1 = p1_out;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out, p2_out;
    asm volatile(
        "call (%0, %1, %2), _optix_trace_3"
        ", (%3, %4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16, %17"
        ", %18, %19, %20"
        ");"
        : "=r"( p0_out ), "=r"( p1_out ), "=r"( p2_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 ), "r"( p2 )
        : );
    p0 = p0_out;
    p1 = p1_out;
    p2 = p2_out;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out, p2_out, p3_out;
    asm volatile(
        "call (%0, %1, %2, %3), _optix_trace_4"
        ", (%4, %5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16, %17, %18"
        ", %19, %20, %21, %22"
        ");"
        : "=r"( p0_out ), "=r"( p1_out ), "=r"( p2_out ), "=r"( p3_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 ), "r"( p2 ), "r"( p3 )
        : );
    p0 = p0_out;
    p1 = p1_out;
    p2 = p2_out;
    p3 = p3_out;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out, p2_out, p3_out, p4_out;
    asm volatile(
        "call (%0, %1, %2, %3, %4), _optix_trace_5"
        ", (%5, %6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16, %17, %18, %19"
        ", %20, %21, %22, %23, %24"
        ");"
        : "=r"( p0_out ), "=r"( p1_out ), "=r"( p2_out ), "=r"( p3_out ), "=r"( p4_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 ), "r"( p2 ), "r"( p3 ), "r"( p4 )
        : );
    p0 = p0_out;
    p1 = p1_out;
    p2 = p2_out;
    p3 = p3_out;
    p4 = p4_out;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4,
                                                   unsigned int& p5 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out, p2_out, p3_out, p4_out, p5_out;
    asm volatile(
        "call (%0, %1, %2, %3, %4, %5), _optix_trace_6"
        ", (%6, %7, %8, %9, %10, %11, %12, %13, %14, %15, %16, %17, %18, %19, %20"
        ", %21, %22, %23, %24, %25, %26"
        ");"
        : "=r"( p0_out ), "=r"( p1_out ), "=r"( p2_out ), "=r"( p3_out ), "=r"( p4_out ), "=r"( p5_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 ), "r"( p2 ), "r"( p3 ), "r"( p4 ), "r"( p5 )
        : );
    p0 = p0_out;
    p1 = p1_out;
    p2 = p2_out;
    p3 = p3_out;
    p4 = p4_out;
    p5 = p5_out;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4,
                                                   unsigned int& p5,
                                                   unsigned int& p6 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out, p2_out, p3_out, p4_out, p5_out, p6_out;
    asm volatile(
        "call (%0, %1, %2, %3, %4, %5, %6), _optix_trace_7"
        ", (%7, %8, %9, %10, %11, %12, %13, %14, %15, %16, %17, %18, %19, %20, %21"
        ", %22, %23, %24, %25, %26, %27, %28"
        ");"
        : "=r"( p0_out ), "=r"( p1_out ), "=r"( p2_out ), "=r"( p3_out ), "=r"( p4_out ), "=r"( p5_out ), "=r"( p6_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 ), "r"( p2 ), "r"( p3 ), "r"( p4 ), "r"( p5 ), "r"( p6 )
        : );
    p0 = p0_out;
    p1 = p1_out;
    p2 = p2_out;
    p3 = p3_out;
    p4 = p4_out;
    p5 = p5_out;
    p6 = p6_out;
}
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTrace( OptixTraversableHandle handle,
                                                   float3 rayOrigin,
                                                   float3 rayDirection,
                                                   float tmin,
                                                   float tmax,
                                                   float rayTime,
                                                   OptixVisibilityMask visibilityMask,
                                                   unsigned int rayFlags,
                                                   unsigned int SBToffset,
                                                   unsigned int SBTstride,
                                                   unsigned int missSBTIndex,
                                                   unsigned int& p0,
                                                   unsigned int& p1,
                                                   unsigned int& p2,
                                                   unsigned int& p3,
                                                   unsigned int& p4,
                                                   unsigned int& p5,
                                                   unsigned int& p6,
                                                   unsigned int& p7 )
{
    float ox = rayOrigin.x, oy = rayOrigin.y, oz = rayOrigin.z;
    float dx = rayDirection.x, dy = rayDirection.y, dz = rayDirection.z;
    unsigned int p0_out, p1_out, p2_out, p3_out, p4_out, p5_out, p6_out, p7_out;
    asm volatile(
        "call (%0, %1, %2, %3, %4, %5, %6, %7), _optix_trace_8"
        ", (%8, %9, %10, %11, %12, %13, %14, %15, %16, %17, %18, %19, %20, %21, %22"
        ", %23, %24, %25, %26, %27, %28, %29, %30"
        ");"
        : "=r"( p0_out ), "=r"( p1_out ), "=r"( p2_out ), "=r"( p3_out ), "=r"( p4_out ), "=r"( p5_out ),
          "=r"( p6_out ), "=r"( p7_out )
        : "l"( handle ), "f"( ox ), "f"( oy ), "f"( oz ), "f"( dx ), "f"( dy ), "f"( dz ), "f"( tmin ), "f"( tmax ),
          "f"( rayTime ), "r"( visibilityMask ), "r"( rayFlags ), "r"( SBToffset ), "r"( SBTstride ),
          "r"( missSBTIndex ), "r"( p0 ), "r"( p1 ), "r"( p2 ), "r"( p3 ), "r"( p4 ), "r"( p5 ), "r"( p6 ), "r"( p7 )
        : );
    p0 = p0_out;
    p1 = p1_out;
    p2 = p2_out;
    p3 = p3_out;
    p4 = p4_out;
    p5 = p5_out;
    p6 = p6_out;
    p7 = p7_out;
}
# 354 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/internal/optix_7_device_impl.h"
static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_0( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "0" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_1( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "1" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_2( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "2" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_3( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "3" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_4( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "4" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_5( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "5" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_6( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "6" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixSetPayload_7( unsigned int p )
{
    asm volatile( "call _optix_set_payload_" "7" ", (%0);" : : "r"( p ) : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_0()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "0" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_1()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "1" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_2()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "2" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_3()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "3" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_4()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "4" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_5()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "5" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_6()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "6" ", ();" : "=r"( result ) : ); return result;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPayload_7()
{
    unsigned int result; asm volatile( "call (%0), _optix_get_payload_" "7" ", ();" : "=r"( result ) : ); return result;;
}




static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixUndefinedValue()
{
    unsigned int u0;
    asm( "call (%0), _optix_undef_value, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetWorldRayOrigin()
{
    float f0, f1, f2;
    asm( "call (%0), _optix_get_world_ray_origin_x, ();" : "=f"( f0 ) : );
    asm( "call (%0), _optix_get_world_ray_origin_y, ();" : "=f"( f1 ) : );
    asm( "call (%0), _optix_get_world_ray_origin_z, ();" : "=f"( f2 ) : );
    return make_float3( f0, f1, f2 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetWorldRayDirection()
{
    float f0, f1, f2;
    asm( "call (%0), _optix_get_world_ray_direction_x, ();" : "=f"( f0 ) : );
    asm( "call (%0), _optix_get_world_ray_direction_y, ();" : "=f"( f1 ) : );
    asm( "call (%0), _optix_get_world_ray_direction_z, ();" : "=f"( f2 ) : );
    return make_float3( f0, f1, f2 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetObjectRayOrigin()
{
    float f0, f1, f2;
    asm( "call (%0), _optix_get_object_ray_origin_x, ();" : "=f"( f0 ) : );
    asm( "call (%0), _optix_get_object_ray_origin_y, ();" : "=f"( f1 ) : );
    asm( "call (%0), _optix_get_object_ray_origin_z, ();" : "=f"( f2 ) : );
    return make_float3( f0, f1, f2 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixGetObjectRayDirection()
{
    float f0, f1, f2;
    asm( "call (%0), _optix_get_object_ray_direction_x, ();" : "=f"( f0 ) : );
    asm( "call (%0), _optix_get_object_ray_direction_y, ();" : "=f"( f1 ) : );
    asm( "call (%0), _optix_get_object_ray_direction_z, ();" : "=f"( f2 ) : );
    return make_float3( f0, f1, f2 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetRayTmin()
{
    float f0;
    asm( "call (%0), _optix_get_ray_tmin, ();" : "=f"( f0 ) : );
    return f0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetRayTmax()
{
    float f0;
    asm( "call (%0), _optix_get_ray_tmax, ();" : "=f"( f0 ) : );
    return f0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetRayTime()
{
    float f0;
    asm( "call (%0), _optix_get_ray_time, ();" : "=f"( f0 ) : );
    return f0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetRayFlags()
{
    unsigned int u0;
    asm( "call (%0), _optix_get_ray_flags, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetRayVisibilityMask()
{
    unsigned int u0;
    asm( "call (%0), _optix_get_ray_visibility_mask, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetTriangleVertexData( OptixTraversableHandle gas,
                                                                   unsigned int primIdx,
                                                                   unsigned int sbtGASIndex,
                                                                   float time,
                                                                   float3 data[3] )
{
    asm( "call (%0, %1, %2, %3, %4, %5, %6, %7, %8), _optix_get_triangle_vertex_data, "
         "(%9, %10, %11, %12);"
         : "=f"( data[0].x ), "=f"( data[0].y ), "=f"( data[0].z ), "=f"( data[1].x ), "=f"( data[1].y ),
           "=f"( data[1].z ), "=f"( data[2].x ), "=f"( data[2].y ), "=f"( data[2].z )
         : "l"( gas ), "r"( primIdx ), "r"( sbtGASIndex ), "f"( time )
         : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetLinearCurveVertexData( OptixTraversableHandle gas,
                                                                      unsigned int primIdx,
                                                                      unsigned int sbtGASIndex,
                                                                      float time,
                                                                      float4 data[2] )
{
    asm( "call (%0, %1, %2, %3,  %4, %5, %6, %7), _optix_get_linear_curve_vertex_data, "
         "(%8, %9, %10, %11);"
         : "=f"( data[0].x ), "=f"( data[0].y ), "=f"( data[0].z ), "=f"( data[0].w ),
           "=f"( data[1].x ), "=f"( data[1].y ), "=f"( data[1].z ), "=f"( data[1].w )
         : "l"( gas ), "r"( primIdx ), "r"( sbtGASIndex ), "f"( time )
         : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetQuadraticBSplineVertexData( OptixTraversableHandle gas,
                                                                           unsigned int primIdx,
                                                                           unsigned int sbtGASIndex,
                                                                           float time,
                                                                           float4 data[3] )
{
    asm( "call (%0, %1, %2, %3,  %4, %5, %6, %7,  %8, %9, %10, %11), _optix_get_quadratic_bspline_vertex_data, "
         "(%12, %13, %14, %15);"
         : "=f"( data[0].x ), "=f"( data[0].y ), "=f"( data[0].z ), "=f"( data[0].w ),
           "=f"( data[1].x ), "=f"( data[1].y ), "=f"( data[1].z ), "=f"( data[1].w ),
           "=f"( data[2].x ), "=f"( data[2].y ), "=f"( data[2].z ), "=f"( data[2].w )
         : "l"( gas ), "r"( primIdx ), "r"( sbtGASIndex ), "f"( time )
         : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetCubicBSplineVertexData( OptixTraversableHandle gas,
                                                                       unsigned int primIdx,
                                                                       unsigned int sbtGASIndex,
                                                                       float time,
                                                                       float4 data[4] )
{
    asm( "call (%0, %1, %2, %3,  %4, %5, %6, %7,  %8, %9, %10, %11,  %12, %13, %14, %15), "
         "_optix_get_cubic_bspline_vertex_data, "
         "(%16, %17, %18, %19);"
         : "=f"( data[0].x ), "=f"( data[0].y ), "=f"( data[0].z ), "=f"( data[0].w ),
           "=f"( data[1].x ), "=f"( data[1].y ), "=f"( data[1].z ), "=f"( data[1].w ),
           "=f"( data[2].x ), "=f"( data[2].y ), "=f"( data[2].z ), "=f"( data[2].w ),
           "=f"( data[3].x ), "=f"( data[3].y ), "=f"( data[3].z ), "=f"( data[3].w )
         : "l"( gas ), "r"( primIdx ), "r"( sbtGASIndex ), "f"( time )
         : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTraversableHandle optixGetGASTraversableHandle()
{
    unsigned long long handle;
    asm( "call (%0), _optix_get_gas_traversable_handle, ();" : "=l"( handle ) : );
    return (OptixTraversableHandle)handle;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetGASMotionTimeBegin( OptixTraversableHandle handle )
{
    float f0;
    asm( "call (%0), _optix_get_gas_motion_time_begin, (%1);" : "=f"( f0 ) : "l"( handle ) : );
    return f0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetGASMotionTimeEnd( OptixTraversableHandle handle )
{
    float f0;
    asm( "call (%0), _optix_get_gas_motion_time_end, (%1);" : "=f"( f0 ) : "l"( handle ) : );
    return f0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetGASMotionStepCount( OptixTraversableHandle handle )
{
    unsigned int u0;
    asm( "call (%0), _optix_get_gas_motion_step_count, (%1);" : "=r"( u0 ) : "l"( handle ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetWorldToObjectTransformMatrix( float m[12] )
{
    if( optixGetTransformListSize() == 0 )
    {
        m[0] = 1.0f;
        m[1] = 0.0f;
        m[2] = 0.0f;
        m[3] = 0.0f;
        m[4] = 0.0f;
        m[5] = 1.0f;
        m[6] = 0.0f;
        m[7] = 0.0f;
        m[8] = 0.0f;
        m[9] = 0.0f;
        m[10] = 1.0f;
        m[11] = 0.0f;
        return;
    }

    float4 m0, m1, m2;
    optix_impl::optixGetWorldToObjectTransformMatrix( m0, m1, m2 );
    m[0] = m0.x;
    m[1] = m0.y;
    m[2] = m0.z;
    m[3] = m0.w;
    m[4] = m1.x;
    m[5] = m1.y;
    m[6] = m1.z;
    m[7] = m1.w;
    m[8] = m2.x;
    m[9] = m2.y;
    m[10] = m2.z;
    m[11] = m2.w;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixGetObjectToWorldTransformMatrix( float m[12] )
{
    if( optixGetTransformListSize() == 0 )
    {
        m[0] = 1.0f;
        m[1] = 0.0f;
        m[2] = 0.0f;
        m[3] = 0.0f;
        m[4] = 0.0f;
        m[5] = 1.0f;
        m[6] = 0.0f;
        m[7] = 0.0f;
        m[8] = 0.0f;
        m[9] = 0.0f;
        m[10] = 1.0f;
        m[11] = 0.0f;
        return;
    }

    float4 m0, m1, m2;
    optix_impl::optixGetObjectToWorldTransformMatrix( m0, m1, m2 );
    m[0] = m0.x;
    m[1] = m0.y;
    m[2] = m0.z;
    m[3] = m0.w;
    m[4] = m1.x;
    m[5] = m1.y;
    m[6] = m1.z;
    m[7] = m1.w;
    m[8] = m2.x;
    m[9] = m2.y;
    m[10] = m2.z;
    m[11] = m2.w;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformPointFromWorldToObjectSpace( float3 point )
{
    if( optixGetTransformListSize() == 0 )
        return point;

    float4 m0, m1, m2;
    optix_impl::optixGetWorldToObjectTransformMatrix( m0, m1, m2 );
    return optix_impl::optixTransformPoint( m0, m1, m2, point );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformVectorFromWorldToObjectSpace( float3 vec )
{
    if( optixGetTransformListSize() == 0 )
        return vec;

    float4 m0, m1, m2;
    optix_impl::optixGetWorldToObjectTransformMatrix( m0, m1, m2 );
    return optix_impl::optixTransformVector( m0, m1, m2, vec );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformNormalFromWorldToObjectSpace( float3 normal )
{
    if( optixGetTransformListSize() == 0 )
        return normal;

    float4 m0, m1, m2;
    optix_impl::optixGetObjectToWorldTransformMatrix( m0, m1, m2 );
    return optix_impl::optixTransformNormal( m0, m1, m2, normal );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformPointFromObjectToWorldSpace( float3 point )
{
    if( optixGetTransformListSize() == 0 )
        return point;

    float4 m0, m1, m2;
    optix_impl::optixGetObjectToWorldTransformMatrix( m0, m1, m2 );
    return optix_impl::optixTransformPoint( m0, m1, m2, point );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformVectorFromObjectToWorldSpace( float3 vec )
{
    if( optixGetTransformListSize() == 0 )
        return vec;

    float4 m0, m1, m2;
    optix_impl::optixGetObjectToWorldTransformMatrix( m0, m1, m2 );
    return optix_impl::optixTransformVector( m0, m1, m2, vec );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float3 optixTransformNormalFromObjectToWorldSpace( float3 normal )
{
    if( optixGetTransformListSize() == 0 )
        return normal;

    float4 m0, m1, m2;
    optix_impl::optixGetWorldToObjectTransformMatrix( m0, m1, m2 );
    return optix_impl::optixTransformNormal( m0, m1, m2, normal );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetTransformListSize()
{
    unsigned int u0;
    asm( "call (%0), _optix_get_transform_list_size, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTraversableHandle optixGetTransformListHandle( unsigned int index )
{
    unsigned long long u0;
    asm( "call (%0), _optix_get_transform_list_handle, (%1);" : "=l"( u0 ) : "r"( index ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTransformType optixGetTransformTypeFromHandle( OptixTraversableHandle handle )
{
    int i0;
    asm( "call (%0), _optix_get_transform_type_from_handle, (%1);" : "=r"( i0 ) : "l"( handle ) : );
    return (OptixTransformType)i0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) const OptixStaticTransform* optixGetStaticTransformFromHandle( OptixTraversableHandle handle )
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_static_transform_from_handle, (%1);" : "=l"( ptr ) : "l"( handle ) : );
    return (const OptixStaticTransform*)ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) const OptixSRTMotionTransform* optixGetSRTMotionTransformFromHandle( OptixTraversableHandle handle )
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_srt_motion_transform_from_handle, (%1);" : "=l"( ptr ) : "l"( handle ) : );
    return (const OptixSRTMotionTransform*)ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) const OptixMatrixMotionTransform* optixGetMatrixMotionTransformFromHandle( OptixTraversableHandle handle )
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_matrix_motion_transform_from_handle, (%1);" : "=l"( ptr ) : "l"( handle ) : );
    return (const OptixMatrixMotionTransform*)ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetInstanceIdFromHandle( OptixTraversableHandle handle )
{
    int i0;
    asm( "call (%0), _optix_get_instance_id_from_handle, (%1);" : "=r"( i0 ) : "l"( handle ) : );
    return i0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) const float4* optixGetInstanceTransformFromHandle( OptixTraversableHandle handle )
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_instance_transform_from_handle, (%1);" : "=l"( ptr ) : "l"( handle ) : );
    return (const float4*)ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) const float4* optixGetInstanceInverseTransformFromHandle( OptixTraversableHandle handle )
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_instance_inverse_transform_from_handle, (%1);" : "=l"( ptr ) : "l"( handle ) : );
    return (const float4*)ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_0"
        ", (%1, %2);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind, unsigned int a0 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_1"
        ", (%1, %2, %3);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind, unsigned int a0, unsigned int a1 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_2"
        ", (%1, %2, %3, %4);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT, unsigned int hitKind, unsigned int a0, unsigned int a1, unsigned int a2 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_3"
        ", (%1, %2, %3, %4, %5);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 ), "r"( a2 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_4"
        ", (%1, %2, %3, %4, %5, %6);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 ), "r"( a2 ), "r"( a3 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_5"
        ", (%1, %2, %3, %4, %5, %6, %7);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 ), "r"( a2 ), "r"( a3 ), "r"( a4 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4,
                                                                unsigned int a5 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_6"
        ", (%1, %2, %3, %4, %5, %6, %7, %8);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 ), "r"( a2 ), "r"( a3 ), "r"( a4 ), "r"( a5 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4,
                                                                unsigned int a5,
                                                                unsigned int a6 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_7"
        ", (%1, %2, %3, %4, %5, %6, %7, %8, %9);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 ), "r"( a2 ), "r"( a3 ), "r"( a4 ), "r"( a5 ), "r"( a6 )
        : );
    return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixReportIntersection( float hitT,
                                                                unsigned int hitKind,
                                                                unsigned int a0,
                                                                unsigned int a1,
                                                                unsigned int a2,
                                                                unsigned int a3,
                                                                unsigned int a4,
                                                                unsigned int a5,
                                                                unsigned int a6,
                                                                unsigned int a7 )
{
    int ret;
    asm volatile(
        "call (%0), _optix_report_intersection_8"
        ", (%1, %2, %3, %4, %5, %6, %7, %8, %9, %10);"
        : "=r"( ret )
        : "f"( hitT ), "r"( hitKind ), "r"( a0 ), "r"( a1 ), "r"( a2 ), "r"( a3 ), "r"( a4 ), "r"( a5 ), "r"( a6 ), "r"( a7 )
        : );
    return ret;
}






static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_0()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "0" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_1()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "1" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_2()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "2" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_3()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "3" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_4()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "4" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_5()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "5" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_6()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "6" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetAttribute_7()
{
    unsigned int ret; asm( "call (%0), _optix_get_attribute_" "7" ", ();" : "=r"( ret ) : ); return ret;;
}



static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixTerminateRay()
{
    asm volatile( "call _optix_terminate_ray, ();" );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixIgnoreIntersection()
{
    asm volatile( "call _optix_ignore_intersection, ();" );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetPrimitiveIndex()
{
    unsigned int u0;
    asm( "call (%0), _optix_read_primitive_idx, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetSbtGASIndex()
{
    unsigned int u0;
    asm( "call (%0), _optix_read_sbt_gas_idx, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetInstanceId()
{
    unsigned int u0;
    asm( "call (%0), _optix_read_instance_id, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetInstanceIndex()
{
    unsigned int u0;
    asm( "call (%0), _optix_read_instance_idx, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetHitKind()
{
    unsigned int u0;
    asm( "call (%0), _optix_get_hit_kind, ();" : "=r"( u0 ) : );
    return u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixPrimitiveType optixGetPrimitiveType(unsigned int hitKind)
{
    unsigned int u0;
    asm( "call (%0), _optix_get_primitive_type_from_hit_kind, (%1);" : "=r"( u0 ) : "r"( hitKind ) );
    return (OptixPrimitiveType)u0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsBackFaceHit( unsigned int hitKind )
{
    unsigned int u0;
    asm( "call (%0), _optix_get_backface_from_hit_kind, (%1);" : "=r"( u0 ) : "r"( hitKind ) );
    return (u0 == 0x1);
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsFrontFaceHit( unsigned int hitKind )
{
    return !optixIsBackFaceHit( hitKind );
}


static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixPrimitiveType optixGetPrimitiveType()
{
    return optixGetPrimitiveType( optixGetHitKind() );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsBackFaceHit()
{
    return optixIsBackFaceHit( optixGetHitKind() );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsFrontFaceHit()
{
    return optixIsFrontFaceHit( optixGetHitKind() );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsTriangleHit()
{
    return optixIsTriangleFrontFaceHit() || optixIsTriangleBackFaceHit();
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsTriangleFrontFaceHit()
{
    return optixGetHitKind() == OPTIX_HIT_KIND_TRIANGLE_FRONT_FACE;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) bool optixIsTriangleBackFaceHit()
{
    return optixGetHitKind() == OPTIX_HIT_KIND_TRIANGLE_BACK_FACE;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float optixGetCurveParameter()
{
    return __int_as_float( optixGetAttribute_0() );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) float2 optixGetTriangleBarycentrics()
{
    float f0, f1;
    asm( "call (%0, %1), _optix_get_triangle_barycentrics, ();" : "=f"( f0 ), "=f"( f1 ) : );
    return make_float2( f0, f1 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint3 optixGetLaunchIndex()
{
    unsigned int u0, u1, u2;
    asm( "call (%0), _optix_get_launch_index_x, ();" : "=r"( u0 ) : );
    asm( "call (%0), _optix_get_launch_index_y, ();" : "=r"( u1 ) : );
    asm( "call (%0), _optix_get_launch_index_z, ();" : "=r"( u2 ) : );
    return make_uint3( u0, u1, u2 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) uint3 optixGetLaunchDimensions()
{
    unsigned int u0, u1, u2;
    asm( "call (%0), _optix_get_launch_dimension_x, ();" : "=r"( u0 ) : );
    asm( "call (%0), _optix_get_launch_dimension_y, ();" : "=r"( u1 ) : );
    asm( "call (%0), _optix_get_launch_dimension_z, ();" : "=r"( u2 ) : );
    return make_uint3( u0, u1, u2 );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) CUdeviceptr optixGetSbtDataPointer()
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_sbt_data_ptr_64, ();" : "=l"( ptr ) : );
    return (CUdeviceptr)ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode )
{
    asm volatile(
        "call _optix_throw_exception_0, (%0);"
        :
        : "r"( exceptionCode )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0 )
{
    asm volatile(
        "call _optix_throw_exception_1, (%0, %1);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1 )
{
    asm volatile(
        "call _optix_throw_exception_2, (%0, %1, %2);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1, unsigned int exceptionDetail2 )
{
    asm volatile(
        "call _optix_throw_exception_3, (%0, %1, %2, %3);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 ), "r"( exceptionDetail2 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1, unsigned int exceptionDetail2, unsigned int exceptionDetail3 )
{
    asm volatile(
        "call _optix_throw_exception_4, (%0, %1, %2, %3, %4);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 ), "r"( exceptionDetail2 ), "r"( exceptionDetail3 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1, unsigned int exceptionDetail2, unsigned int exceptionDetail3, unsigned int exceptionDetail4 )
{
    asm volatile(
        "call _optix_throw_exception_5, (%0, %1, %2, %3, %4, %5);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 ), "r"( exceptionDetail2 ), "r"( exceptionDetail3 ), "r"( exceptionDetail4 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1, unsigned int exceptionDetail2, unsigned int exceptionDetail3, unsigned int exceptionDetail4, unsigned int exceptionDetail5 )
{
    asm volatile(
        "call _optix_throw_exception_6, (%0, %1, %2, %3, %4, %5, %6);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 ), "r"( exceptionDetail2 ), "r"( exceptionDetail3 ), "r"( exceptionDetail4 ), "r"( exceptionDetail5 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1, unsigned int exceptionDetail2, unsigned int exceptionDetail3, unsigned int exceptionDetail4, unsigned int exceptionDetail5, unsigned int exceptionDetail6 )
{
    asm volatile(
        "call _optix_throw_exception_7, (%0, %1, %2, %3, %4, %5, %6, %7);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 ), "r"( exceptionDetail2 ), "r"( exceptionDetail3 ), "r"( exceptionDetail4 ), "r"( exceptionDetail5 ), "r"( exceptionDetail6 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) void optixThrowException( int exceptionCode, unsigned int exceptionDetail0, unsigned int exceptionDetail1, unsigned int exceptionDetail2, unsigned int exceptionDetail3, unsigned int exceptionDetail4, unsigned int exceptionDetail5, unsigned int exceptionDetail6, unsigned int exceptionDetail7 )
{
    asm volatile(
        "call _optix_throw_exception_8, (%0, %1, %2, %3, %4, %5, %6, %7, %8);"
        :
        : "r"( exceptionCode ), "r"( exceptionDetail0 ), "r"( exceptionDetail1 ), "r"( exceptionDetail2 ), "r"( exceptionDetail3 ), "r"( exceptionDetail4 ), "r"( exceptionDetail5 ), "r"( exceptionDetail6 ), "r"( exceptionDetail7 )
        : );
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int optixGetExceptionCode()
{
    int s0;
    asm( "call (%0), _optix_get_exception_code, ();" : "=r"( s0 ) : );
    return s0;
}






static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_0()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "0" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_1()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "1" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_2()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "2" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_3()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "3" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_4()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "4" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_5()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "5" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_6()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "6" ", ();" : "=r"( ret ) : ); return ret;;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) unsigned int optixGetExceptionDetail_7()
{
    unsigned int ret; asm( "call (%0), _optix_get_exception_detail_" "7" ", ();" : "=r"( ret ) : ); return ret;;
}



static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixTraversableHandle optixGetExceptionInvalidTraversable()
{
    unsigned long long handle;
    asm( "call (%0), _optix_get_exception_invalid_traversable, ();" : "=l"( handle ) : );
    return (OptixTraversableHandle)handle;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) int optixGetExceptionInvalidSbtOffset()
{
    int s0;
    asm( "call (%0), _optix_get_exception_invalid_sbt_offset, ();" : "=r"( s0 ) : );
    return s0;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixInvalidRayExceptionDetails optixGetExceptionInvalidRay()
{
    float rayOriginX, rayOriginY, rayOriginZ, rayDirectionX, rayDirectionY, rayDirectionZ, tmin, tmax, rayTime;
    asm( "call (%0, %1, %2, %3, %4, %5, %6, %7, %8), _optix_get_exception_invalid_ray, ();"
         : "=f"( rayOriginX ), "=f"( rayOriginY ), "=f"( rayOriginZ ), "=f"( rayDirectionX ), "=f"( rayDirectionY ),
           "=f"( rayDirectionZ ), "=f"( tmin ), "=f"( tmax ), "=f"( rayTime )
         : );
    OptixInvalidRayExceptionDetails ray;
    ray.origin = make_float3( rayOriginX, rayOriginY, rayOriginZ );
    ray.direction = make_float3( rayDirectionX, rayDirectionY, rayDirectionZ );
    ray.tmin = tmin;
    ray.tmax = tmax;
    ray.time = rayTime;
    return ray;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) OptixParameterMismatchExceptionDetails optixGetExceptionParameterMismatch()
{
    unsigned int expected, actual, sbtIdx;
    unsigned long long calleeName;
    asm(
        "call (%0, %1, %2, %3), _optix_get_exception_parameter_mismatch, ();"
        : "=r"(expected), "=r"(actual), "=r"(sbtIdx), "=l"(calleeName) : );
    OptixParameterMismatchExceptionDetails details;
    details.expectedParameterCount = expected;
    details.passedArgumentCount = actual;
    details.sbtIndex = sbtIdx;
    details.callableName = (char*)calleeName;
    return details;
}

static __inline__ __attribute__((always_inline)) __attribute__((device)) char* optixGetExceptionLineInfo()
{
    unsigned long long ptr;
    asm( "call (%0), _optix_get_exception_line_info, ();" : "=l"(ptr) : );
    return (char*)ptr;
}

template <typename ReturnT, typename... ArgTypes>
static __inline__ __attribute__((always_inline)) __attribute__((device)) ReturnT optixDirectCall( unsigned int sbtIndex, ArgTypes... args )
{
    unsigned long long func;
    asm( "call (%0), _optix_call_direct_callable,(%1);" : "=l"( func ) : "r"( sbtIndex ) : );
    using funcT = ReturnT ( * )( ArgTypes... );
    funcT call = ( funcT )( func );
    return call( args... );
}

template <typename ReturnT, typename... ArgTypes>
static __inline__ __attribute__((always_inline)) __attribute__((device)) ReturnT optixContinuationCall( unsigned int sbtIndex, ArgTypes... args )
{
    unsigned long long func;
    asm( "call (%0), _optix_call_continuation_callable,(%1);" : "=l"( func ) : "r"( sbtIndex ) : );
    using funcT = ReturnT ( * )( ArgTypes... );
    funcT call = ( funcT )( func );
    return call( args... );
}
# 894 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h" 2
# 44 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_device.h" 2
# 42 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix.h" 2
# 22 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h" 2





# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstddef" 1 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstddef" 3
       
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstddef" 3







# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 51 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstddef" 2 3


# 52 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstddef" 3
extern "C++"
{

namespace std
{

  using ::max_align_t;
}



namespace std
{




  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };

  template<> struct __byte_operand<wchar_t> { using __type = byte; };




  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };

  template<> struct __byte_operand<__int128>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __int128>
  { using __type = byte; };
# 110 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstddef" 3
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b << __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b >> __shift); }

  constexpr byte
  operator|(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }

  constexpr byte
  operator&(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }

  constexpr byte
  operator^(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }

  constexpr byte
  operator~(byte __b) noexcept
  { return (byte)(unsigned char)~(unsigned)__b; }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b << __shift; }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b >> __shift; }

  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  { return __l = __l | __r; }

  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  { return __l = __l & __r; }

  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  { return __l = __l ^ __r; }

  template<typename _IntegerType>
    [[nodiscard]]
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }


}

}
# 28 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h" 2
# 78 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"

# 78 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
typedef enum
  {





   OWL_MATRIX_FORMAT_COLUMN_MAJOR=0,




   OWL_MATRIX_FORMAT_OWL=OWL_MATRIX_FORMAT_COLUMN_MAJOR,




   OWL_MATRIX_FORMAT_ROW_MAJOR
  } OWLMatrixFormat;

typedef enum
  {
   OWL_SBT_HITGROUPS = 0x1,
   OWL_SBT_GEOMS = OWL_SBT_HITGROUPS,
   OWL_SBT_RAYGENS = 0x2,
   OWL_SBT_MISSPROGS = 0x4,
   OWL_SBT_ALL = 0x7
  } OWLBuildSBTFlags;

typedef enum
  {
   OWL_INVALID_TYPE = 0,

   OWL_BUFFER=10,

   OWL_BUFFER_SIZE,
   OWL_BUFFER_ID,
   OWL_BUFFER_POINTER,
   OWL_BUFPTR=OWL_BUFFER_POINTER,

   OWL_GROUP=20,





   OWL_DEVICE=30,


   OWL_TEXTURE=40,
   OWL_TEXTURE_2D=OWL_TEXTURE,




   _OWL_BEGIN_COPYABLE_TYPES = 1000,


   OWL_FLOAT=1000,
   OWL_FLOAT2,
   OWL_FLOAT3,
   OWL_FLOAT4,

   OWL_INT=1010,
   OWL_INT2,
   OWL_INT3,
   OWL_INT4,

   OWL_UINT=1020,
   OWL_UINT2,
   OWL_UINT3,
   OWL_UINT4,

   OWL_LONG=1030,
   OWL_LONG2,
   OWL_LONG3,
   OWL_LONG4,

   OWL_ULONG=1040,
   OWL_ULONG2,
   OWL_ULONG3,
   OWL_ULONG4,

   OWL_DOUBLE=1050,
   OWL_DOUBLE2,
   OWL_DOUBLE3,
   OWL_DOUBLE4,

   OWL_CHAR=1060,
   OWL_CHAR2,
   OWL_CHAR3,
   OWL_CHAR4,


   OWL_UCHAR=1070,
   OWL_UCHAR2,
   OWL_UCHAR3,
   OWL_UCHAR4,

   OWL_SHORT=1080,
   OWL_SHORT2,
   OWL_SHORT3,
   OWL_SHORT4,


   OWL_USHORT=1090,
   OWL_USHORT2,
   OWL_USHORT3,
   OWL_USHORT4,

   OWL_BOOL,
   OWL_BOOL2,
   OWL_BOOL3,
   OWL_BOOL4,







   OWL_RAW_POINTER=OWL_ULONG,
   OWL_BYTE = OWL_UCHAR,







   OWL_AFFINE3F=1300,





   OWL_USER_TYPE_BEGIN=10000
  }
  OWLDataType;



typedef enum
  {

   OWL_GEOMETRY_USER,

   OWL_GEOM_USER=OWL_GEOMETRY_USER,

   OWL_GEOMETRY_TRIANGLES,

   OWL_GEOM_TRIANGLES=OWL_GEOMETRY_TRIANGLES,
   OWL_TRIANGLES=OWL_GEOMETRY_TRIANGLES,
   OWL_GEOMETRY_HAIR
  }
  OWLGeomKind;




typedef float OWL_float;
typedef double OWL_double;
typedef int32_t OWL_int;
typedef uint32_t OWL_uint;
typedef int64_t OWL_long;
typedef uint64_t OWL_ulong;

typedef struct _OWL_int2 { int32_t x,y; } owl2i;
typedef struct _OWL_uint2 { int32_t x,y; } owl2ui;
typedef struct _OWL_long2 { int64_t x,y; } owl2l;
typedef struct _OWL_ulong2 { uint64_t x,y; } owl2ul;
typedef struct _OWL_float2 { float x,y; } owl2f;
typedef struct _OWL_double2 { double x,y; } owl2d;

typedef struct _OWL_int3 { int32_t x,y,z; } owl3i;
typedef struct _OWL_uint3 { uint32_t x,y,z; } owl3ui;
typedef struct _OWL_long3 { int64_t x,y,z; } owl3l;
typedef struct _OWL_ulong3 { uint64_t x,y,z; } owl3ul;
typedef struct _OWL_float3 { float x,y,z; } owl3f;
typedef struct _OWL_double3 { double x,y,z; } owl3d;

typedef struct _OWL_int4 { int32_t x,y,z,w; } owl4i;
typedef struct _OWL_uint4 { uint32_t x,y,z,w; } owl4ui;
typedef struct _OWL_long4 { int64_t x,y,z,w; } owl4l;
typedef struct _OWL_ulong4 { uint64_t x,y,z,w; } owl4ul;
typedef struct _OWL_float4 { float x,y,z,w; } owl4f;
typedef struct _OWL_double4 { double x,y,z,w; } owl4d;

typedef struct _OWL_affine3f { owl3f vx,vy,vz,t; } owl4x3f;

typedef struct _OWLVarDecl {
  const char *name;
  OWLDataType type;
  uint32_t offset;
} OWLVarDecl;



typedef enum {
  OWL_TEXEL_FORMAT_RGBA8,
  OWL_TEXEL_FORMAT_RGBA32F,
  OWL_TEXEL_FORMAT_R8,
  OWL_TEXEL_FORMAT_R32F
}
OWLTexelFormat;


typedef enum {
  OWL_TEXTURE_NEAREST,
  OWL_TEXTURE_LINEAR
}
OWLTextureFilterMode;


typedef enum {
  OWL_TEXTURE_WRAP,
  OWL_TEXTURE_CLAMP,
  OWL_TEXTURE_BORDER,
  OWL_TEXTURE_MIRROR
}
OWLTextureAddressMode;


typedef enum {
  OWL_COLOR_SPACE_LINEAR,
  OWL_COLOR_SPACE_SRGB
}
OWLTextureColorSpace;





typedef OptixTraversableHandle OWLDeviceTraversable;
typedef struct _OWLDeviceBuffer2D { void *d_pointer; owl2i dims; } OWLDeviceBuffer2D;


typedef struct _OWLContext *OWLContext;
typedef struct _OWLBuffer *OWLBuffer;
typedef struct _OWLTexture *OWLTexture;
typedef struct _OWLGeom *OWLGeom;
typedef struct _OWLGeomType *OWLGeomType;
typedef struct _OWLVariable *OWLVariable;
typedef struct _OWLModule *OWLModule;
typedef struct _OWLGroup *OWLGroup;
typedef struct _OWLRayGen *OWLRayGen;
typedef struct _OWLMissProg *OWLMissProg;
# 334 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
typedef struct _OWLLaunchParams *OWLLaunchParams, *OWLParams, *OWLGlobals;

extern "C" __attribute__((visibility("default"))) void owlBuildPrograms(OWLContext context, bool debug = false);
extern "C" __attribute__((visibility("default"))) void owlBuildPipeline(OWLContext context);
extern "C" __attribute__((visibility("default"))) void owlBuildSBT(OWLContext context,
                         OWLBuildSBTFlags flags =OWL_SBT_ALL);


extern "C" __attribute__((visibility("default"))) int32_t
owlGetDeviceCount(OWLContext context);
# 360 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) OWLContext
owlContextCreate(int32_t *requestedDeviceIDs =nullptr,
                 int numDevices =0);





extern "C" __attribute__((visibility("default"))) void
owlEnableMotionBlur(OWLContext _context);




extern "C" __attribute__((visibility("default"))) void
owlContextSetRayTypeCount(OWLContext context,
                          size_t numRayTypes);
# 400 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) void
owlSetMaxInstancingDepth(OWLContext context,
                         int32_t maxInstanceDepth);


extern "C" __attribute__((visibility("default"))) void
owlContextDestroy(OWLContext context);


extern "C" __attribute__((visibility("default"))) CUstream
owlContextGetStream(OWLContext context, int deviceID);


extern "C" __attribute__((visibility("default"))) OptixDeviceContext
owlContextGetOptixContext(OWLContext context, int deviceID);

extern "C" __attribute__((visibility("default"))) OWLModule
owlModuleCreate(OWLContext context,
                const char *ptxCode);

extern "C" __attribute__((visibility("default"))) OWLGeom
owlGeomCreate(OWLContext context,
              OWLGeomType type);

extern "C" __attribute__((visibility("default"))) OWLParams
owlParamsCreate(OWLContext context,
                size_t sizeOfVarStruct,
                OWLVarDecl *vars,
                int numVars);

extern "C" __attribute__((visibility("default"))) OWLRayGen
owlRayGenCreate(OWLContext context,
                OWLModule module,
                const char *programName,
                size_t sizeOfVarStruct,
                OWLVarDecl *vars,
                int numVars);
# 445 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) OWLMissProg
owlMissProgCreate(OWLContext context,
                  OWLModule module,
                  const char *programName,
                  size_t sizeOfVarStruct,
                  OWLVarDecl *vars,
                  int numVars);


extern "C" __attribute__((visibility("default"))) void
owlMissProgSet(OWLContext context,
               int rayType,
               OWLMissProg missProgToUse);
# 471 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) OWLGroup
owlUserGeomGroupCreate(OWLContext context,
                       size_t numGeometries,
                       OWLGeom *arrayOfChildGeoms);
# 489 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) OWLGroup
owlTrianglesGeomGroupCreate(OWLContext context,
                            size_t numGeometries,
                            OWLGeom *initValues);
# 508 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) OWLGroup
owlInstanceGroupCreate(OWLContext context,


                       size_t numInstances,







                       const OWLGroup *initGroups = nullptr,
# 532 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
                       const uint32_t *initInstanceIDs = nullptr,





                       const float *initTransforms = nullptr,
                       OWLMatrixFormat matrixFormat =OWL_MATRIX_FORMAT_OWL
                       );



extern "C" __attribute__((visibility("default"))) void owlGroupBuildAccel(OWLGroup group);
extern "C" __attribute__((visibility("default"))) void owlGroupRefitAccel(OWLGroup group);







extern "C" __attribute__((visibility("default"))) void owlGroupGetAccelSize(OWLGroup group,
                                  size_t *p_memFinal,
                                  size_t *p_memPeak);

extern "C" __attribute__((visibility("default"))) OWLGeomType
owlGeomTypeCreate(OWLContext context,
                  OWLGeomKind kind,
                  size_t sizeOfVarStruct,
                  OWLVarDecl *vars,
                  int numVars);






extern "C" __attribute__((visibility("default"))) OWLTexture
owlTexture2DCreate(OWLContext context,
                   OWLTexelFormat texelFormat,

                   uint32_t size_x,

                   uint32_t size_y,
                   const void *texels,
                   OWLTextureFilterMode filterMode =OWL_TEXTURE_LINEAR,
                   OWLTextureAddressMode addressMode =OWL_TEXTURE_CLAMP,
                   OWLTextureColorSpace colorSpace =OWL_COLOR_SPACE_LINEAR,


                   uint32_t linePitchInBytes =0
                   );



extern "C" __attribute__((visibility("default"))) CUtexObject
owlTextureGetObject(OWLTexture texture, int deviceID);


extern "C" __attribute__((visibility("default"))) void
owlTexture2DDestroy(OWLTexture texture);



extern "C" __attribute__((visibility("default"))) OWLBuffer
owlDeviceBufferCreate(OWLContext context,
                      OWLDataType type,
                      size_t count,
                      const void *init);




extern "C" __attribute__((visibility("default"))) OWLBuffer
owlHostPinnedBufferCreate(OWLContext context,
                          OWLDataType type,
                          size_t count);




extern "C" __attribute__((visibility("default"))) OWLBuffer
owlManagedMemoryBufferCreate(OWLContext context,
                             OWLDataType type,
                             size_t count,
                             const void *init);



extern "C" __attribute__((visibility("default"))) OWLBuffer
owlGraphicsBufferCreate(OWLContext context,
                        OWLDataType type,
                        size_t count,
                        cudaGraphicsResource_t resource);

extern "C" __attribute__((visibility("default"))) void
owlGraphicsBufferMap(OWLBuffer buffer);

extern "C" __attribute__((visibility("default"))) void
owlGraphicsBufferUnmap(OWLBuffer buffer);
# 641 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) const void *
owlBufferGetPointer(OWLBuffer buffer, int deviceID);

extern "C" __attribute__((visibility("default"))) OptixTraversableHandle
owlGroupGetTraversable(OWLGroup group, int deviceID);

extern "C" __attribute__((visibility("default"))) void
owlBufferResize(OWLBuffer buffer, size_t newItemCount);





extern "C" __attribute__((visibility("default"))) void
owlBufferDestroy(OWLBuffer buffer);




extern "C" __attribute__((visibility("default"))) void
owlBufferUpload(OWLBuffer buffer,
                const void *hostPtr,
                size_t offset =0,
                size_t numBytes =size_t(-1));




extern "C" __attribute__((visibility("default"))) void
owlRayGenLaunch2D(OWLRayGen rayGen, int dims_x, int dims_y);



extern "C" __attribute__((visibility("default"))) void
owlLaunch2D(OWLRayGen rayGen, int dims_x, int dims_y,
            OWLParams params);




extern "C" __attribute__((visibility("default"))) void
owlAsyncLaunch2D(OWLRayGen rayGen, int dims_x, int dims_y,
                 OWLParams params);



extern "C" __attribute__((visibility("default"))) void
owlAsyncLaunch2DOnDevice(OWLRayGen rayGen, int dims_x, int dims_y,
                        int deviceID, OWLParams params);


extern "C" __attribute__((visibility("default"))) CUstream
owlParamsGetCudaStream(OWLParams params, int deviceID);


extern "C" __attribute__((visibility("default"))) void
owlLaunchSync(OWLParams params);




extern "C" __attribute__((visibility("default"))) void owlTrianglesSetVertices(OWLGeom triangles,
                                     OWLBuffer vertices,
                                     size_t count,
                                     size_t stride,
                                     size_t offset);
extern "C" __attribute__((visibility("default"))) void owlTrianglesSetMotionVertices(OWLGeom triangles,







                                           size_t numKeys,
                                           OWLBuffer *vertexArrays,
                                           size_t count,
                                           size_t stride,
                                           size_t offset);
extern "C" __attribute__((visibility("default"))) void owlTrianglesSetIndices(OWLGeom triangles,
                                    OWLBuffer indices,
                                    size_t count,
                                    size_t stride,
                                    size_t offset);




extern "C" __attribute__((visibility("default"))) void
owlInstanceGroupSetChild(OWLGroup group,
                         int whichChild,
                         OWLGroup child);



extern "C" __attribute__((visibility("default"))) void
owlInstanceGroupSetTransform(OWLGroup group,
                             int whichChild,
                             const float *floats,
                             OWLMatrixFormat matrixFormat
                             =OWL_MATRIX_FORMAT_OWL);




extern "C" __attribute__((visibility("default"))) void
owlInstanceGroupSetTransforms(OWLGroup group,


                              uint32_t timeStep,
                              const float *floatsForThisStimeStep,
                              OWLMatrixFormat matrixFormat
                              =OWL_MATRIX_FORMAT_OWL);






extern "C" __attribute__((visibility("default"))) void
owlInstanceGroupSetInstanceIDs(OWLGroup group,
                               const uint32_t *instanceIDs);

extern "C" __attribute__((visibility("default"))) void
owlInstanceGroupSetVisibilityMasks(OWLGroup group,
                               const uint8_t *visibilityMasks);


extern "C" __attribute__((visibility("default"))) void
owlGeomTypeSetClosestHit(OWLGeomType type,
                         int rayType,
                         OWLModule module,
                         const char *progName);

extern "C" __attribute__((visibility("default"))) void
owlGeomTypeSetAnyHit(OWLGeomType type,
                     int rayType,
                     OWLModule module,
                     const char *progName);

extern "C" __attribute__((visibility("default"))) void
owlGeomTypeSetIntersectProg(OWLGeomType type,
                            int rayType,
                            OWLModule module,
                            const char *progName);

extern "C" __attribute__((visibility("default"))) void
owlGeomTypeSetBoundsProg(OWLGeomType type,
                         OWLModule module,
                         const char *progName);



extern "C" __attribute__((visibility("default"))) void
owlGeomSetPrimCount(OWLGeom geom,
                    size_t primCount);





extern "C" __attribute__((visibility("default"))) void owlGeomRelease(OWLGeom geometry);
extern "C" __attribute__((visibility("default"))) void owlVariableRelease(OWLVariable variable);
extern "C" __attribute__((visibility("default"))) void owlModuleRelease(OWLModule module);
extern "C" __attribute__((visibility("default"))) void owlBufferRelease(OWLBuffer buffer);
extern "C" __attribute__((visibility("default"))) void owlRayGenRelease(OWLRayGen rayGen);
extern "C" __attribute__((visibility("default"))) void owlGroupRelease(OWLGroup group);




extern "C" __attribute__((visibility("default"))) OWLVariable
owlGeomGetVariable(OWLGeom geom,
                   const char *varName);

extern "C" __attribute__((visibility("default"))) OWLVariable
owlRayGenGetVariable(OWLRayGen geom,
                     const char *varName);

extern "C" __attribute__((visibility("default"))) OWLVariable
owlMissProgGetVariable(OWLMissProg geom,
                       const char *varName);

extern "C" __attribute__((visibility("default"))) OWLVariable
owlParamsGetVariable(OWLParams object,
                     const char *varName);







extern "C" __attribute__((visibility("default"))) void owlVariableSet1b(OWLVariable var, bool val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2b(OWLVariable var, bool x, bool y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3b(OWLVariable var, bool x, bool y, bool z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4b(OWLVariable var, bool x, bool y, bool z, bool w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2bv(OWLVariable var, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3bv(OWLVariable var, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4bv(OWLVariable var, const bool *val);



extern "C" __attribute__((visibility("default"))) void owlVariableSet1c(OWLVariable var, int8_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2c(OWLVariable var, int8_t x, int8_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3c(OWLVariable var, int8_t x, int8_t y, int8_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4c(OWLVariable var, int8_t x, int8_t y, int8_t z, int8_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2cv(OWLVariable var, const int8_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3cv(OWLVariable var, const int8_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4cv(OWLVariable var, const int8_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1uc(OWLVariable var, uint8_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2uc(OWLVariable var, uint8_t x, uint8_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3uc(OWLVariable var, uint8_t x, uint8_t y, uint8_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4uc(OWLVariable var, uint8_t x, uint8_t y, uint8_t z, uint8_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2ucv(OWLVariable var, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3ucv(OWLVariable var, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4ucv(OWLVariable var, const uint8_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1s(OWLVariable var, int16_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2s(OWLVariable var, int16_t x, int16_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3s(OWLVariable var, int16_t x, int16_t y, int16_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4s(OWLVariable var, int16_t x, int16_t y, int16_t z, int16_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2sv(OWLVariable var, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3sv(OWLVariable var, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4sv(OWLVariable var, const int16_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1us(OWLVariable var, uint16_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2us(OWLVariable var, uint16_t x, uint16_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3us(OWLVariable var, uint16_t x, uint16_t y, uint16_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4us(OWLVariable var, uint16_t x, uint16_t y, uint16_t z, uint16_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2usv(OWLVariable var, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3usv(OWLVariable var, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4usv(OWLVariable var, const uint16_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1f(OWLVariable var, float val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2f(OWLVariable var, float x, float y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3f(OWLVariable var, float x, float y, float z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4f(OWLVariable var, float x, float y, float z, float w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2fv(OWLVariable var, const float *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3fv(OWLVariable var, const float *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4fv(OWLVariable var, const float *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1i(OWLVariable var, int32_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2i(OWLVariable var, int32_t x, int32_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3i(OWLVariable var, int32_t x, int32_t y, int32_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4i(OWLVariable var, int32_t x, int32_t y, int32_t z, int32_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2iv(OWLVariable var, const int32_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3iv(OWLVariable var, const int32_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4iv(OWLVariable var, const int32_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1ui(OWLVariable var, uint32_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2ui(OWLVariable var, uint32_t x, uint32_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3ui(OWLVariable var, uint32_t x, uint32_t y, uint32_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4ui(OWLVariable var, uint32_t x, uint32_t y, uint32_t z, uint32_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2uiv(OWLVariable var, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3uiv(OWLVariable var, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4uiv(OWLVariable var, const uint32_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1d(OWLVariable var, double val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2d(OWLVariable var, double x, double y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3d(OWLVariable var, double x, double y, double z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4d(OWLVariable var, double x, double y, double z, double w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2dv(OWLVariable var, const double *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3dv(OWLVariable var, const double *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4dv(OWLVariable var, const double *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1l(OWLVariable var, int64_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2l(OWLVariable var, int64_t x, int64_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3l(OWLVariable var, int64_t x, int64_t y, int64_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4l(OWLVariable var, int64_t x, int64_t y, int64_t z, int64_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2lv(OWLVariable var, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3lv(OWLVariable var, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4lv(OWLVariable var, const int64_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSet1ul(OWLVariable var, uint64_t val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2ul(OWLVariable var, uint64_t x, uint64_t y);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3ul(OWLVariable var, uint64_t x, uint64_t y, uint64_t z);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4ul(OWLVariable var, uint64_t x, uint64_t y, uint64_t z, uint64_t w);
extern "C" __attribute__((visibility("default"))) void owlVariableSet2ulv(OWLVariable var, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet3ulv(OWLVariable var, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlVariableSet4ulv(OWLVariable var, const uint64_t *val);


extern "C" __attribute__((visibility("default"))) void owlVariableSetGroup (OWLVariable variable, OWLGroup value);
extern "C" __attribute__((visibility("default"))) void owlVariableSetTexture(OWLVariable variable, OWLTexture value);
extern "C" __attribute__((visibility("default"))) void owlVariableSetBuffer (OWLVariable variable, OWLBuffer value);
extern "C" __attribute__((visibility("default"))) void owlVariableSetRaw (OWLVariable variable, const void *valuePtr);
extern "C" __attribute__((visibility("default"))) void owlVariableSetPointer(OWLVariable variable, const void *valuePtr);







extern "C" __attribute__((visibility("default"))) void owlRayGenSet1b(OWLRayGen var, const char *name, bool val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2b(OWLRayGen var, const char *name, bool x, bool y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3b(OWLRayGen var, const char *name, bool x, bool y, bool z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4b(OWLRayGen var, const char *name, bool x, bool y, bool z, bool w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2bv(OWLRayGen var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3bv(OWLRayGen var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4bv(OWLRayGen var, const char *name, const bool *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1b(OWLMissProg var, const char *name, bool val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2b(OWLMissProg var, const char *name, bool x, bool y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3b(OWLMissProg var, const char *name, bool x, bool y, bool z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4b(OWLMissProg var, const char *name, bool x, bool y, bool z, bool w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2bv(OWLMissProg var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3bv(OWLMissProg var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4bv(OWLMissProg var, const char *name, const bool *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1b(OWLGeom var, const char *name, bool val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2b(OWLGeom var, const char *name, bool x, bool y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3b(OWLGeom var, const char *name, bool x, bool y, bool z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4b(OWLGeom var, const char *name, bool x, bool y, bool z, bool w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2bv(OWLGeom var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3bv(OWLGeom var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4bv(OWLGeom var, const char *name, const bool *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1b(OWLParams var, const char *name, bool val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2b(OWLParams var, const char *name, bool x, bool y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3b(OWLParams var, const char *name, bool x, bool y, bool z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4b(OWLParams var, const char *name, bool x, bool y, bool z, bool w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2bv(OWLParams var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3bv(OWLParams var, const char *name, const bool *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4bv(OWLParams var, const char *name, const bool *val);







extern "C" __attribute__((visibility("default"))) void owlRayGenSet1c(OWLRayGen obj, const char *name, char val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2c(OWLRayGen obj, const char *name, char x, char y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3c(OWLRayGen obj, const char *name, char x, char y, char z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4c(OWLRayGen obj, const char *name, char x, char y, char z, char w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2cv(OWLRayGen obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3cv(OWLRayGen obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4cv(OWLRayGen obj, const char *name, const char *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1c(OWLMissProg obj, const char *name, char val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2c(OWLMissProg obj, const char *name, char x, char y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3c(OWLMissProg obj, const char *name, char x, char y, char z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4c(OWLMissProg obj, const char *name, char x, char y, char z, char w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2cv(OWLMissProg obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3cv(OWLMissProg obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4cv(OWLMissProg obj, const char *name, const char *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1c(OWLGeom obj, const char *name, char val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2c(OWLGeom obj, const char *name, char x, char y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3c(OWLGeom obj, const char *name, char x, char y, char z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4c(OWLGeom obj, const char *name, char x, char y, char z, char w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2cv(OWLGeom obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3cv(OWLGeom obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4cv(OWLGeom obj, const char *name, const char *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1c(OWLParams obj, const char *name, char val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2c(OWLParams obj, const char *name, char x, char y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3c(OWLParams obj, const char *name, char x, char y, char z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4c(OWLParams obj, const char *name, char x, char y, char z, char w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2cv(OWLParams obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3cv(OWLParams obj, const char *name, const char *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4cv(OWLParams obj, const char *name, const char *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1uc(OWLRayGen obj, const char *name, uint8_t val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2uc(OWLRayGen obj, const char *name, uint8_t x, uint8_t y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3uc(OWLRayGen obj, const char *name, uint8_t x, uint8_t y, uint8_t z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4uc(OWLRayGen obj, const char *name, uint8_t x, uint8_t y, uint8_t z, uint8_t w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2ucv(OWLRayGen obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3ucv(OWLRayGen obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4ucv(OWLRayGen obj, const char *name, const uint8_t *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1uc(OWLMissProg obj, const char *name, uint8_t val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2uc(OWLMissProg obj, const char *name, uint8_t x, uint8_t y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3uc(OWLMissProg obj, const char *name, uint8_t x, uint8_t y, uint8_t z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4uc(OWLMissProg obj, const char *name, uint8_t x, uint8_t y, uint8_t z, uint8_t w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2ucv(OWLMissProg obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3ucv(OWLMissProg obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4ucv(OWLMissProg obj, const char *name, const uint8_t *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1uc(OWLGeom obj, const char *name, uint8_t val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2uc(OWLGeom obj, const char *name, uint8_t x, uint8_t y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3uc(OWLGeom obj, const char *name, uint8_t x, uint8_t y, uint8_t z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4uc(OWLGeom obj, const char *name, uint8_t x, uint8_t y, uint8_t z, uint8_t w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2ucv(OWLGeom obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3ucv(OWLGeom obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4ucv(OWLGeom obj, const char *name, const uint8_t *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1uc(OWLParams obj, const char *name, uint8_t val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2uc(OWLParams obj, const char *name, uint8_t x, uint8_t y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3uc(OWLParams obj, const char *name, uint8_t x, uint8_t y, uint8_t z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4uc(OWLParams obj, const char *name, uint8_t x, uint8_t y, uint8_t z, uint8_t w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2ucv(OWLParams obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3ucv(OWLParams obj, const char *name, const uint8_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4ucv(OWLParams obj, const char *name, const uint8_t *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1s(OWLRayGen obj, const char *name, int16_t val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2s(OWLRayGen obj, const char *name, int16_t x, int16_t y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3s(OWLRayGen obj, const char *name, int16_t x, int16_t y, int16_t z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4s(OWLRayGen obj, const char *name, int16_t x, int16_t y, int16_t z, int16_t w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2sv(OWLRayGen obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3sv(OWLRayGen obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4sv(OWLRayGen obj, const char *name, const int16_t *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1s(OWLMissProg obj, const char *name, int16_t val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2s(OWLMissProg obj, const char *name, int16_t x, int16_t y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3s(OWLMissProg obj, const char *name, int16_t x, int16_t y, int16_t z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4s(OWLMissProg obj, const char *name, int16_t x, int16_t y, int16_t z, int16_t w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2sv(OWLMissProg obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3sv(OWLMissProg obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4sv(OWLMissProg obj, const char *name, const int16_t *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1s(OWLGeom obj, const char *name, int16_t val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2s(OWLGeom obj, const char *name, int16_t x, int16_t y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3s(OWLGeom obj, const char *name, int16_t x, int16_t y, int16_t z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4s(OWLGeom obj, const char *name, int16_t x, int16_t y, int16_t z, int16_t w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2sv(OWLGeom obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3sv(OWLGeom obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4sv(OWLGeom obj, const char *name, const int16_t *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1s(OWLParams obj, const char *name, int16_t val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2s(OWLParams obj, const char *name, int16_t x, int16_t y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3s(OWLParams obj, const char *name, int16_t x, int16_t y, int16_t z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4s(OWLParams obj, const char *name, int16_t x, int16_t y, int16_t z, int16_t w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2sv(OWLParams obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3sv(OWLParams obj, const char *name, const int16_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4sv(OWLParams obj, const char *name, const int16_t *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1us(OWLRayGen obj, const char *name, uint16_t val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2us(OWLRayGen obj, const char *name, uint16_t x, uint16_t y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3us(OWLRayGen obj, const char *name, uint16_t x, uint16_t y, uint16_t z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4us(OWLRayGen obj, const char *name, uint16_t x, uint16_t y, uint16_t z, uint16_t w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2usv(OWLRayGen obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3usv(OWLRayGen obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4usv(OWLRayGen obj, const char *name, const uint16_t *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1us(OWLMissProg obj, const char *name, uint16_t val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2us(OWLMissProg obj, const char *name, uint16_t x, uint16_t y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3us(OWLMissProg obj, const char *name, uint16_t x, uint16_t y, uint16_t z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4us(OWLMissProg obj, const char *name, uint16_t x, uint16_t y, uint16_t z, uint16_t w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2usv(OWLMissProg obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3usv(OWLMissProg obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4usv(OWLMissProg obj, const char *name, const uint16_t *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1us(OWLGeom obj, const char *name, uint16_t val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2us(OWLGeom obj, const char *name, uint16_t x, uint16_t y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3us(OWLGeom obj, const char *name, uint16_t x, uint16_t y, uint16_t z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4us(OWLGeom obj, const char *name, uint16_t x, uint16_t y, uint16_t z, uint16_t w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2usv(OWLGeom obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3usv(OWLGeom obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4usv(OWLGeom obj, const char *name, const uint16_t *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1us(OWLParams obj, const char *name, uint16_t val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2us(OWLParams obj, const char *name, uint16_t x, uint16_t y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3us(OWLParams obj, const char *name, uint16_t x, uint16_t y, uint16_t z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4us(OWLParams obj, const char *name, uint16_t x, uint16_t y, uint16_t z, uint16_t w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2usv(OWLParams obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3usv(OWLParams obj, const char *name, const uint16_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4usv(OWLParams obj, const char *name, const uint16_t *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1i(OWLRayGen obj, const char *name, int val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2i(OWLRayGen obj, const char *name, int x, int y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3i(OWLRayGen obj, const char *name, int x, int y, int z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4i(OWLRayGen obj, const char *name, int x, int y, int z, int w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2iv(OWLRayGen obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3iv(OWLRayGen obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4iv(OWLRayGen obj, const char *name, const int *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1i(OWLMissProg obj, const char *name, int val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2i(OWLMissProg obj, const char *name, int x, int y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3i(OWLMissProg obj, const char *name, int x, int y, int z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4i(OWLMissProg obj, const char *name, int x, int y, int z, int w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2iv(OWLMissProg obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3iv(OWLMissProg obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4iv(OWLMissProg obj, const char *name, const int *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1i(OWLGeom obj, const char *name, int val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2i(OWLGeom obj, const char *name, int x, int y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3i(OWLGeom obj, const char *name, int x, int y, int z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4i(OWLGeom obj, const char *name, int x, int y, int z, int w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2iv(OWLGeom obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3iv(OWLGeom obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4iv(OWLGeom obj, const char *name, const int *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1i(OWLParams obj, const char *name, int val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2i(OWLParams obj, const char *name, int x, int y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3i(OWLParams obj, const char *name, int x, int y, int z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4i(OWLParams obj, const char *name, int x, int y, int z, int w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2iv(OWLParams obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3iv(OWLParams obj, const char *name, const int *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4iv(OWLParams obj, const char *name, const int *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1ui(OWLRayGen obj, const char *name, uint32_t val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2ui(OWLRayGen obj, const char *name, uint32_t x, uint32_t y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3ui(OWLRayGen obj, const char *name, uint32_t x, uint32_t y, uint32_t z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4ui(OWLRayGen obj, const char *name, uint32_t x, uint32_t y, uint32_t z, uint32_t w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2uiv(OWLRayGen obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3uiv(OWLRayGen obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4uiv(OWLRayGen obj, const char *name, const uint32_t *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1ui(OWLMissProg obj, const char *name, uint32_t val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2ui(OWLMissProg obj, const char *name, uint32_t x, uint32_t y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3ui(OWLMissProg obj, const char *name, uint32_t x, uint32_t y, uint32_t z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4ui(OWLMissProg obj, const char *name, uint32_t x, uint32_t y, uint32_t z, uint32_t w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2uiv(OWLMissProg obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3uiv(OWLMissProg obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4uiv(OWLMissProg obj, const char *name, const uint32_t *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1ui(OWLGeom obj, const char *name, uint32_t val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2ui(OWLGeom obj, const char *name, uint32_t x, uint32_t y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3ui(OWLGeom obj, const char *name, uint32_t x, uint32_t y, uint32_t z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4ui(OWLGeom obj, const char *name, uint32_t x, uint32_t y, uint32_t z, uint32_t w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2uiv(OWLGeom obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3uiv(OWLGeom obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4uiv(OWLGeom obj, const char *name, const uint32_t *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1ui(OWLParams obj, const char *name, uint32_t val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2ui(OWLParams obj, const char *name, uint32_t x, uint32_t y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3ui(OWLParams obj, const char *name, uint32_t x, uint32_t y, uint32_t z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4ui(OWLParams obj, const char *name, uint32_t x, uint32_t y, uint32_t z, uint32_t w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2uiv(OWLParams obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3uiv(OWLParams obj, const char *name, const uint32_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4uiv(OWLParams obj, const char *name, const uint32_t *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1f(OWLRayGen obj, const char *name, float val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2f(OWLRayGen obj, const char *name, float x, float y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3f(OWLRayGen obj, const char *name, float x, float y, float z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4f(OWLRayGen obj, const char *name, float x, float y, float z, float w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2fv(OWLRayGen obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3fv(OWLRayGen obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4fv(OWLRayGen obj, const char *name, const float *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1f(OWLMissProg obj, const char *name, float val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2f(OWLMissProg obj, const char *name, float x, float y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3f(OWLMissProg obj, const char *name, float x, float y, float z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4f(OWLMissProg obj, const char *name, float x, float y, float z, float w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2fv(OWLMissProg obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3fv(OWLMissProg obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4fv(OWLMissProg obj, const char *name, const float *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1f(OWLGeom obj, const char *name, float val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2f(OWLGeom obj, const char *name, float x, float y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3f(OWLGeom obj, const char *name, float x, float y, float z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4f(OWLGeom obj, const char *name, float x, float y, float z, float w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2fv(OWLGeom obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3fv(OWLGeom obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4fv(OWLGeom obj, const char *name, const float *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1f(OWLParams obj, const char *name, float val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2f(OWLParams obj, const char *name, float x, float y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3f(OWLParams obj, const char *name, float x, float y, float z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4f(OWLParams obj, const char *name, float x, float y, float z, float w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2fv(OWLParams obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3fv(OWLParams obj, const char *name, const float *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4fv(OWLParams obj, const char *name, const float *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1d(OWLRayGen obj, const char *name, double val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2d(OWLRayGen obj, const char *name, double x, double y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3d(OWLRayGen obj, const char *name, double x, double y, double z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4d(OWLRayGen obj, const char *name, double x, double y, double z, double w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2dv(OWLRayGen obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3dv(OWLRayGen obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4dv(OWLRayGen obj, const char *name, const double *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1d(OWLMissProg obj, const char *name, double val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2d(OWLMissProg obj, const char *name, double x, double y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3d(OWLMissProg obj, const char *name, double x, double y, double z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4d(OWLMissProg obj, const char *name, double x, double y, double z, double w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2dv(OWLMissProg obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3dv(OWLMissProg obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4dv(OWLMissProg obj, const char *name, const double *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1d(OWLGeom obj, const char *name, double val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2d(OWLGeom obj, const char *name, double x, double y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3d(OWLGeom obj, const char *name, double x, double y, double z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4d(OWLGeom obj, const char *name, double x, double y, double z, double w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2dv(OWLGeom obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3dv(OWLGeom obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4dv(OWLGeom obj, const char *name, const double *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1d(OWLParams obj, const char *name, double val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2d(OWLParams obj, const char *name, double x, double y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3d(OWLParams obj, const char *name, double x, double y, double z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4d(OWLParams obj, const char *name, double x, double y, double z, double w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2dv(OWLParams obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3dv(OWLParams obj, const char *name, const double *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4dv(OWLParams obj, const char *name, const double *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1l(OWLRayGen obj, const char *name, int64_t val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2l(OWLRayGen obj, const char *name, int64_t x, int64_t y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3l(OWLRayGen obj, const char *name, int64_t x, int64_t y, int64_t z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4l(OWLRayGen obj, const char *name, int64_t x, int64_t y, int64_t z, int64_t w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2lv(OWLRayGen obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3lv(OWLRayGen obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4lv(OWLRayGen obj, const char *name, const int64_t *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1l(OWLMissProg obj, const char *name, int64_t val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2l(OWLMissProg obj, const char *name, int64_t x, int64_t y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3l(OWLMissProg obj, const char *name, int64_t x, int64_t y, int64_t z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4l(OWLMissProg obj, const char *name, int64_t x, int64_t y, int64_t z, int64_t w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2lv(OWLMissProg obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3lv(OWLMissProg obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4lv(OWLMissProg obj, const char *name, const int64_t *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1l(OWLGeom obj, const char *name, int64_t val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2l(OWLGeom obj, const char *name, int64_t x, int64_t y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3l(OWLGeom obj, const char *name, int64_t x, int64_t y, int64_t z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4l(OWLGeom obj, const char *name, int64_t x, int64_t y, int64_t z, int64_t w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2lv(OWLGeom obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3lv(OWLGeom obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4lv(OWLGeom obj, const char *name, const int64_t *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1l(OWLParams obj, const char *name, int64_t val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2l(OWLParams obj, const char *name, int64_t x, int64_t y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3l(OWLParams obj, const char *name, int64_t x, int64_t y, int64_t z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4l(OWLParams obj, const char *name, int64_t x, int64_t y, int64_t z, int64_t w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2lv(OWLParams obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3lv(OWLParams obj, const char *name, const int64_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4lv(OWLParams obj, const char *name, const int64_t *val);






extern "C" __attribute__((visibility("default"))) void owlRayGenSet1ul(OWLRayGen obj, const char *name, uint64_t val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2ul(OWLRayGen obj, const char *name, uint64_t x, uint64_t y);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3ul(OWLRayGen obj, const char *name, uint64_t x, uint64_t y, uint64_t z);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4ul(OWLRayGen obj, const char *name, uint64_t x, uint64_t y, uint64_t z, uint64_t w);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet2ulv(OWLRayGen obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet3ulv(OWLRayGen obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSet4ulv(OWLRayGen obj, const char *name, const uint64_t *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSet1ul(OWLMissProg obj, const char *name, uint64_t val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2ul(OWLMissProg obj, const char *name, uint64_t x, uint64_t y);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3ul(OWLMissProg obj, const char *name, uint64_t x, uint64_t y, uint64_t z);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4ul(OWLMissProg obj, const char *name, uint64_t x, uint64_t y, uint64_t z, uint64_t w);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet2ulv(OWLMissProg obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet3ulv(OWLMissProg obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSet4ulv(OWLMissProg obj, const char *name, const uint64_t *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSet1ul(OWLGeom obj, const char *name, uint64_t val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2ul(OWLGeom obj, const char *name, uint64_t x, uint64_t y);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3ul(OWLGeom obj, const char *name, uint64_t x, uint64_t y, uint64_t z);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4ul(OWLGeom obj, const char *name, uint64_t x, uint64_t y, uint64_t z, uint64_t w);
extern "C" __attribute__((visibility("default"))) void owlGeomSet2ulv(OWLGeom obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet3ulv(OWLGeom obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSet4ulv(OWLGeom obj, const char *name, const uint64_t *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSet1ul(OWLParams obj, const char *name, uint64_t val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2ul(OWLParams obj, const char *name, uint64_t x, uint64_t y);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3ul(OWLParams obj, const char *name, uint64_t x, uint64_t y, uint64_t z);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4ul(OWLParams obj, const char *name, uint64_t x, uint64_t y, uint64_t z, uint64_t w);
extern "C" __attribute__((visibility("default"))) void owlParamsSet2ulv(OWLParams obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet3ulv(OWLParams obj, const char *name, const uint64_t *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSet4ulv(OWLParams obj, const char *name, const uint64_t *val);
# 1389 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_host.h"
extern "C" __attribute__((visibility("default"))) void owlRayGenSetTexture(OWLRayGen obj, const char *name, OWLTexture val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSetPointer(OWLRayGen obj, const char *name, const void *val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSetBuffer(OWLRayGen obj, const char *name, OWLBuffer val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSetGroup(OWLRayGen obj, const char *name, OWLGroup val);
extern "C" __attribute__((visibility("default"))) void owlRayGenSetRaw(OWLRayGen obj, const char *name, const void *val);


extern "C" __attribute__((visibility("default"))) void owlGeomSetTexture(OWLGeom obj, const char *name, OWLTexture val);
extern "C" __attribute__((visibility("default"))) void owlGeomSetPointer(OWLGeom obj, const char *name, const void *val);
extern "C" __attribute__((visibility("default"))) void owlGeomSetBuffer(OWLGeom obj, const char *name, OWLBuffer val);
extern "C" __attribute__((visibility("default"))) void owlGeomSetGroup(OWLGeom obj, const char *name, OWLGroup val);
extern "C" __attribute__((visibility("default"))) void owlGeomSetRaw(OWLGeom obj, const char *name, const void *val);


extern "C" __attribute__((visibility("default"))) void owlParamsSetTexture(OWLParams obj, const char *name, OWLTexture val);
extern "C" __attribute__((visibility("default"))) void owlParamsSetPointer(OWLParams obj, const char *name, const void *val);
extern "C" __attribute__((visibility("default"))) void owlParamsSetBuffer(OWLParams obj, const char *name, OWLBuffer val);
extern "C" __attribute__((visibility("default"))) void owlParamsSetGroup(OWLParams obj, const char *name, OWLGroup val);
extern "C" __attribute__((visibility("default"))) void owlParamsSetRaw(OWLParams obj, const char *name, const void *val);


extern "C" __attribute__((visibility("default"))) void owlMissProgSetTexture(OWLMissProg obj, const char *name, OWLTexture val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSetPointer(OWLMissProg obj, const char *name, const void *val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSetBuffer(OWLMissProg obj, const char *name, OWLBuffer val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSetGroup(OWLMissProg obj, const char *name, OWLGroup val);
extern "C" __attribute__((visibility("default"))) void owlMissProgSetRaw(OWLMissProg obj, const char *name, const void *val);







inline void owlParamsSet2i(OWLParams obj, const char *name, const owl2i &val)
{ owlParamsSet2i(obj,name,val.x,val.y); }
inline void owlParamsSet3i(OWLParams obj, const char *name, const owl3i &val)
{ owlParamsSet3i(obj,name,val.x,val.y,val.z); }
inline void owlParamsSet4i(OWLParams obj, const char *name, const owl4i &val)
{ owlParamsSet4i(obj,name,val.x,val.y,val.z,val.w); }

inline void owlParamsSet2ui(OWLParams obj, const char *name, const owl2ui &val)
{ owlParamsSet2ui(obj,name,val.x,val.y); }
inline void owlParamsSet3ui(OWLParams obj, const char *name, const owl3ui &val)
{ owlParamsSet3ui(obj,name,val.x,val.y,val.z); }
inline void owlParamsSet4ui(OWLParams obj, const char *name, const owl4ui &val)
{ owlParamsSet4ui(obj,name,val.x,val.y,val.z,val.w); }

inline void owlParamsSet2f(OWLParams obj, const char *name, const owl2f &val)
{ owlParamsSet2f(obj,name,val.x,val.y); }
inline void owlParamsSet3f(OWLParams obj, const char *name, const owl3f &val)
{ owlParamsSet3f(obj,name,val.x,val.y,val.z); }
inline void owlParamsSet4f(OWLParams obj, const char *name, const owl4f &val)
{ owlParamsSet4f(obj,name,val.x,val.y,val.z,val.w); }


inline void owlGeomSet2i(OWLGeom obj, const char *name, const owl2i &val)
{ owlGeomSet2i(obj,name,val.x,val.y); }
inline void owlGeomSet3i(OWLGeom obj, const char *name, const owl3i &val)
{ owlGeomSet3i(obj,name,val.x,val.y,val.z); }
inline void owlGeomSet4i(OWLGeom obj, const char *name, const owl4i &val)
{ owlGeomSet4i(obj,name,val.x,val.y,val.z,val.w); }

inline void owlGeomSet2ui(OWLGeom obj, const char *name, const owl2ui &val)
{ owlGeomSet2ui(obj,name,val.x,val.y); }
inline void owlGeomSet3ui(OWLGeom obj, const char *name, const owl3ui &val)
{ owlGeomSet3ui(obj,name,val.x,val.y,val.z); }
inline void owlGeomSet4ui(OWLGeom obj, const char *name, const owl4ui &val)
{ owlGeomSet4ui(obj,name,val.x,val.y,val.z,val.w); }

inline void owlGeomSet2f(OWLGeom obj, const char *name, const owl2f &val)
{ owlGeomSet2f(obj,name,val.x,val.y); }
inline void owlGeomSet3f(OWLGeom obj, const char *name, const owl3f &val)
{ owlGeomSet3f(obj,name,val.x,val.y,val.z); }
inline void owlGeomSet4f(OWLGeom obj, const char *name, const owl4f &val)
{ owlGeomSet4f(obj,name,val.x,val.y,val.z,val.w); }


inline void owlMissProgSet2i(OWLMissProg obj, const char *name, const owl2i &val)
{ owlMissProgSet2i(obj,name,val.x,val.y); }
inline void owlMissProgSet3i(OWLMissProg obj, const char *name, const owl3i &val)
{ owlMissProgSet3i(obj,name,val.x,val.y,val.z); }
inline void owlMissProgSet4i(OWLMissProg obj, const char *name, const owl4i &val)
{ owlMissProgSet4i(obj,name,val.x,val.y,val.z,val.w); }

inline void owlMissProgSet2ui(OWLMissProg obj, const char *name, const owl2ui &val)
{ owlMissProgSet2ui(obj,name,val.x,val.y); }
inline void owlMissProgSet3ui(OWLMissProg obj, const char *name, const owl3ui &val)
{ owlMissProgSet3ui(obj,name,val.x,val.y,val.z); }
inline void owlMissProgSet4ui(OWLMissProg obj, const char *name, const owl4ui &val)
{ owlMissProgSet4ui(obj,name,val.x,val.y,val.z,val.w); }

inline void owlMissProgSet2f(OWLMissProg obj, const char *name, const owl2f &val)
{ owlMissProgSet2f(obj,name,val.x,val.y); }
inline void owlMissProgSet3f(OWLMissProg obj, const char *name, const owl3f &val)
{ owlMissProgSet3f(obj,name,val.x,val.y,val.z); }
inline void owlMissProgSet4f(OWLMissProg obj, const char *name, const owl4f &val)
{ owlMissProgSet4f(obj,name,val.x,val.y,val.z,val.w); }


inline void owlRayGenSet2i(OWLRayGen obj, const char *name, const owl2i &val)
{ owlRayGenSet2i(obj,name,val.x,val.y); }
inline void owlRayGenSet3i(OWLRayGen obj, const char *name, const owl3i &val)
{ owlRayGenSet3i(obj,name,val.x,val.y,val.z); }
inline void owlRayGenSet4i(OWLRayGen obj, const char *name, const owl4i &val)
{ owlRayGenSet4i(obj,name,val.x,val.y,val.z,val.w); }

inline void owlRayGenSet2ui(OWLRayGen obj, const char *name, const owl2ui &val)
{ owlRayGenSet2ui(obj,name,val.x,val.y); }
inline void owlRayGenSet3ui(OWLRayGen obj, const char *name, const owl3ui &val)
{ owlRayGenSet3ui(obj,name,val.x,val.y,val.z); }
inline void owlRayGenSet4ui(OWLRayGen obj, const char *name, const owl4ui &val)
{ owlRayGenSet4ui(obj,name,val.x,val.y,val.z,val.w); }

inline void owlRayGenSet2f(OWLRayGen obj, const char *name, const owl2f &val)
{ owlRayGenSet2f(obj,name,val.x,val.y); }
inline void owlRayGenSet3f(OWLRayGen obj, const char *name, const owl3f &val)
{ owlRayGenSet3f(obj,name,val.x,val.y,val.z); }
inline void owlRayGenSet4f(OWLRayGen obj, const char *name, const owl4f &val)
{ owlRayGenSet4f(obj,name,val.x,val.y,val.z,val.w); }





  inline void
  owlInstanceGroupSetTransform(OWLGroup group,
                               int childID,
                               const owl4x3f &xfm)
  {
    owlInstanceGroupSetTransform(group,childID,(const float *)&xfm,
                                 OWL_MATRIX_FORMAT_OWL);
  }


inline void
owlInstanceGroupSetTransform(OWLGroup group,
                             int childID,
                             const owl4x3f *xfm)
{
  owlInstanceGroupSetTransform(group,childID,(const float *)xfm,
                               OWL_MATRIX_FORMAT_OWL);
}
# 24 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl.h" 2




# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device.h"
       

# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
       

# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"
       




# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 1 3
# 23 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iostream" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iostream" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iostream" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iosfwd" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iosfwd" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iosfwd" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stringfwd.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stringfwd.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stringfwd.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/memoryfwd.h" 1 3
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/memoryfwd.h" 3
       
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/memoryfwd.h" 3




# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/memoryfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;



  template<typename, typename>
    struct uses_allocator;

  template<typename>
    struct allocator_traits;





}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;







  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

}


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;
# 93 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stringfwd.h" 3
  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iosfwd" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 1 3
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
       
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 39 "/usr/include/wchar.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stdarg.h" 1 3 4
# 40 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 350 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;






# 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 306 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();

# 405 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 530 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 680 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 736 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 801 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 827 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 837 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 891 "/usr/include/wchar.h" 3 4
}
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 2 3
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3

}
}







namespace __gnu_cxx
{





  using ::wcstold;
# 260 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 280 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 2 3
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      fpos(const fpos&) = default;
      fpos& operator=(const fpos&) = default;
      ~fpos() = default;



      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 245 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/postypes.h" 3
  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 3

#pragma GCC visibility push(default)




extern "C++" {

namespace std
{
# 53 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 3
  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 108 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 3
  __attribute__ ((__deprecated__ ("use '" "std::uncaught_exceptions()" "' instead")))
  bool uncaught_exception() noexcept __attribute__ ((__pure__));







  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 143 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 1 3
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_init_exception.h" 1 3
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_init_exception.h" 3
       
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_init_exception.h" 2 3
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hash_bytes.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hash_bytes.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }



    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 2 3
# 52 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 3
extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(nullptr)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = nullptr; }
# 128 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 3
      explicit operator bool() const noexcept
      { return _M_exception_object; }







      friend bool
      operator==(const exception_ptr& __x, const exception_ptr& __y)
      noexcept
      { return __x._M_exception_object == __y._M_exception_object; }

      friend bool
      operator!=(const exception_ptr& __x, const exception_ptr& __y)
      noexcept
      { return __x._M_exception_object != __y._M_exception_object; }


      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

   
    inline
    exception_ptr::exception_ptr() noexcept
    : _M_exception_object(0)
    { }

   
    inline
    exception_ptr::exception_ptr(const exception_ptr& __other)
    noexcept
    : _M_exception_object(__other._M_exception_object)
    {
      if (_M_exception_object)
 _M_addref();
    }

   
    inline
    exception_ptr::~exception_ptr() noexcept
    {
      if (_M_exception_object)
 _M_release();
    }

   
    inline exception_ptr&
    exception_ptr::operator=(const exception_ptr& __other) noexcept
    {
      exception_ptr(__other).swap(*this);
      return *this;
    }

   
    inline void
    exception_ptr::swap(exception_ptr &__other) noexcept
    {
      void *__tmp = _M_exception_object;
      _M_exception_object = __other._M_exception_object;
      __other._M_exception_object = __tmp;
    }


    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }


    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {


      using _Ex2 = typename remove_reference<_Ex>::type;
      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(_Ex)),
   __exception_ptr::__dest_thunk<_Ex2>);
      try
 {
   ::new (__e) _Ex2(std::forward<_Ex>(__ex));
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 269 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/exception_ptr.h" 3
    }




}

}

#pragma GCC visibility pop
# 154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/nested_exception.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/exception" 2 3
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 2 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 2 3
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 89 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;




      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
# 233 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
      __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
      return __s1;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 283 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
  template<typename _CharT>
    inline __attribute__((__always_inline__)) constexpr bool
    __constant_string_p(const _CharT* __s)
    {

      (void) __s;

      return __builtin_is_constant_evaluated();





    }
# 306 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
  template<typename _CharT>
    inline __attribute__((__always_inline__)) constexpr bool
    __constant_char_array_p(const _CharT* __a, size_t __n)
    {

      (void) __a;
      (void) __n;

      return __builtin_is_constant_evaluated();






    }
# 337 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;




      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   {
     for (size_t __i = 0; __i < __n; ++__i)
       if (lt(__s1[__i], __s2[__i]))
  return -1;
       else if (lt(__s2[__i], __s1[__i]))
  return 1;
     return 0;
   }

 return __builtin_memcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return __builtin_strlen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;




 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;




      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 return wmemcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return wcslen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;




 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
# 722 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3

}



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdint" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdint" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdint" 3
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdint" 3
namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 728 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;

      typedef uint_least16_t int_type;





      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;




      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;

      typedef uint_least32_t int_type;





      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;




      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };
# 980 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/char_traits.h" 3

}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/localefwd.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/localefwd.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/localefwd.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/clocale" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/clocale" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/clocale" 2 3
# 51 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/localefwd.h" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 29 "/usr/include/ctype.h" 3 4
extern "C" {
# 47 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 80 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 105 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 272 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 348 "/usr/include/ctype.h" 3 4
}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 2 3
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  struct ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;


  template<> class codecvt<char16_t, char, mbstate_t>;
  template<> class codecvt<char32_t, char, mbstate_t>;





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  struct messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/atomicity.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/atomicity.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/atomicity.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 42 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 73 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 119 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 202 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 43 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 117 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 116 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 157 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 192 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 230 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 488 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 500 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 534 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 736 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 800 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 882 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 994 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1038 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1105 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1139 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1153 "/usr/include/pthread.h" 3 4
}
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 102 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once"), __copy__ (pthread_once)));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific"), __copy__ (pthread_getspecific)));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific"), __copy__ (pthread_setspecific)));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create"), __copy__ (pthread_create)));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join"), __copy__ (pthread_join)));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal"), __copy__ (pthread_equal)));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self"), __copy__ (pthread_self)));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach"), __copy__ (pthread_detach)));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel"), __copy__ (pthread_cancel)));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield"), __copy__ (sched_yield)));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock"), __copy__ (pthread_mutex_lock)));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock"), __copy__ (pthread_mutex_trylock)));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock"), __copy__ (pthread_mutex_timedlock)));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock"), __copy__ (pthread_mutex_unlock)));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init"), __copy__ (pthread_mutex_init)));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy"), __copy__ (pthread_mutex_destroy)));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init"), __copy__ (pthread_cond_init)));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast"), __copy__ (pthread_cond_broadcast)));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal"), __copy__ (pthread_cond_signal)));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait"), __copy__ (pthread_cond_wait)));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait"), __copy__ (pthread_cond_timedwait)));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy"), __copy__ (pthread_cond_destroy)));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create"), __copy__ (pthread_key_create)));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete"), __copy__ (pthread_key_delete)));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init"), __copy__ (pthread_mutexattr_init)));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype"), __copy__ (pthread_mutexattr_settype)));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy"), __copy__ (pthread_mutexattr_destroy)));
# 237 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create"), __copy__ (pthread_key_create)));
# 247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 659 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 808 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 850 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/atomicity.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/atomicity.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  __attribute__((__always_inline__))
  inline bool
  __is_single_threaded() noexcept
  {





    return !__gthread_active_p();

  }






  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  inline void
  __attribute__((__always_inline__))
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/atomicity.h" 3
  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  inline void
  __attribute__((__always_inline__))
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  inline _Atomic_word
  __attribute__ ((__always_inline__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
    if (__is_single_threaded())
      return __exchange_and_add_single(__mem, __val);
    else
      return __exchange_and_add(__mem, __val);
  }

  inline void
  __attribute__ ((__always_inline__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {
    if (__is_single_threaded())
      __atomic_add_single(__mem, __val);
    else
      __atomic_add(__mem, __val);
  }


}
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 3




# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 1 3
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/new_allocator.h" 1 3
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;

      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };





      typedef std::true_type propagate_on_container_move_assignment;


     
      new_allocator() noexcept { }

     
      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>

 new_allocator(const new_allocator<_Tp1>&) noexcept { }


      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }




      [[__nodiscard__]] _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {



  static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");


 if (__builtin_expect(__n > this->_M_max_size(), false))
   {


     if (__n > (std::size_t(-1) / sizeof(_Tp)))
       std::__throw_bad_array_new_length();
     std::__throw_bad_alloc();
   }


 if (alignof(_Tp) > 16)
   {
     std::align_val_t __al = std::align_val_t(alignof(_Tp));
     return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
   }

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
      {

 if (alignof(_Tp) > 16)
   {
     ::operator delete(__p,

         __t * sizeof(_Tp),

         std::align_val_t(alignof(_Tp)));
     return;
   }

 ::operator delete(__p

     , __t * sizeof(_Tp)

    );
      }


      size_type
      max_size() const noexcept
      { return _M_max_size(); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(std::is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }
# 181 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/new_allocator.h" 3
      template<typename _Up>
 friend bool
 operator==(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return true; }


      template<typename _Up>
 friend bool
 operator!=(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return false; }


    private:
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;



      typedef void* pointer;
      typedef const void* const_pointer;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };





      using propagate_on_container_move_assignment = true_type;

      using is_always_equal

 = true_type;
# 113 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 3
    };
# 123 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;



      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };





      using propagate_on_container_move_assignment = true_type;

      using is_always_equal

 = true_type;




     
      allocator() noexcept { }

     
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>

 allocator(const allocator<_Tp1>&) noexcept { }




      ~allocator() noexcept { }
# 203 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocator.h" 3
      friend bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }


      friend bool
      operator!=(const allocator&, const allocator&) noexcept
      { return false; }



    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }


  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }




  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 2 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream_insert.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream_insert.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream_insert.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_forced.h" 1 3
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_forced.h" 3
       
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream_insert.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 2 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 1 3
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 116 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };





  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {

      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 344 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 788 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 1019 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1098 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };


  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };


  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




  template<typename _Func, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Func, typename _SfinaeType>
    struct __has_is_transparent<_Func, _SfinaeType,
    __void_t<typename _Func::is_transparent>>
    { typedef void type; };

  template<typename _Func, typename _SfinaeType>
    using __has_is_transparent_t
      = typename __has_is_transparent<_Func, _SfinaeType>::type;



}


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/binders.h" 1 3
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1422 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_function.h" 2 3
# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 2 3





# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/range_access.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/range_access.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/range_access.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/initializer_list" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/initializer_list" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/range_access.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm]) noexcept
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm]) noexcept
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 243 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/range_access.h" 3
  template <typename _Container>
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }




  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&)[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    [[nodiscard]] constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard]] constexpr bool
    empty(const _Tp (&)[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    [[nodiscard]] constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }
# 341 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/range_access.h" 3

}
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/alloc_traits.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/alloc_traits.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/alloc_traits.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_construct.h" 1 3
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Tp>
    inline void
    destroy_at(_Tp* __location)
    {
      if constexpr (201703L > 201703L && is_array_v<_Tp>)
 {
   for (auto& __x : *__location)
     std::destroy_at(std::__addressof(__x));
 }
      else
 __location->~_Tp();
    }
# 106 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
   
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    {
# 119 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_construct.h" 3
      ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);
    }
# 132 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }

  template<typename _ForwardIterator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {



      __pointer->~_Tp();

    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }


  template <typename _ForwardIterator>
    inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
# 89 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {

   ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);



 }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 316 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 331 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 343 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 358 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 374 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 388 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      static size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 400 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };






  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 462 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 476 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      {

 return __a.allocate(__n, __hint);



      }
# 494 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 509 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {

   __a.construct(__p, std::forward<_Args>(__args)...);



 }
# 529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {

   __a.destroy(__p);



 }






      static size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {

 return __a.max_size();



      }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<>
    struct allocator_traits<allocator<void>>
    {

      using allocator_type = allocator<void>;


      using value_type = void;


      using pointer = void*;


      using const_pointer = const void*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;


      static void*
      allocate(allocator_type&, size_type, const void* = nullptr) = delete;


      static void
      deallocate(allocator_type&, void*, size_type) = delete;
# 631 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type&, _Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { std::_Construct(__p, std::forward<_Args>(__args)...); }
# 644 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { std::_Destroy(__p); }


      static size_type
      max_size(const allocator_type&) = delete;






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };
# 676 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;

      if constexpr (__pocca::value)
 __one = __two;



    }

  template<typename _Alloc>
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }
# 708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;

      if constexpr (__pocma::value)
 __one = std::move(__two);



    }
# 735 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;

      if constexpr (__pocs::value)
 {
   using std::swap;
   swap(__one, __two);
 }



    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };




  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };


  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
# 829 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 166 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/alloc_traits.h" 3
  };


}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 2 3







# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3





# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type [[__deprecated__]];
      typedef _Arg argument_type [[__deprecated__]];
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };







  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 193 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };


  template<>
    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>
    {
      size_t
      operator()(nullptr_t) const noexcept
      { return 0; }
    };
# 279 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 2 3
# 51 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  constexpr size_t
  __sv_check(size_t __size, size_t __pos, const char* __s)
  {
    if (__pos > __size)
      __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size " "(which is %zu)")
                        , __s, __pos, __size);
    return __pos;
  }



  constexpr size_t
  __sv_limit(size_t __size, size_t __pos, size_t __off) noexcept
  {
   const bool __testoff = __off < __size - __pos;
   return __testoff ? __off : __size - __pos;
  }
# 97 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
  template<typename _CharT, typename _Traits = std::char_traits<_CharT>>
    class basic_string_view
    {
      static_assert(!is_array_v<_CharT>);
      static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
      static_assert(is_same_v<_CharT, typename _Traits::char_type>);

    public:


      using traits_type = _Traits;
      using value_type = _CharT;
      using pointer = value_type*;
      using const_pointer = const value_type*;
      using reference = value_type&;
      using const_reference = const value_type&;
      using const_iterator = const value_type*;
      using iterator = const_iterator;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using reverse_iterator = const_reverse_iterator;
      using size_type = size_t;
      using difference_type = ptrdiff_t;
      static constexpr size_type npos = size_type(-1);



      constexpr
      basic_string_view() noexcept
      : _M_len{0}, _M_str{nullptr}
      { }

      constexpr basic_string_view(const basic_string_view&) noexcept = default;

      __attribute__((__nonnull__)) constexpr
      basic_string_view(const _CharT* __str) noexcept
      : _M_len{traits_type::length(__str)},
 _M_str{__str}
      { }

      constexpr
      basic_string_view(const _CharT* __str, size_type __len) noexcept
      : _M_len{__len}, _M_str{__str}
      { }
# 171 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
      constexpr basic_string_view&
      operator=(const basic_string_view&) noexcept = default;



      constexpr const_iterator
      begin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      end() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_iterator
      cbegin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      cend() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }



      constexpr size_type
      size() const noexcept
      { return this->_M_len; }

      constexpr size_type
      length() const noexcept
      { return _M_len; }

      constexpr size_type
      max_size() const noexcept
      {
 return (npos - sizeof(size_type) - sizeof(void*))
  / sizeof(value_type) / 4;
      }

      [[nodiscard]] constexpr bool
      empty() const noexcept
      { return this->_M_len == 0; }



      constexpr const_reference
      operator[](size_type __pos) const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(__pos < this->_M_len)) __builtin_unreachable(); } while (false);
 return *(this->_M_str + __pos);
      }

      constexpr const_reference
      at(size_type __pos) const
      {
 if (__pos >= _M_len)
   __throw_out_of_range_fmt(("basic_string_view::at: __pos " "(which is %zu) >= this->size() " "(which is %zu)")

                            , __pos, this->size());
 return *(this->_M_str + __pos);
      }

      constexpr const_reference
      front() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(this->_M_len > 0)) __builtin_unreachable(); } while (false);
 return *this->_M_str;
      }

      constexpr const_reference
      back() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(this->_M_len > 0)) __builtin_unreachable(); } while (false);
 return *(this->_M_str + this->_M_len - 1);
      }

      constexpr const_pointer
      data() const noexcept
      { return this->_M_str; }



      constexpr void
      remove_prefix(size_type __n) noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(this->_M_len >= __n)) __builtin_unreachable(); } while (false);
 this->_M_str += __n;
 this->_M_len -= __n;
      }

      constexpr void
      remove_suffix(size_type __n) noexcept
      { this->_M_len -= __n; }

      constexpr void
      swap(basic_string_view& __sv) noexcept
      {
 auto __tmp = *this;
 *this = __sv;
 __sv = __tmp;
      }



     
      size_type
      copy(_CharT* __str, size_type __n, size_type __pos = 0) const
      {
 ;
 __pos = std::__sv_check(size(), __pos, "basic_string_view::copy");
 const size_type __rlen = std::min(__n, _M_len - __pos);


 traits_type::copy(__str, data() + __pos, __rlen);
 return __rlen;
      }

      constexpr basic_string_view
      substr(size_type __pos = 0, size_type __n = npos) const noexcept(false)
      {
 __pos = std::__sv_check(size(), __pos, "basic_string_view::substr");
 const size_type __rlen = std::min(__n, _M_len - __pos);
 return basic_string_view{_M_str + __pos, __rlen};
      }

      constexpr int
      compare(basic_string_view __str) const noexcept
      {
 const size_type __rlen = std::min(this->_M_len, __str._M_len);
 int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
 if (__ret == 0)
   __ret = _S_compare(this->_M_len, __str._M_len);
 return __ret;
      }

      constexpr int
      compare(size_type __pos1, size_type __n1, basic_string_view __str) const
      { return this->substr(__pos1, __n1).compare(__str); }

      constexpr int
      compare(size_type __pos1, size_type __n1,
       basic_string_view __str, size_type __pos2, size_type __n2) const
      {
 return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
      }

      __attribute__((__nonnull__)) constexpr int
      compare(const _CharT* __str) const noexcept
      { return this->compare(basic_string_view{__str}); }

      __attribute__((__nonnull__)) constexpr int
      compare(size_type __pos1, size_type __n1, const _CharT* __str) const
      { return this->substr(__pos1, __n1).compare(basic_string_view{__str}); }

      constexpr int
      compare(size_type __pos1, size_type __n1,
       const _CharT* __str, size_type __n2) const noexcept(false)
      {
 return this->substr(__pos1, __n1)
     .compare(basic_string_view(__str, __n2));
      }
# 397 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
      constexpr size_type
      find(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;

      constexpr size_type
      find(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      rfind(basic_string_view __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;

      constexpr size_type
      rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      rfind(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_first_of(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }

      constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos,
      size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_last_of(basic_string_view __str,
     size_type __pos = npos) const noexcept
      { return this->find_last_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_last_of(_CharT __c, size_type __pos=npos) const noexcept
      { return this->rfind(__c, __pos); }

      constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos,
     size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->find_last_of(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_first_not_of(basic_string_view __str,
   size_type __pos = 0) const noexcept
      { return this->find_first_not_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept;

      constexpr size_type
      find_first_not_of(const _CharT* __str,
   size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_first_not_of(const _CharT* __str, size_type __pos = 0) const noexcept
      {
 return this->find_first_not_of(__str, __pos,
           traits_type::length(__str));
      }

      constexpr size_type
      find_last_not_of(basic_string_view __str,
         size_type __pos = npos) const noexcept
      { return this->find_last_not_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept;

      constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos = npos) const noexcept
      {
 return this->find_last_not_of(__str, __pos,
          traits_type::length(__str));
      }

    private:

      static constexpr int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 using __limits = __gnu_cxx::__int_traits<int>;
 const difference_type __diff = __n1 - __n2;
 if (__diff > __limits::__max)
   return __limits::__max;
 if (__diff < __limits::__min)
   return __limits::__min;
 return static_cast<int>(__diff);
      }

      size_t _M_len;
      const _CharT* _M_str;
    };
# 533 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }
# 562 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) >= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) >= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) >= 0; }



  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        basic_string_view<_CharT,_Traits> __str)
    { return __ostream_insert(__os, __str.data(), __str.size()); }




  using string_view = basic_string_view<char>;

  using wstring_view = basic_string_view<wchar_t>;




  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;



  template<typename _Tp>
    struct hash;

  template<>
    struct hash<string_view>
    : public __hash_base<size_t, string_view>
    {
      size_t
      operator()(const string_view& __str) const noexcept
      { return std::_Hash_impl::hash(__str.data(), __str.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string_view>> : std::false_type
    { };


  template<>
    struct hash<wstring_view>
    : public __hash_base<size_t, wstring_view>
    {
      size_t
      operator()(const wstring_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring_view>> : std::false_type
    { };
# 733 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
  template<>
    struct hash<u16string_view>
    : public __hash_base<size_t, u16string_view>
    {
      size_t
      operator()(const u16string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string_view>> : std::false_type
    { };

  template<>
    struct hash<u32string_view>
    : public __hash_base<size_t, u32string_view>
    {
      size_t
      operator()(const u32string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string_view>> : std::false_type
    { };

  inline namespace literals
  {
  inline namespace string_view_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    inline constexpr basic_string_view<char>
    operator""sv(const char* __str, size_t __len) noexcept
    { return basic_string_view<char>{__str, __len}; }


    inline constexpr basic_string_view<wchar_t>
    operator""sv(const wchar_t* __str, size_t __len) noexcept
    { return basic_string_view<wchar_t>{__str, __len}; }
# 783 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3
    inline constexpr basic_string_view<char16_t>
    operator""sv(const char16_t* __str, size_t __len) noexcept
    { return basic_string_view<char16_t>{__str, __len}; }

    inline constexpr basic_string_view<char32_t>
    operator""sv(const char32_t* __str, size_t __len) noexcept
    { return basic_string_view<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }
# 809 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 3

}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/string_view.tcc" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/string_view.tcc" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/string_view.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
      ;

      if (__n == 0)
 return __pos <= _M_len ? __pos : npos;
      if (__pos >= _M_len)
 return npos;

      const _CharT __elem0 = __str[0];
      const _CharT* __first = _M_str + __pos;
      const _CharT* const __last = _M_str + _M_len;
      size_type __len = _M_len - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __str, __n) == 0)
     return __first - _M_str;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      if (__pos < this->_M_len)
 {
   const size_type __n = this->_M_len - __pos;
   const _CharT* __p = traits_type::find(this->_M_str + __pos, __n, __c);
   if (__p)
     __ret = __p - this->_M_str;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
      ;

      if (__n <= this->_M_len)
 {
   __pos = std::min(size_type(this->_M_len - __n), __pos);
   do
     {
       if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size > 0)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(this->_M_str[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_of(const _CharT* __str, size_type __pos,
    size_type __n) const noexcept
    {
      ;
      for (; __n && __pos < this->_M_len; ++__pos)
 {
   const _CharT* __p = traits_type::find(__str, __n,
      this->_M_str[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_of(const _CharT* __str, size_type __pos,
   size_type __n) const noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(const _CharT* __str, size_type __pos,
        size_type __n) const noexcept
    {
      ;
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::find(__str, __n, this->_M_str[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::eq(this->_M_str[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(const _CharT* __str, size_type __pos,
       size_type __n) const noexcept
    {
      ;
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(this->_M_str[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }


}
# 813 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string_view" 2 3
# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
namespace __cxx11 {
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    protected:




      typedef const_iterator __const_iterator;


    private:


      typedef basic_string_view<_CharT, _Traits> __sv_type;

      template<typename _Tp, typename _Res>
 using _If_sv = enable_if_t<
   __and_<is_convertible<const _Tp&, __sv_type>,
   __not_<is_convertible<const _Tp*, const basic_string*>>,
   __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
   _Res>;


      static __sv_type
      _S_to_string_view(__sv_type __svt) noexcept
      { return __svt; }





      struct __sv_wrapper
      {
 explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
 __sv_type _M_sv;
      };







      explicit
      basic_string(__sv_wrapper __svw, const _Alloc& __a)
      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }



      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 317 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 469 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 500 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 518 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 531 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename = _RequireAllocator<_Alloc>>

      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __end = __s ? __s + traits_type::length(__s)

   : reinterpret_cast<const _CharT*>(__alignof__(_CharT));
 _M_construct(__s, __end, random_access_iterator_tag());
      }
# 551 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename = _RequireAllocator<_Alloc>>

      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 565 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 633 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 651 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp,
        typename = enable_if_t<is_convertible_v<const _Tp&, __sv_type>>>
 basic_string(const _Tp& __t, size_type __pos, size_type __n,
       const _Alloc& __a = _Alloc())
 : basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }






      template<typename _Tp, typename = _If_sv<_Tp, void>>
 explicit
 basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
 : basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }





      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {
 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 699 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 716 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {



     if (__builtin_expect(std::__addressof(__str) != this, true))
       {
  if (__str.size())
    this->_S_copy(_M_data(), __str._M_data(), __str.size());
  _M_set_length(__str.size());
       }
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







     template<typename _Tp>
       _If_sv<_Tp, basic_string&>
       operator=(const _Tp& __svt)
       { return this->assign(__svt); }





      operator __sv_type() const noexcept
      { return __sv_type(data(), size()); }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 944 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 957 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      void
      shrink_to_fit() noexcept
      { reserve(); }
#pragma GCC diagnostic pop






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 999 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg);







      void
      reserve();




      void
      clear() noexcept
      { _M_set_length(0); }





      [[__nodiscard__]] bool
      empty() const noexcept
      { return this->size() == 0; }
# 1037 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(__pos <= size())) __builtin_unreachable(); } while (false);
 return _M_data()[__pos];
      }
# 1054 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 do { if (__builtin_is_constant_evaluated() && !bool(__pos <= size())) __builtin_unreachable(); } while (false);

 ;
 return _M_data()[__pos];
      }
# 1075 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1096 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!empty())) __builtin_unreachable(); } while (false);
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!empty())) __builtin_unreachable(); } while (false);
 return operator[](0);
      }





      reference
      back() noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!empty())) __builtin_unreachable(); } while (false);
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!empty())) __builtin_unreachable(); } while (false);
 return operator[](this->size() - 1);
      }
# 1159 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 operator+=(const _Tp& __svt)
 { return this->append(__svt); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1229 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1295 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }







      template<typename _Tp>
        _If_sv<_Tp, basic_string&>
        append(const _Tp& __svt)
        {
          __sv_type __sv = __svt;
          return this->append(__sv.data(), __sv.size());
        }
# 1325 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
        _If_sv<_Tp, basic_string&>
 append(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_append(__sv.data()
       + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
       std::__sv_limit(__sv.size(), __pos, __n));
 }






      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 this->_M_assign(__str);
 return *this;
      }
# 1400 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1423 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1439 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1455 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1511 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->assign(__sv.data(), __sv.size());
 }
# 1526 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_replace(size_type(0), this->size(),
       __sv.data()
       + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
       std::__sv_limit(__sv.size(), __pos, __n));
 }
# 1554 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1596 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1632 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, initializer_list<_CharT> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1659 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1682 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1705 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1724 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1748 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1766 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1782 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->insert(__pos, __sv.data(), __sv.size());
 }
# 1798 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos1, const _Tp& __svt,
        size_type __pos2, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, size_type(0),
       __sv.data()
       + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
       std::__sv_limit(__sv.size(), __pos2, __n));
 }
# 1826 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1845 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1864 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!empty())) __builtin_unreachable(); } while (false);
 _M_erase(size() - 1, 1);
      }
# 1908 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1930 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1955 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1980 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 2004 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 2022 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2042 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2064 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2085 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2110 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2142 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2214 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos, size_type __n, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos, __n, __sv.data(), __sv.size());
 }
# 2231 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, __n1,
       __sv.data()
       + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
       std::__sv_limit(__sv.size(), __pos2, __n2));
 }
# 2252 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__i1 - begin(), __i2 - __i1, __sv);
 }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2299 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2319 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2331 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2342 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      _CharT*
      data() noexcept
      { return _M_data(); }





      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2366 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2380 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2392 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find(__sv.data(), __pos, __sv.size());
 }
# 2412 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2429 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2442 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2454 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 rfind(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->rfind(__sv.data(), __pos, __sv.size());
 }
# 2476 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2490 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2507 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2521 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2534 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_first_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_of(__sv.data(), __pos, __sv.size());
 }
# 2556 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2570 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2590 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2605 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2618 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_last_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_of(__sv.data(), __pos, __sv.size());
 }
# 2640 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2654 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2674 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2688 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2701 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_not_of(__sv.data(), __pos, __sv.size());
 }
# 2723 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2737 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2755 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2770 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2783 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_not_of(__sv.data(), __pos, __sv.size());
 }
# 2805 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2819 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2853 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2872 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }







      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   const size_type __size = this->size();
   const size_type __osize = __sv.size();
   const size_type __len = std::min(__size, __osize);

   int __r = traits_type::compare(_M_data(), __sv.data(), __len);
   if (!__r)
     __r = _S_compare(__size, __osize);
   return __r;
 }
# 2915 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(size_type __pos, size_type __n, const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this).substr(__pos, __n).compare(__sv);
 }
# 2934 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this)
     .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
 }
# 2965 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2991 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 3009 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3033 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3060 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
# 3105 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 6058 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
namespace __cxx11 {
  template<typename _InputIterator, typename _CharT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;



  template<typename _CharT, typename _Traits,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;

  template<typename _CharT, typename _Traits,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(basic_string_view<_CharT, _Traits>,
   typename basic_string<_CharT, _Traits, _Allocator>::size_type,
   typename basic_string<_CharT, _Traits, _Allocator>::size_type,
   const _Allocator& = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;
}
# 6093 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {

      using _Alloc_traits = allocator_traits<_Alloc>;
      bool __use_rhs = false;
      if constexpr (typename _Alloc_traits::is_always_equal{})
 __use_rhs = true;
      else if (__lhs.get_allocator() == __rhs.get_allocator())
 __use_rhs = true;
      if (__use_rhs)

 {
   const auto __size = __lhs.size() + __rhs.size();
   if (__size > __lhs.capacity() && __size <= __rhs.capacity())
     return std::move(__rhs.insert(0, __lhs));
 }
      return std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6224 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6287 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
# 6300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6338 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6376 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6414 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6452 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6491 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6511 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6552 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6569 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwchar" 2 3
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4
extern "C" {



# 1 "/usr/include/bits/errno.h" 1 3 4
# 24 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/bits/errno.h" 2 3 4
# 50 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 2 3
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6609 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/charconv.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/charconv.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/charconv.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{

  template<typename _Tp>
    constexpr unsigned
    __to_chars_len(_Tp __value, int __base = 10) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      unsigned __n = 1;
      const unsigned __b2 = __base * __base;
      const unsigned __b3 = __b2 * __base;
      const unsigned long __b4 = __b3 * __base;
      for (;;)
 {
   if (__value < (unsigned)__base) return __n;
   if (__value < __b2) return __n + 1;
   if (__value < __b3) return __n + 2;
   if (__value < __b4) return __n + 3;
   __value /= __b4;
   __n += 4;
 }
    }




  template<typename _Tp>
    void
    __to_chars_10_impl(char* __first, unsigned __len, _Tp __val) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      static constexpr char __digits[201] =
 "0001020304050607080910111213141516171819"
 "2021222324252627282930313233343536373839"
 "4041424344454647484950515253545556575859"
 "6061626364656667686970717273747576777879"
 "8081828384858687888990919293949596979899";
      unsigned __pos = __len - 1;
      while (__val >= 100)
 {
   auto const __num = (__val % 100) * 2;
   __val /= 100;
   __first[__pos] = __digits[__num + 1];
   __first[__pos - 1] = __digits[__num];
   __pos -= 2;
 }
      if (__val >= 10)
 {
   auto const __num = __val * 2;
   __first[1] = __digits[__num + 1];
   __first[0] = __digits[__num];
 }
      else
 __first[0] = '0' + __val;
    }

}

}
# 6610 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  {
    const bool __neg = __val < 0;
    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long long __uval
      = __neg ? (unsigned long long)~__val + 1ull : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }




  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };
# 6919 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };





  inline namespace literals
  {
  inline namespace string_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }
# 6977 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.h" 3
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }


  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Traits, typename _Alloc>
      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
      : __and_<
 is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,
 is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>
 >::type
      { };
  }




}
# 56 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.tcc" 1 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.tcc" 3
       
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      const size_type __capacity = capacity();




      if (__res <= __capacity)
 return;

      pointer __tmp = _M_create(__res, __capacity);
      this->_S_copy(__tmp, _M_data(), length() + 1);
      _M_dispose();
      _M_data(__tmp);
      _M_capacity(__res);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve()
    {
      if (_M_is_local())
 return;

      const size_type __length = length();
      const size_type __capacity = _M_allocated_capacity;

      if (__length <= size_type(_S_local_capacity))
 {
   this->_S_copy(_M_local_data(), _M_data(), __length + 1);
   _M_destroy(__capacity);
   _M_data(_M_local_data());
 }

      else if (__length < __capacity)
 try
   {
     pointer __tmp
       = _Alloc_traits::allocate(_M_get_allocator(), __length + 1);
     this->_S_copy(__tmp, _M_data(), __length + 1);
     _M_dispose();
     _M_data(__tmp);
     _M_capacity(__length);
   }
 catch (const __cxxabiv1::__forced_unwind&)
   { throw; }
 catch (...)
   { }

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {


 const basic_string __s(__k1, __k2, this->get_allocator());
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      {


        const size_type __poff = (__s - __p) + (__len2 - __len1);
        this->_S_copy(__p, __p + __poff, __len2);
      }
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1167 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 57 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/string" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _CharT, typename _Traits = char_traits<_CharT>>
      using basic_string = std::basic_string<_CharT, _Traits,
          polymorphic_allocator<_CharT>>;
    using string = basic_string<char>;



    using u16string = basic_string<char16_t>;
    using u32string = basic_string<char32_t>;

    using wstring = basic_string<wchar_t>;

  }

  template<typename _Str>
    struct __hash_string_base
    : public __hash_base<size_t, _Str>
    {
      size_t
      operator()(const _Str& __s) const noexcept
      { return hash<basic_string_view<typename _Str::value_type>>{}(__s); }
    };

  template<>
    struct hash<pmr::string>
    : public __hash_string_base<pmr::string>
    { };






  template<>
    struct hash<pmr::u16string>
    : public __hash_string_base<pmr::u16string>
    { };
  template<>
    struct hash<pmr::u32string>
    : public __hash_string_base<pmr::u32string>
    { };

  template<>
    struct hash<pmr::wstring>
    : public __hash_string_base<pmr::wstring>
    { };



}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();
# 264 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 284 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 300 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 335 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 373 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 440 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);




  };
# 647 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 674 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 688 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 705 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 724 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 738 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 767 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 781 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 794 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.tcc" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.tcc" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 858 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_classes.h" 2 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 2 3




# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3






# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/error_constants.h" 1 3
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/error_constants.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 2 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdexcept" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdexcept" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;

    logic_error(logic_error&&) noexcept;
    logic_error& operator=(logic_error&&) noexcept;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;





    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;
    domain_error(const domain_error&) = default;
    domain_error& operator=(const domain_error&) = default;
    domain_error(domain_error&&) = default;
    domain_error& operator=(domain_error&&) = default;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;
    invalid_argument(const invalid_argument&) = default;
    invalid_argument& operator=(const invalid_argument&) = default;
    invalid_argument(invalid_argument&&) = default;
    invalid_argument& operator=(invalid_argument&&) = default;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;
    length_error(const length_error&) = default;
    length_error& operator=(const length_error&) = default;
    length_error(length_error&&) = default;
    length_error& operator=(length_error&&) = default;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;
    out_of_range(const out_of_range&) = default;
    out_of_range& operator=(const out_of_range&) = default;
    out_of_range(out_of_range&&) = default;
    out_of_range& operator=(out_of_range&&) = default;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;

    runtime_error(runtime_error&&) noexcept;
    runtime_error& operator=(runtime_error&&) noexcept;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;





    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;
    range_error(const range_error&) = default;
    range_error& operator=(const range_error&) = default;
    range_error(range_error&&) = default;
    range_error& operator=(range_error&&) = default;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;
    overflow_error(const overflow_error&) = default;
    overflow_error& operator=(const overflow_error&) = default;
    overflow_error(overflow_error&&) = default;
    overflow_error& operator=(overflow_error&&) = default;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;
    underflow_error(const underflow_error&) = default;
    underflow_error& operator=(const underflow_error&) = default;
    underflow_error(underflow_error&&) = default;
    underflow_error& operator=(underflow_error&&) = default;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };


  template <typename _Tp>
    inline constexpr bool is_error_code_enum_v =
      is_error_code_enum<_Tp>::value;
  template <typename _Tp>
    inline constexpr bool is_error_condition_enum_v =
      is_error_condition_enum<_Tp>::value;



  inline namespace _V2 {
# 97 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 133 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }






    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

  };




  __attribute__ ((__const__)) const error_category& generic_category() noexcept;


  __attribute__ ((__const__)) const error_category& system_category() noexcept;


  }





  error_code make_error_code(errc) noexcept;
# 196 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  class error_code
  {
  public:
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }
# 268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }



  error_condition make_error_condition(errc) noexcept;
# 297 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  class error_condition
  {
  public:
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }




  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }


  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }


  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }
# 397 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }


  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }


  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }


  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }


  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }
# 446 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/system_error" 3
  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }


    system_error (const system_error &) = default;
    system_error &operator= (const system_error &) = default;


    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };






  template<>
    struct hash<error_condition>
    : public __hash_base<size_t, error_condition>
    {
      size_t
      operator()(const error_condition& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };



}
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
  public:
# 255 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 341 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 416 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 447 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 479 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;
# 512 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 541 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();


      Init(const Init&) = default;
      Init& operator=(const Init&) = default;


    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 659 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 675 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 692 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 718 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 769 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 781 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 792 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 803 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 822 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 838 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 859 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 876 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 890 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      friend void __istream_extract(istream&, char*, streamsize);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 230 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 243 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 255 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 267 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 288 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 302 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 320 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 342 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 361 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 376 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 401 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 428 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 454 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 468 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 486 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 502 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 513 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 533 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 549 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 559 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 580 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 606 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 618 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 631 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 653 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 669 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 691 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 704 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 728 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 746 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 772 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 799 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 3
      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf.tcc" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf.tcc" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 859 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/streambuf" 2 3
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwctype" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwctype" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwctype" 3
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 34 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwctype" 2 3
# 80 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cctype" 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 2 3






# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT>
    {
    public:
# 66 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 3
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2, typename _Size>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2*, bool);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }







      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      istreambuf_iterator&
      operator=(const istreambuf_iterator&) noexcept = default;





      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 156 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }






    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
# 273 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/streambuf_iterator.h" 3
      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT* __result,
        bool __strict __attribute__((__unused__)))
    {
      if (__n == 0)
 return __result;

     

                            ;
      _CharT* __beg = __result;
      __result += __it._M_sbuf->sgetn(__beg, __n);
     

                            ;
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      do { if (__builtin_is_constant_evaluated() && !bool(__n > 0)) __builtin_unreachable(); } while (false);
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 152 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 171 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 188 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 204 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 220 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 234 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 249 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 263 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 278 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 295 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 314 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 333 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 355 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 380 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 399 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 418 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 437 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 455 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 472 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 488 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 505 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 524 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 545 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 591 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 614 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 720 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 733 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 746 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 761 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 775 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 789 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 804 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 821 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 854 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 874 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 901 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 933 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 966 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1016 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1033 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1049 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1066 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1086 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1109 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1136 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1162 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1188 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1221 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1232 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1256 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1275 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1293 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1311 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1328 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1345 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1361 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1378 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1398 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1420 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1443 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1469 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1542 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1672 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1710 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1724 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1738 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1751 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1782 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1795 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1808 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1825 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1850 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1863 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1876 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1954 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1975 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 2001 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2038 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2098 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2141 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2214 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;
# 2266 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2294 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2312 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2333 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2351 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2393 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2456 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2481 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;
# 2581 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 3
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }
# 795 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 989 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1062 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1187 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1224 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3

# 1233 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2683 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/locale_facets.h" 2 3
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.tcc" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.tcc" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/basic_ios.h" 2 3
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ios" 2 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }


      __ostream_type&
      operator<<(nullptr_t)
      { return *this << "nullptr"; }
# 282 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 315 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 347 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 360 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      flush();
# 370 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      pos_type
      tellp();
# 381 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 393 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 438 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 457 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma GCC diagnostic pop
# 489 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 511 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 592 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 682 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 694 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 726 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _Tp>
    using _Require_derived_from_ios_base
      = _Require<is_class<_Tp>, __not_<is_same<_Tp, ios_base>>,
   is_convertible<typename add_pointer<_Tp>::type, ios_base*>>;

  template<typename _Os, typename _Tp,
    typename = _Require_derived_from_ios_base<_Os>,
    typename
      = decltype(std::declval<_Os&>() << std::declval<const _Tp&>())>
    using __rvalue_stream_insertion_t = _Os&&;
# 748 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline __rvalue_stream_insertion_t<_Ostream, _Tp>
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __os << __x;
      return std::move(__os);
    }
# 826 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 3

}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream.tcc" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream.tcc" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 830 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ostream" 2 3
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iostream" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      int_type
      get();
# 315 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      int_type
      peek();
# 485 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      unget();
# 555 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      int
      sync();
# 570 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      pos_type
      tellg();
# 585 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }



  template<typename _CharT, typename _Traits>
    void
    __istream_extract(basic_istream<_CharT, _Traits>&, _CharT*, streamsize);

  void __istream_extract(istream&, char*, streamsize);
# 800 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      size_t __n = __builtin_object_size(__s, 0);
      if (__builtin_expect(__n < sizeof(_CharT), false))
 {

   do { if (__builtin_is_constant_evaluated() && !bool(__n >= sizeof(_CharT))) __builtin_unreachable(); } while (false);
   __in.width(0);
   __in.setstate(ios_base::failbit);
 }
      else
 {
   if (__n == (size_t)-1)
     __n = __gnu_cxx::__numeric_traits<streamsize>::__max;
   std::__istream_extract(__in, __s, __n / sizeof(_CharT));
 }
      return __in;
    }

  template<class _Traits>
    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return __in >> reinterpret_cast<char*>(__s); }

  template<class _Traits>
    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return __in >> reinterpret_cast<char*>(__s); }
# 868 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 951 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 967 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _Is, typename _Tp,
    typename = _Require_derived_from_ios_base<_Is>,
    typename = decltype(std::declval<_Is&>() >> std::declval<_Tp>())>
    using __rvalue_stream_extraction_t = _Is&&;
# 983 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 3
  template<typename _Istream, typename _Tp>
    inline __rvalue_stream_extraction_t<_Istream, _Tp>
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __is >> std::forward<_Tp>(__x);
      return std::move(__is);
    }



}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/istream.tcc" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/istream.tcc" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);
       unsigned long long __gcount = 0;

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++__gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;


       if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)
  _M_gcount = __gcount;
       else
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 528 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)
  {
    if (__large_ignore)
      _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
  }
       else if (_M_gcount < __n)
  {
    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max)
  {
    if (__large_ignore)
      _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
    else
      {
        if (_M_gcount != __n)
   ++_M_gcount;
        __sb->sbumpc();
      }
  }
       else if (_M_gcount < __n)
  {
    if (traits_type::eq_int_type(__c, __eof))
      __err |= ios_base::eofbit;
    else
      {
        ++_M_gcount;
        __sb->sbumpc();
      }
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    void
    __istream_extract(basic_istream<_CharT, _Traits>& __in, _CharT* __s,
        streamsize __num)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __width = __in.width();
       if (0 < __width && __width < __num)
  __num = __width;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }

       if (__extracted < __num - 1
    && _Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template void __istream_extract(wistream&, wchar_t*, streamsize);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 996 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/istream" 2 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 26 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 1 3
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 3
       
# 48 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 3
# 66 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 1 3
# 70 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 124 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;





      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
   "result type must be constructible from value type of input range");

      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;


      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 271 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
# 288 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      constexpr bool __can_fill
 = __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __can_fill>::
 __uninit_fill_n(__first, __n, __x);
    }
# 308 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 422 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 529 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   if (__first == __last)
     return;

   typename iterator_traits<_ForwardIterator>::value_type* __val
     = std::__addressof(*__first);
   std::_Construct(__val);
   if (++__first != __last)
     std::fill(__first, __last, *__val);
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   if (__n > 0)
     {
       typename iterator_traits<_ForwardIterator>::value_type* __val
  = std::__addressof(*__first);
       std::_Construct(__val);
       ++__first;
       __first = std::fill_n(__first, __n - 1, *__val);
     }
   return __first;
 }
    };



  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      constexpr bool __can_fill
 = __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
      && __can_fill>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };



  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 870 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }


  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator>
    inline void
    uninitialized_default_construct(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      __uninitialized_default_novalue(__first, __last);
    }







  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_novalue_n(__first, __count);
    }






  template <typename _ForwardIterator>
    inline void
    uninitialized_value_construct(_ForwardIterator __first,
      _ForwardIterator __last)
    {
      return __uninitialized_default(__first, __last);
    }







  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_n(__first, __count);
    }
# 952 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_move(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      return std::uninitialized_copy
 (std::make_move_iterator(__first),
  std::make_move_iterator(__last), __result);
    }
# 969 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    uninitialized_move_n(_InputIterator __first, _Size __count,
    _ForwardIterator __result)
    {
      auto __res = std::__uninitialized_copy_n_pair
 (std::make_move_iterator(__first),
  __count, __result);
      return {__res.first.base(), __res.second};
    }





  template<typename _Tp, typename _Up, typename _Allocator>
    inline void
    __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
   _Allocator& __alloc)
    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
    __dest, std::move(*__orig)))
      && noexcept(std::allocator_traits<_Allocator>::destroy(
       __alloc, std::__addressof(*__orig))))
    {
      typedef std::allocator_traits<_Allocator> __traits;
      __traits::construct(__alloc, __dest, std::move(*__orig));
      __traits::destroy(__alloc, std::__addressof(*__orig));
    }



  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };

  template <typename _Tp, typename _Up>
    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    __relocate_a_1(_Tp* __first, _Tp* __last,
     _Tp* __result, allocator<_Up>&) noexcept
    {
      ptrdiff_t __count = __last - __first;
      if (__count > 0)
 __builtin_memmove(__result, __first, __count * sizeof(_Tp));
      return __result + __count;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
     _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
            std::addressof(*__first),
            __alloc)))
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
   "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
 std::__relocate_object_a(std::__addressof(*__cur),
     std::__addressof(*__first), __alloc);
      return __cur;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
   _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
       std::__niter_base(__last),
       std::__niter_base(__result), __alloc);
    }







}
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_tempbuf.h" 1 3
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {
    template<typename _Tp>
      inline void
      __return_temporary_buffer(_Tp* __p,
    size_t __len __attribute__((__unused__)))
      {

 ::operator delete(__p, __len * sizeof(_Tp));



      }
  }
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len = __len == 1 ? 0 : ((__len + 1) / 2);
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p); }






  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __seed, size_type __original_len);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::__detail::__return_temporary_buffer(_M_buffer, _M_len);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if (__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 243 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __seed, size_type __original_len)
    : _M_original_len(__original_len), _M_len(0), _M_buffer(0)
    {
      std::pair<pointer, size_type> __p(
  std::get_temporary_buffer<value_type>(_M_original_len));

      if (__p.first)
 {
   try
     {
       std::__uninitialized_construct_buf(__p.first, __p.first + __p.second,
       __seed);
       _M_buffer = __p.first;
       _M_len = __p.second;
     }
   catch(...)
     {
       std::__detail::__return_temporary_buffer(__p.first, __p.second);
       throw;
     }
 }
    }


}
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_raw_storage_iter.h" 1 3
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }




      raw_storage_iterator&
      operator=(_Tp&& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), std::move(__element));
 return *this;
      }


      raw_storage_iterator&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator
      operator++(int)
      {
 raw_storage_iterator __tmp = *this;
 ++_M_iter;
 return __tmp;
      }



      _OutputIterator base() const { return _M_iter; }
    };


}
# 69 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/align.h" 1 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/align.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bit" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bit" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bit" 3
# 55 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bit" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 87 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bit" 3
  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));





      if (!__builtin_is_constant_evaluated())
 {
   do { if (__builtin_is_constant_evaluated() && !bool(__shift_exponent != __int_traits<_Tp>::__digits)) __builtin_unreachable(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }
# 409 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bit" 3

}
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/align.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/align.h" 3
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{
  if (__space < __size)
    return nullptr;
  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if (__diff > (__space - __size))
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}
# 108 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/align.h" 3

}
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uses_allocator.h" 1 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  inline constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
   
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;


  template <typename _Tp, typename _Alloc>
    inline constexpr bool uses_allocator_v =
      uses_allocator<_Tp, _Alloc>::value;


  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }



}
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 1 3
# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 3
       
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 3
# 69 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_relops.h" 1 3
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 2 3
# 82 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }





  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
# 312 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 3
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;


  template<typename _Tp>
    [[nodiscard]]
    constexpr add_const_t<_Tp>&
    as_const(_Tp& __t) noexcept
    { return __t; }

  template<typename _Tp>
    void as_const(const _Tp&&) = delete;
# 476 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/utility" 3

}
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3






# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 3
# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 94 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef __array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      constexpr iterator
      begin() noexcept
      { return iterator(data()); }

      constexpr const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      constexpr iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      constexpr const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      constexpr reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      constexpr reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      constexpr const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      constexpr const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      [[__nodiscard__]] constexpr bool
      empty() const noexcept { return size() == 0; }


      constexpr reference
      operator[](size_type __n) noexcept
      {
 ;
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      {

 ;

 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      constexpr reference
      front() noexcept
      {
 ;
 return *begin();
      }

      constexpr const_reference
      front() const noexcept
      {

 ;

 return _AT_Type::_S_ref(_M_elems, 0);
      }

      constexpr reference
      back() noexcept
      {
 ;
 return _Nm ? *(end() - 1) : *end();
      }

      constexpr const_reference
      back() const noexcept
      {

 ;

 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      constexpr pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      constexpr const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, typename... _Up>
    array(_Tp, _Up...)
      -> array<enable_if_t<(is_same_v<_Tp, _Up> && ...), _Tp>,
        1 + sizeof...(_Up)>;



  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }
# 302 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }



  template<typename _Tp, std::size_t _Nm>
   
    inline


    typename enable_if<
      __array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return __array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return __array_traits<_Tp, _Nm>::_S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }
# 432 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/array" 3
  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/invoke.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/invoke.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/invoke.h" 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/invoke.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 53 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



  template<typename _Res, typename _Callable, typename... _Args>
    constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      if constexpr (is_void_v<_Res>)
 std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
      else
 return std::__invoke_impl<__type>(__tag{},
       std::forward<_Callable>(__fn),
       std::forward<_Args>(__args)...);
    }
# 159 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/invoke.h" 3

}
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;


  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
 constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

     
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>

 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      [[__no_unique_address__]] _Head _M_head_impl;
    };
# 186 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

     
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>

 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>

 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>

 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 249 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
  template<size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head)
      { }

      template<typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 explicit constexpr
 _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      _Tuple_impl(_Tuple_impl&&) = default;

      template<typename... _UElements>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
 { }

      template<typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
   _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }

      template<typename... _UElements>

 void
 _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>

 void
 _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr
      _Tuple_impl()
      : _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head)
      : _Base(__head)
      { }

      template<typename _UHead>
 explicit constexpr
 _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;




      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(static_cast<_Base&&>(__in))
      { }


      template<typename _UHead>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _UHead>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(__in))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _UHead>

 void
 _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>

 void
 _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
 {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {
      template<typename _Tp, typename _Up>
 using is_constructible
   = __bool_constant<__is_constructible(_Tp, _Up)>;




      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   is_convertible<_UTypes, _Types>...
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   __not_<__and_<is_convertible<_UTypes, _Types>...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

      template<bool _Cond>
 using _TCC = _TupleConstraints<_Cond, _Elements...>;


      template<bool _Dummy>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_explicitly_default_constructible(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),
   bool>;

      template<typename... _UElements>
 static constexpr
 __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
 __assignable()
 { return __and_<is_assignable<_Elements&, _UElements>...>::value; }


      template<typename... _UElements>
 static constexpr bool __nothrow_assignable()
 {
   return
     __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
 }


      template<typename... _UElements>
 static constexpr bool __nothrow_constructible()
 {
   return
     __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
 }


      template<typename _Up>
 static constexpr bool __valid_args()
 {
   return sizeof...(_Elements) == 1
     && !is_same<tuple, __remove_cvref_t<_Up>>::value;
 }


      template<typename, typename, typename... _Tail>
 static constexpr bool __valid_args()
 { return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }
# 688 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
      template<typename _Tuple, typename = tuple,
        typename = __remove_cvref_t<_Tuple>>
 struct _UseOtherCtor
 : false_type
 { };


      template<typename _Tuple, typename _Tp, typename _Up>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
 : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>
 { };


      template<typename _Tuple, typename _Tp>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>
 : true_type
 { };




      template<typename _Tuple>
 static constexpr bool __use_other_ctor()
 { return _UseOtherCtor<_Tuple>::value; }

    public:
      template<typename _Dummy = void,
        _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
 constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<typename _Dummy = void,
        _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
 explicit constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
 constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
 explicit constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>
 constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>
 explicit constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc, typename... _UElements,
   bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }



     
      tuple&
      operator=(typename conditional<__assignable<const _Elements&...>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _Elements&...>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_Elements...>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename... _UElements>

 __enable_if_t<__assignable<const _UElements&...>(), tuple&>
 operator=(const tuple<_UElements...>& __in)
 noexcept(__nothrow_assignable<const _UElements&...>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename... _UElements>

 __enable_if_t<__assignable<_UElements...>(), tuple&>
 operator=(tuple<_UElements...>&& __in)
 noexcept(__nothrow_assignable<_UElements...>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }


     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
    };


  template<typename... _UTypes>
    tuple(_UTypes...) -> tuple<_UTypes...>;
  template<typename _T1, typename _T2>
    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template<typename _Alloc, typename _T1, typename _T2>
    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;



  template<>
    class tuple<>
    {
    public:
     
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_explicitly_default_constructible(),
   bool>;

      template<bool _Dummy>
 using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),
   bool>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),
   bool>;

      template<typename _U1, typename _U2>
 static constexpr bool __assignable()
 {
   return __and_<is_assignable<_T1&, _U1>,
   is_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_assignable()
 {
   return __and_<is_nothrow_assignable<_T1&, _U1>,
   is_nothrow_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_constructible()
 {
   return __and_<is_nothrow_constructible<_T1, _U1>,
       is_nothrow_constructible<_T2, _U2>>::value;
 }

      static constexpr bool __nothrow_default_constructible()
      {
 return __and_<is_nothrow_default_constructible<_T1>,
        is_nothrow_default_constructible<_T2>>::value;
      }

      template<typename _U1>
 static constexpr bool __is_alloc_arg()
 { return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }

    public:
      template<bool _Dummy = true,
        _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
 constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
 explicit constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
 constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
 constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
 explicit constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



     
      tuple&
      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_T1, _T2>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_T1, _T2>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<size_t, sizeof...(_Elements)> { };


  template <typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;






  template<size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index must be in range");
    };

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<size_t __i, typename... _Types>
    __enable_if_t<(__i >= sizeof...(_Types))>
    __get_helper(const tuple<_Types...>&) = delete;


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type>(std::__get_helper<__i>(__t));
    }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type>(std::__get_helper<__i>(__t));
    }
# 1431 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<_Tp>(std::__get_helper<__idx>(__t));
    }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
    }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }
# 1568 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }



  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef _Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename _Build_index_tuple<tuple_size<
 typename remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, _Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
   
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
   
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  inline constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 1804 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
     
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, size_t... _Indexes1,
      typename... _Args2, size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
 second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }







  template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
    inline constexpr bool __unpack_std_tuple = false;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>>
      = _Trait<_Tp, _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>&>
      = _Trait<_Tp, _Up&...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>>
      = _Trait<_Tp, const _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>&>
      = _Trait<_Tp, const _Up&...>::value;



  template <typename _Fn, typename _Tuple, size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)
    {
      return std::__invoke(std::forward<_Fn>(__f),
      std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }

  template <typename _Fn, typename _Tuple>
    constexpr decltype(auto)
    apply(_Fn&& __f, _Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)
    {
      using _Indices
 = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
      return std::__apply_impl(std::forward<_Fn>(__f),
          std::forward<_Tuple>(__t),
          _Indices{});
    }



  template <typename _Tp, typename _Tuple, size_t... _Idx>
    constexpr _Tp
    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)
    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }

  template <typename _Tp, typename _Tuple>
    constexpr _Tp
    make_from_tuple(_Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)
    {
      return __make_from_tuple_impl<_Tp>(
        std::forward<_Tuple>(__t),
 make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
    }





}
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up,
        typename = _Require<is_convertible<_Up*, _Tp*>>>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };





  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 109 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
 typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
 {
   static_assert(sizeof(_Tp)>0,
   "can't delete pointer to incomplete type");
   delete [] __ptr;
 }
    };




  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      static_assert( !is_rvalue_reference<_Dp>::value,
       "unique_ptr's deleter type must be a function object type"
       " or an lvalue reference type" );

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
      : _M_t(std::move(__u._M_t))
      { __u._M_ptr() = nullptr; }

      __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
      {
 reset(__u.release());
 _M_deleter() = std::forward<_Dp>(__u._M_deleter());
 return *this;
      }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

      void reset(pointer __p) noexcept
      {
 const pointer __old_p = _M_ptr();
 _M_ptr() = __p;
 if (__old_p)
   _M_deleter()(__old_p);
      }

      pointer release() noexcept
      {
 pointer __p = _M_ptr();
 _M_ptr() = nullptr;
 return __p;
      }

      void
      swap(__uniq_ptr_impl& __rhs) noexcept
      {
 using std::swap;
 swap(this->_M_ptr(), __rhs._M_ptr());
 swap(this->_M_deleter(), __rhs._M_deleter());
      }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp,
     bool = is_move_constructible<_Dp>::value,
     bool = is_move_assignable<_Dp>::value>
    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };



  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <typename _Up>
 using _DeleterConstraint =
   typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;

    private:


      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
        >;

    public:



      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 292 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_copy_constructible<_Del>>>
 unique_ptr(pointer __p, const deleter_type& __d) noexcept
 : _M_t(__p, __d) { }
# 304 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_move_constructible<_Del>>>
 unique_ptr(pointer __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(__p, std::move(__d))
 { }

      template<typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type>
 unique_ptr(pointer,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
 { }




      unique_ptr(unique_ptr&&) = default;







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;
#pragma GCC diagnostic pop



      ~unique_ptr() noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(std::move(__ptr));
 __ptr = pointer();
      }







      unique_ptr& operator=(unique_ptr&&) = default;
# 380 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 do { if (__builtin_is_constant_evaluated() && !bool(get() != pointer())) __builtin_unreachable(); } while (false);
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      void
      reset(pointer __p = pointer()) noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 _M_t.reset(std::move(__p));
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
 _M_t.swap(__u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _UPtr = unique_ptr<_Up, _Ep>,
        typename _UP_pointer = typename _UPtr::pointer,
        typename _UP_element_type = typename _UPtr::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<_UP_pointer, _UP_element_type*>,
          is_convertible<_UP_element_type(*)[], element_type(*)[]>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 541 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 559 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_copy_constructible<_Del>>>
      unique_ptr(_Up __p, const deleter_type& __d) noexcept
      : _M_t(__p, __d) { }
# 573 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_move_constructible<_Del>>>
 unique_ptr(_Up __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(std::move(__p), std::move(__d))
 { }

      template<typename _Up, typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type,
        typename = _Require<__safe_conversion_raw<_Up>>>
 unique_ptr(_Up,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      unique_ptr(unique_ptr&&) = default;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
        { }

      template<typename _Up, typename _Ep, typename = _Require<
        __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }







      unique_ptr&
      operator=(unique_ptr&&) = default;
# 632 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 do { if (__builtin_is_constant_evaluated() && !bool(get() != pointer())) __builtin_unreachable(); } while (false);
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      { _M_t.reset(std::move(__p)); }

      void reset(nullptr_t = nullptr) noexcept
      { reset(pointer()); }


      void
      swap(unique_ptr& __u) noexcept
      {
 static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
 _M_t.swap(__u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };




  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;



  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }



  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }



  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }
# 912 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
  template<typename _Up, typename _Ptr = typename _Up::pointer,
    bool = __poison_hash<_Ptr>::__enable_hash_call>
    struct __uniq_ptr_hash

    : private __poison_hash<_Ptr>

    {
      size_t
      operator()(const _Up& __u) const
      noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>())))
      { return hash<_Ptr>()(__u.get()); }
    };

  template<typename _Up, typename _Ptr>
    struct __uniq_ptr_hash<_Up, _Ptr, false>
    : private __poison_hash<_Ptr>
    { };



  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
      public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>>
    { };







  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };




  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;
# 1015 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unique_ptr.h" 3
  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Del>
      struct _Never_valueless_alt<std::unique_ptr<_Tp, _Del>>
      : std::true_type
      { };
  }



}
# 77 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 1 3
# 53 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 1 3
# 53 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocated_ptr.h" 1 3
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return std::__to_address(_M_ptr); }

    private:
      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }



}
# 54 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 2 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 3
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 54 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 3
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 99 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };


template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };






  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct
    _Weak_result_type_impl<_Res(*)(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Functor,
    bool = is_member_function_pointer<_Functor>::value>
    struct _Weak_result_type_memfun
    : _Weak_result_type_impl<_Functor>
    { };


  template<typename _MemFunPtr>
    struct _Weak_result_type_memfun<_MemFunPtr, true>
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };


  template<typename _Func, typename _Class>
    struct _Weak_result_type_memfun<_Func _Class::*, false>
    { };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>
    { };



  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg1
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg1<_Tp,
         __void_t<typename _Tp::argument_type>>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg2
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg2<_Tp,
         __void_t<typename _Tp::first_argument_type,
           typename _Tp::second_argument_type>>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res(_T1) noexcept (_NE)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res(_T1, _T2) noexcept (_NE)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 , bool _NE>
    struct _Reference_wrapper_base<_Res(*)(_T1) noexcept (_NE)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 , bool _NE>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) noexcept (_NE)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>
    struct _Reference_wrapper_base_memfun
    : _Reference_wrapper_base<_Tp>
    { };

  template<typename _MemFunPtr>
    struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
    : _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };
# 293 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/refwrap.h" 3
  template<typename _Tp>
    class reference_wrapper



    : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>

    {
      _Tp* _M_data;

     
      static _Tp* _S_fun(_Tp& __r) noexcept { return std::__addressof(__r); }

      static void _S_fun(_Tp&&) = delete;

      template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
 using __not_same
   = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

    public:
      typedef _Tp type;




      template<typename _Up, typename = __not_same<_Up>, typename
  = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>

 reference_wrapper(_Up&& __uref)
 noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
 : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
 { }

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

     
      operator _Tp&() const noexcept
      { return this->get(); }

     
      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>

 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {




   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };


  template<typename _Tp>
    reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;





  template<typename _Tp>
   
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
   
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
   
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return __t; }


  template<typename _Tp>
   
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return { __t.get() }; }




}
# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 2 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/aligned_buffer.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/aligned_buffer.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/concurrence.h" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/concurrence.h" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;






  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 144 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 277 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const* what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock()
      {
 if (!_M_add_ref_lock_nothrow())
   __throw_bad_weak_ptr();
      }

      bool
      _M_add_ref_lock_nothrow() noexcept;

      void
      _M_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
            ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
  __atomic_thread_fence (4);
       }


            ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
            ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


  __atomic_thread_fence (4);
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow() noexcept
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow() noexcept
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow() noexcept
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, std::move(__d), _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, std::move(__d), __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const type_info& __ti [[__gnu__::__unused__]]) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag
  {
  private:
    template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
      friend class _Sp_counted_ptr_inplace;

    static const type_info&
    _S_ti() noexcept __attribute__ ((__visibility__ ("default")))
    {
      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };
      return reinterpret_cast<const type_info&>(__tag);
    }

    static bool _S_eq(const type_info&) noexcept;
  };

  template<typename _Alloc>
    struct _Sp_alloc_shared_tag
    {
      const _Alloc& _M_a;
    };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;


      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }

    private:
      friend class __shared_count<_Lp>;



      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept override
      {
 auto __ptr = const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());




 if (&__ti == &_Sp_make_shared_tag::_S_ti()
     ||

     __ti == typeid(_Sp_make_shared_tag)



    )
   return __ptr;
 return nullptr;
      }

      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  struct __sp_array_delete
  {
    template<typename _Yp>
      void operator()(_Yp* __p) const { delete[] __p; }
  };

  template<_Lock_policy _Lp>
    class __shared_count
    {
      template<typename _Tp>
 struct __not_alloc_shared_tag { using type = void; };

      template<typename _Tp>
 struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };

    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr>
 __shared_count(_Ptr __p, false_type)
 : __shared_count(__p)
 { }

      template<typename _Ptr>
 __shared_count(_Ptr __p, true_type)
 : __shared_count(__p, __sp_array_delete{}, allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
         _Args&&... __args)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   auto __pi = ::new (__mem)
     _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
   __guard = nullptr;
   _M_pi = __pi;
   __p = __pi->_M_ptr();
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);
#pragma GCC diagnostic pop



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {


   if (__r.get() == nullptr)
     return;

   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);



   _Alloc_traits::construct(__a, __mem, __r.release(),
       std::forward<_Del>(__r.get_deleter()));
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit
      __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept;

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != nullptr)
       __tmp->_M_add_ref_copy();
     if (_M_pi != nullptr)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi == nullptr || !_M_pi->_M_add_ref_lock_nothrow())
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept
    : _M_pi(__r._M_pi)
    {
      if (_M_pi && !_M_pi->_M_add_ref_lock_nothrow())
 _M_pi = nullptr;
    }







  template<typename _Yp_ptr, typename _Tp_ptr>
    struct __sp_compatible_with
    : false_type
    { };

  template<typename _Yp, typename _Tp>
    struct __sp_compatible_with<_Yp*, _Tp*>
    : is_convertible<_Yp*, _Tp*>::type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
    : true_type
    { };


  template<typename _Up, size_t _Nm, typename _Yp, typename = void>
    struct __sp_is_constructible_arrN
    : false_type
    { };

  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type
    { };


  template<typename _Up, typename _Yp, typename = void>
    struct __sp_is_constructible_arr
    : false_type
    { };

  template<typename _Up, typename _Yp>
    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
    : is_convertible<_Yp(*)[], _Up(*)[]>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible;


  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible<_Up[_Nm], _Yp>
    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type
    { };


  template<typename _Up, typename _Yp>
    struct __sp_is_constructible<_Up[], _Yp>
    : __sp_is_constructible_arr<_Up, _Yp>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible
    : is_convertible<_Yp*, _Tp*>::type
    { };



  template<typename _Tp, _Lock_policy _Lp,
    bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
    class __shared_ptr_access
    {
    public:
      using element_type = _Tp;

      element_type&
      operator*() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(_M_get() != nullptr)) __builtin_unreachable(); } while (false);
 return *_M_get();
      }

      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, false, true>
    {
    public:
      using element_type = _Tp;

      element_type*
      operator->() const noexcept
      {
 auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();
 ;
 return __ptr;
      }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, true, false>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;
# 1037 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
      element_type&
      operator[](ptrdiff_t __i) const
      {
 do { if (__builtin_is_constant_evaluated() && !bool(_M_get() != nullptr)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(!extent<_Tp>::value || __i < extent<_Tp>::value)) __builtin_unreachable(); } while (false);
 return _M_get()[__i];
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    : public __shared_ptr_access<_Tp, _Lp>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;

    private:

      template<typename _Yp>
 using _SafeConv
   = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;


      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __shared_ptr&>;


      template<typename _Yp, typename _Del, typename _Res = void,
        typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
 using _UniqCompatible = __enable_if_t<__and_<
   __sp_compatible_with<_Yp*, _Tp*>,
   is_convertible<_Ptr, element_type*>,
   is_move_constructible<_Del>
   >::value, _Res>;


      template<typename _Yp, typename _Del>
 using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;

    public:


      using weak_type = __weak_ptr<_Tp, _Lp>;


      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Yp, typename = _SafeConv<_Yp>>
 explicit
 __shared_ptr(_Yp* __p)
 : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 {
   static_assert( !is_void<_Yp>::value, "incomplete type" );
   static_assert( sizeof(_Yp) > 0, "incomplete type" );
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, std::move(__d))
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
 { }


      template<typename _Yp>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }


      template<typename _Yp>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = nullptr;
 }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = nullptr;
      }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = nullptr;
 }

      template<typename _Yp, typename = _Compatible<_Yp>>
 explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {


   _M_ptr = __r._M_ptr;
 }


      template<typename _Yp, typename _Del,
        typename = _UniqCompatible<_Yp, _Del>>
 __shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = __to_address(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }
# 1215 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<_Yp>
 operator=(auto_ptr<_Yp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
#pragma GCC diagnostic pop


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Yp>
 _Assignable<_Yp>
 operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Yp, typename _Del>
 _UniqAssignable<_Yp, _Del>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Yp>
 _SafeConv<_Yp>
 reset(_Yp* __p)
 {

   do { if (__builtin_is_constant_evaluated() && !bool(__p == nullptr || __p != _M_ptr)) __builtin_unreachable(); } while (false);
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Yp, typename _Deleter>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d)
 { __shared_ptr(__p, std::move(__d)).swap(*this); }

      template<typename _Yp, typename _Deleter, typename _Alloc>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }


      element_type*
      get() const noexcept
      { return _M_ptr; }


      explicit operator bool() const noexcept
      { return _M_ptr != nullptr; }


      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }


      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }


      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }
# 1327 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
 { _M_enable_shared_from_this_with(_M_ptr); }

      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t) noexcept
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:

      template<typename _Yp>
 using __esft_base_t = decltype(__enable_shared_from_this_base(
       std::declval<const __shared_count<_Lp>&>(),
       std::declval<_Yp*>()));


      template<typename _Yp, typename = void>
 struct __has_esft_base
 : false_type { };

      template<typename _Yp>
 struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
 : __not_<is_array<_Tp>> { };

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp* __p) noexcept
 {
   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
     __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
 }

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<!__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp*) noexcept
 { }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      template<typename _Del, typename _Tp1>
 friend _Del* get_deleter(const shared_ptr<_Tp1>&) noexcept;

      element_type* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }
# 1434 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Up, _Lp>& __b) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }



  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1544 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }


  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    reinterpret_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __weak_ptr&>;

    public:
      using element_type = typename remove_extent<_Tp>::type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
# 1626 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 if (use_count() == 0)
   {
     _M_ptr = __ptr;
     _M_refcount = __refcount;
   }
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      element_type* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }
    };

  template<>
    struct _Sp_owner_less<void, void>
    {
      template<typename _Tp, typename _Up>
 auto
 operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept
 -> decltype(__lhs.owner_before(__rhs))
 { return __lhs.owner_before(__rhs); }

      using is_transparent = void;
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }


      __weak_ptr<_Tp, _Lp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      __weak_ptr<const _Tp, _Lp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      friend const __enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<_Lp>&,
         const __enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");

      return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      {
 return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(
     __s.get());
      }
    };


}
# 54 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }

  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }





  template<typename _Del, typename _Tp>
    inline _Del*
    get_deleter(const shared_ptr<_Tp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename... _Args>
 using _Constructible = typename enable_if<
   is_constructible<__shared_ptr<_Tp>, _Args...>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&
 >::type;

    public:


      using element_type = typename __shared_ptr<_Tp>::element_type;




      using weak_type = weak_ptr<_Tp>;





      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Yp, typename = _Constructible<_Yp*>>
 explicit
 shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
# 175 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter,
        typename = _Constructible<_Yp*, _Deleter>>
 shared_ptr(_Yp* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 193 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 212 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _Constructible<_Yp*, _Deleter, _Alloc>>
 shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 232 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 256 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 294 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
 shared_ptr(shared_ptr<_Yp>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 324 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 explicit shared_ptr(const weak_ptr<_Yp>& __r)
 : __shared_ptr<_Tp>(__r) { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
 shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop




      template<typename _Yp, typename _Del,
        typename = _Constructible<unique_ptr<_Yp, _Del>>>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 357 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<auto_ptr<_Yp>>
 operator=(auto_ptr<_Yp>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
#pragma GCC diagnostic pop


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Yp>
 _Assignable<shared_ptr<_Yp>>
 operator=(shared_ptr<_Yp>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Yp, typename _Del>
 _Assignable<unique_ptr<_Yp, _Del>>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...)
 { }

      template<typename _Yp, typename _Alloc, typename... _Args>
 friend shared_ptr<_Yp>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t) noexcept
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };


  template<typename _Tp>
    shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
  template<typename _Tp, typename _Del>
    shared_ptr(unique_ptr<_Tp, _Del>) -> shared_ptr<_Tp>;







  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }
# 462 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() != __b.get(); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      using _Up_elt = typename shared_ptr<_Up>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__b < __a); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return (__b < __a); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return __a < nullptr; }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__a < __b); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }





  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }




  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }



  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }
# 685 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Arg>
 using _Constructible = typename enable_if<
   is_constructible<__weak_ptr<_Tp>, _Arg>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
 >::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 weak_ptr(const shared_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 weak_ptr(const weak_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
 weak_ptr(weak_ptr<_Yp>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<const weak_ptr<_Yp>&>
 operator=(const weak_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<weak_ptr<_Yp>>
 operator=(weak_ptr<_Yp>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };


  template<typename _Tp>
    weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;





  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp = void>
    struct owner_less;


  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }



      weak_ptr<_Tp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      weak_ptr<const _Tp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }


      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
         const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 856 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");

      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }
# 873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_cv<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      {
 return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());
      }
    };





  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp>
      struct _Never_valueless_alt<std::shared_ptr<_Tp>>
      : std::true_type
      { };



    template<typename _Tp>
      struct _Never_valueless_alt<std::weak_ptr<_Tp>>
      : std::true_type
      { };
  }



}
# 78 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_lockfree_defines.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_lockfree_defines.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_lockfree_defines.h" 3
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 2 3
# 48 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 78 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;


  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | __memory_order_modifier(__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(int(__m)); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(int(__m)); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }


  template<typename _IntTp>
    struct __atomic_base;
# 154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
# 177 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i ;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }
# 261 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b __attribute__ ((__unused__))
 = __m & __memory_order_mask;
      do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_consume)) __builtin_unreachable(); } while (false);
      do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acquire)) __builtin_unreachable(); } while (false);
      do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);

      __atomic_clear (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b __attribute__ ((__unused__))
 = __m & __memory_order_mask;
      do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_consume)) __builtin_unreachable(); } while (false);
      do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acquire)) __builtin_unreachable(); } while (false);
      do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);

      __atomic_clear (&_M_i, int(__m));
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
# 316 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
      using value_type = _ITp;
      using difference_type = value_type;

    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i ;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acquire)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_consume)) __builtin_unreachable(); } while (false);

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acquire)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_consume)) __builtin_unreachable(); } while (false);

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 __attribute__ ((__unused__))
   = __m2 & __memory_order_mask;
 memory_order __b1 __attribute__ ((__unused__))
   = __m1 & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 <= __b1)) __builtin_unreachable(); } while (false);

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
 memory_order __b2 __attribute__ ((__unused__))
   = __m2 & __memory_order_mask;
 memory_order __b1 __attribute__ ((__unused__))
   = __m1 & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 <= __b1)) __builtin_unreachable(); } while (false);

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 __attribute__ ((__unused__))
   = __m2 & __memory_order_mask;
 memory_order __b1 __attribute__ ((__unused__))
   = __m1 & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 <= __b1)) __builtin_unreachable(); } while (false);

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 __attribute__ ((__unused__))
   = __m2 & __memory_order_mask;
 memory_order __b1 __attribute__ ((__unused__))
   = __m1 & __memory_order_mask;

 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 <= __b1)) __builtin_unreachable(); } while (false);

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }
# 633 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p ;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;

 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acquire)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_consume)) __builtin_unreachable(); } while (false);

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acquire)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_consume)) __builtin_unreachable(); } while (false);

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b __attribute__ ((__unused__))
   = __m & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b != memory_order_acq_rel)) __builtin_unreachable(); } while (false);

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
 memory_order __b2 __attribute__ ((__unused__))
   = __m2 & __memory_order_mask;
 memory_order __b1 __attribute__ ((__unused__))
   = __m1 & __memory_order_mask;
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 <= __b1)) __builtin_unreachable(); } while (false);

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 __attribute__ ((__unused__))
   = __m2 & __memory_order_mask;
 memory_order __b1 __attribute__ ((__unused__))
   = __m1 & __memory_order_mask;

 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_release)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 != memory_order_acq_rel)) __builtin_unreachable(); } while (false);
 do { if (__builtin_is_constant_evaluated() && !bool(__b2 <= __b1)) __builtin_unreachable(); } while (false);

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }
# 927 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3
      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }
    };
# 1948 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/atomic_base.h" 3

}
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
# 101 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
# 137 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
# 174 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
# 223 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }






}
# 79 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 88 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 126 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 137 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 154 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 172 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 182 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 do { if (__builtin_is_constant_evaluated() && !bool(_M_ptr != 0)) __builtin_unreachable(); } while (false);
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 do { if (__builtin_is_constant_evaluated() && !bool(_M_ptr != 0)) __builtin_unreachable(); } while (false);
 return _M_ptr;
      }
# 212 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 226 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 241 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 266 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__ ("use '" "std::unique_ptr" "' instead")));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1, typename>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {
     
      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__tmp);
    }

  template<typename _Tp>
  template<typename _Tp1, typename>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }


#pragma GCC diagnostic pop


}
# 83 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 91 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 109 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 3
enum class pointer_safety { relaxed, preferred, strict };


inline void
declare_reachable(void*) { }


template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }


inline void
declare_no_pointers(char*, size_t) { }


inline void
undeclare_no_pointers(char*, size_t) { }


inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }



}
# 144 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/glue_memory_defs.h" 1 3
# 13 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/glue_memory_defs.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/execution_defs.h" 1 3
# 15 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/execution_defs.h" 3
namespace __pstl
{
namespace execution
{
inline namespace v1
{


class sequenced_policy
{
  public:

    static constexpr std::false_type
    __allow_unsequenced()
    {
        return std::false_type{};
    }
    static constexpr std::false_type
    __allow_vector()
    {
        return std::false_type{};
    }
    static constexpr std::false_type
    __allow_parallel()
    {
        return std::false_type{};
    }
};


class parallel_policy
{
  public:

    static constexpr std::false_type
    __allow_unsequenced()
    {
        return std::false_type{};
    }
    static constexpr std::false_type
    __allow_vector()
    {
        return std::false_type{};
    }
    static constexpr std::true_type
    __allow_parallel()
    {
        return std::true_type{};
    }
};


class parallel_unsequenced_policy
{
  public:

    static constexpr std::true_type
    __allow_unsequenced()
    {
        return std::true_type{};
    }
    static constexpr std::true_type
    __allow_vector()
    {
        return std::true_type{};
    }
    static constexpr std::true_type
    __allow_parallel()
    {
        return std::true_type{};
    }
};

class unsequenced_policy
{
  public:

    static constexpr std::true_type
    __allow_unsequenced()
    {
        return std::true_type{};
    }
    static constexpr std::true_type
    __allow_vector()
    {
        return std::true_type{};
    }
    static constexpr std::false_type
    __allow_parallel()
    {
        return std::false_type{};
    }
};


constexpr sequenced_policy seq{};
constexpr parallel_policy par{};
constexpr parallel_unsequenced_policy par_unseq{};
constexpr unsequenced_policy unseq{};


template <class _Tp>
struct is_execution_policy : std::false_type
{
};

template <>
struct is_execution_policy<__pstl::execution::sequenced_policy> : std::true_type
{
};
template <>
struct is_execution_policy<__pstl::execution::parallel_policy> : std::true_type
{
};
template <>
struct is_execution_policy<__pstl::execution::parallel_unsequenced_policy> : std::true_type
{
};
template <>
struct is_execution_policy<__pstl::execution::unsequenced_policy> : std::true_type
{
};


template <class _Tp>
constexpr bool is_execution_policy_v = __pstl::execution::is_execution_policy<_Tp>::value;


}
}

namespace __internal
{
template <class _ExecPolicy, class _Tp>

using __enable_if_execution_policy =
    typename std::enable_if<__pstl::execution::is_execution_policy<std::__remove_cvref_t<_ExecPolicy>>::value,
                            _Tp>::type;





}

}
# 14 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/glue_memory_defs.h" 2 3

namespace std
{



template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result);



template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_move_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
destroy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
destroy_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_default_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_default_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_value_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_value_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);

}
# 145 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/memory" 2 3
# 28 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2
# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 29 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 1 3
# 31 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 32 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/algorithm" 1 3
# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/algorithm" 3
       
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/algorithm" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 1 3
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
   
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
   
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
   
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
   
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);


  template<typename _Tp>
    constexpr
    const _Tp&
    clamp(const _Tp&, const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    clamp(const _Tp&, const _Tp&, const _Tp&, _Compare);


  template<typename _IIter, typename _OIter>
   
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
   
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
   
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
   
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
   
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
   
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
   
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
   
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
   
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
   
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
   
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
   
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
   
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
   
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
   
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
   
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
   
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
   
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
   
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
   
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
   
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
   
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
   
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
   
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
   
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
   
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
   
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
   
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
   
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
   
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
   
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
   
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
   
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
   
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
   
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
   
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
   
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
   
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
   
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
   
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
   
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
   
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
   
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
   
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
   
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
     
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
   
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 625 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
   
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 658 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
   
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
   
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
   
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
   
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
   
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);



  template<typename _FIter>
   
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
   
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
   
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
   
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
   
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
   
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
   
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
   
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
   
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
   
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
   
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
   
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
   
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
   
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
   
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
   
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
   
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
   
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
   
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
   
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
   
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
   
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
   
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
   
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
   
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
   
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
   
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
   
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
   
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
   
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
   
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
   
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
   
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
   
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
   
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
   
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
   
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
   
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
   
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
   
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);



}
# 61 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 1 3
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
   
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
   
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
   
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
   
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
   
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
   
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 158 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 194 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
   
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 279 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 313 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
   
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 371 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 398 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
   
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 436 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 464 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 493 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
   
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 522 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 547 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
   
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 561 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {

     

      ;
      ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 2 3




# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uniform_int_dist.h" 1 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uniform_int_dist.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uniform_int_dist.h" 3
  namespace __detail
  {



    template<typename _Tp>
      constexpr bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      }
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 param_type() : param_type(0) { }

 explicit
 param_type(_IntType __a,
     _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
 : _M_a(__a), _M_b(__b)
 {
   do { if (__builtin_is_constant_evaluated() && !bool(_M_a <= _M_b)) __builtin_unreachable(); } while (false);
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      uniform_int_distribution() : uniform_int_distribution(0) { }




      explicit
      uniform_int_distribution(_IntType __a,
          _IntType __b
     = __gnu_cxx::__int_traits<_IntType>::__max)
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomBitGenerator>
 result_type
 operator()(_UniformRandomBitGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomBitGenerator>
 result_type
 operator()(_UniformRandomBitGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomBitGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomBitGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomBitGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomBitGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomBitGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomBitGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomBitGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomBitGenerator& __urng,
   const param_type& __p);

      param_type _M_param;




      template<typename _Wp, typename _Urbg, typename _Up>
 static _Up
 _S_nd(_Urbg& __g, _Up __range)
 {
   using _Up_traits = __gnu_cxx::__int_traits<_Up>;
   using _Wp_traits = __gnu_cxx::__int_traits<_Wp>;
   static_assert(!_Up_traits::__is_signed, "U must be unsigned");
   static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
   static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
   "W must be twice as wide as U");




   _Wp __product = _Wp(__g()) * _Wp(__range);
   _Up __low = _Up(__product);
   if (__low < __range)
     {
       _Up __threshold = -__range % __range;
       while (__low < __threshold)
  {
    __product = _Wp(__g()) * _Wp(__range);
    __low = _Up(__product);
  }
     }
   return __product >> _Up_traits::__digits;
 }
    };

  template<typename _IntType>
    template<typename _UniformRandomBitGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomBitGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
 typedef typename make_unsigned<result_type>::type __utype;
 typedef typename common_type<_Gresult_type, __utype>::type __uctype;

 constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
 constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
 static_assert( __urngmin < __urngmax,
     "Uniform random bit generator must define min() < max()");
 constexpr __uctype __urngrange = __urngmax - __urngmin;

 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;
 if (__urngrange > __urange)
   {


     const __uctype __uerange = __urange + 1;



     if constexpr (__urngrange == 0xffffffffffffffffUL)
       {


  long unsigned int __u64erange = __uerange;
  __ret = _S_nd<unsigned __int128>(__urng, __u64erange);
       }
     else

     if constexpr (__urngrange == 0xffffffffU)
       {


  unsigned int __u32erange = __uerange;
  __ret = _S_nd<long unsigned int>(__urng, __u32erange);
       }
     else

       {

  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  do
    __ret = __uctype(__urng()) - __urngmin;
  while (__ret >= __past);
  __ret /= __scaling;
       }
   }
 else if (__urngrange < __urange)
   {
# 347 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomBitGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomBitGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
 typedef typename make_unsigned<result_type>::type __utype;
 typedef typename common_type<_Gresult_type, __utype>::type __uctype;

 static_assert( __urng.min() < __urng.max(),
     "Uniform random bit generator must define min() < max()");

 constexpr __uctype __urngmin = __urng.min();
 constexpr __uctype __urngmax = __urng.max();
 constexpr __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 432 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      constexpr __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
   
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
   
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, (void) ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 138 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
   
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
   
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
   
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
   
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 364 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 413 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 467 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 486 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 502 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 549 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
   
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
   
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 616 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
   
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 649 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
   
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 684 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
   
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
   
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      return std::__niter_wrap(__result,
          __copy_n_a(__first, __n,
       std::__niter_base(__result), true));
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
   
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 740 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
   
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      const auto __n2 = std::__size_to_integer(__n);
      if (__n2 <= 0)
 return __result;

      ;
      ;

      return std::__copy_n(__first, __n2, __result,
      std::__iterator_category(__first));
    }
# 776 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
   
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
   
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 847 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 881 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
   
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
   
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
   
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 950 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
   
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 981 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
   
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
   
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
   
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
   
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
   
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
   
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1142 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
   
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1170 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
   
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
   
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
   
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
   
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
   
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1402 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
   
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1440 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
   
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
   
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
   
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1520 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      return std::rotate(__left_split, __middle, __right_split);
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType>
 __buf(__first, std::distance(__first, __last));
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1622 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
   
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
   
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1710 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
   
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1725 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1760 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
   
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1777 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
   
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
   
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
   
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
   
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
   
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
   
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
   
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2008 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2064 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2095 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
   
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2168 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2205 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2239 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2273 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 return std::rotate(__first, __middle, __last);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      _BidirectionalIterator __new_middle
 = std::rotate(__first_cut, __middle, __second_cut);
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;
      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);



      _TmpBuf __buf(__first, std::min(__len1, __len2));

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2565 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2606 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
   
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }

      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2780 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
   
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     return false;
   if (!__comp(__first1, __first2))
     ++__first2;
   ++__first1;
 }

      return __first2 == __last2;
    }
# 2818 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2863 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
   
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2899 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
   
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2949 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
   
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2982 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
   
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
   
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3052 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
   
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3085 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
   
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
   
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3137 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
   
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3172 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
   
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }
# 3201 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
   
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3216 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
   
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
   
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
   
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3272 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
   
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3298 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3319 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3399 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3427 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }
# 3504 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3599 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3627 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3654 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
    {
      do { if (__builtin_is_constant_evaluated() && !bool(!(__hi < __lo))) __builtin_unreachable(); } while (false);
      return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
    }
# 3672 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
    {
      do { if (__builtin_is_constant_evaluated() && !bool(!__comp(__hi, __lo))) __builtin_unreachable(); } while (false);
      return __comp(__val, __lo) ? __lo : __comp(__hi, __val) ? __hi : __val;
    }
# 3704 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3726 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }





# 3811 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
   
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3837 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _Function>
   
    _InputIterator
    for_each_n(_InputIterator __first, _Size __n, _Function __f)
    {
      auto __n2 = std::__size_to_integer(__n);
      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)
 {
   if (__n2 <= 0)
     return __first;
   auto __last = __first + __n2;
   std::for_each(__first, __last, std::move(__f));
   return __last;
 }
      else
 {
   while (__n2-->0)
     {
       __f(*__first);
       ++__first;
     }
   return __first;
 }
    }
# 3873 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
   
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3898 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3930 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
   
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3971 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
   
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4004 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
   
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4030 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
   
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4056 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
   
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4080 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
   
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4121 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4161 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4197 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
   
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4231 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
   
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4257 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Searcher>
   
    inline _ForwardIterator
    search(_ForwardIterator __first, _ForwardIterator __last,
    const _Searcher& __searcher)
    { return __searcher(__first, __last).first; }
# 4281 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
   
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4319 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
   
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4353 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
   
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4419 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
   
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4453 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
   
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      typedef __decltype(std::__size_to_integer(__n)) _IntSize;
      for (_IntSize __niter = std::__size_to_integer(__n);
    __niter > 0; --__niter, (void) ++__first)
 *__first = __gen();
      return __first;
    }
# 4491 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
   
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4532 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
   
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4601 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4641 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
   
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4675 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4714 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4751 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4791 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4829 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
   
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4860 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
   
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
   
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4923 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
   
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4974 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
   
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;

      if (__first == __last)
 return;



      _TmpBuf __buf(__first, (__last - __first + 1) / 2);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5044 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5078 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
   
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5148 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
   
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
   
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
   
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5272 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
   
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5322 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
   
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
   
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5397 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
   
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5449 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
   
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
   
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5530 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
   
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5582 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
   
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5636 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5661 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5700 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5725 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
           typename _Size, typename _UniformRandomBitGenerator>
    _RandomAccessIterator
    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      __distrib_type __d{};
      _Size __sample_sz = 0;
      while (__first != __last && __sample_sz != __n)
 {
   __out[__sample_sz++] = *__first;
   ++__first;
 }
      for (auto __pop_sz = __sample_sz; __first != __last;
   ++__first, (void) ++__pop_sz)
 {
   const auto __k = __d(__g, __param_type{0, __pop_sz});
   if (__k < __n)
     __out[__k] = *__first;
 }
      return __out + __sample_sz;
    }


  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
           typename _Size, typename _UniformRandomBitGenerator>
    _OutputIterator
    __sample(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag,
      _OutputIterator __out, _Cat,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      using _USize = make_unsigned_t<_Size>;
      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

      if (__first == __last)
 return __out;

      __distrib_type __d{};
      _Size __unsampled_sz = std::distance(__first, __last);
      __n = std::min(__n, __unsampled_sz);




      const __uc_type __urngrange = __g.max() - __g.min();
      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))


        {
   while (__n != 0 && __unsampled_sz >= 2)
     {
       const pair<_Size, _Size> __p =
  __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

       --__unsampled_sz;
       if (__p.first < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;

       if (__n == 0) break;

       --__unsampled_sz;
       if (__p.second < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;
     }
        }



      for (; __n != 0; ++__first)
 if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
   {
     *__out++ = *__first;
     --__n;
   }
      return __out;
    }




  template<typename _PopulationIterator, typename _SampleIterator,
           typename _Distance, typename _UniformRandomBitGenerator>
    _SampleIterator
    sample(_PopulationIterator __first, _PopulationIterator __last,
    _SampleIterator __out, _Distance __n,
    _UniformRandomBitGenerator&& __g)
    {
      using __pop_cat = typename
 std::iterator_traits<_PopulationIterator>::iterator_category;
      using __samp_cat = typename
 std::iterator_traits<_SampleIterator>::iterator_category;

      static_assert(
   __or_<is_convertible<__pop_cat, forward_iterator_tag>,
  is_convertible<__samp_cat, random_access_iterator_tag>>::value,
   "output range must use a RandomAccessIterator when input range"
   " does not meet the ForwardIterator requirements");

      static_assert(is_integral<_Distance>::value,
      "sample size must be an integer type");

      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
      return std::
 __sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
   std::forward<_UniformRandomBitGenerator>(__g));
    }





}
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/algorithm" 2 3
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/algorithm" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/glue_algorithm_defs.h" 1 3
# 13 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/glue_algorithm_defs.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 1 3
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
       
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const size_t _M_max_size = sizeof(_Nocopy_types);
    static const size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 using _Local_storage = integral_constant<bool, __stored_locally>;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   if constexpr (__stored_locally)
     {
       const _Functor& __f = __source._M_access<_Functor>();
       return const_cast<_Functor*>(std::__addressof(__f));
     }
   else
     return __source._M_access<_Functor*>();
 }

      private:


 template<typename _Fn>
   static void
   _M_create(_Any_data& __dest, _Fn&& __f, true_type)
   {
     ::new (__dest._M_access()) _Functor(std::forward<_Fn>(__f));
   }


 template<typename _Fn>
   static void
   _M_create(_Any_data& __dest, _Fn&& __f, false_type)
   {
     __dest._M_access<_Functor*>()
       = new _Functor(std::forward<_Fn>(__f));
   }


 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {
     case __get_type_info:

       __dest._M_access<const type_info*>() = &typeid(_Functor);



       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_init_functor(__dest,
    *const_cast<const _Functor*>(_M_get_pointer(__source)));
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 template<typename _Fn>
   static void
   _M_init_functor(_Any_data& __functor, _Fn&& __f)
   noexcept(__and_<_Local_storage,
     is_nothrow_constructible<_Functor, _Fn>>::value)
   {
     _M_create(__functor, std::forward<_Fn>(__f), _Local_storage());
   }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }
      };

    _Function_base() = default;

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    using _Manager_type
      = bool (*)(_Any_data&, const _Any_data&, _Manager_operation);

    _Any_data _M_functor{};
    _Manager_type _M_manager{};
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      using _Base = _Function_base::_Base_manager<_Functor>;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
         std::forward<_ArgTypes>(__args)...);
      }

      template<typename _Fn>
 static constexpr bool
 _S_nothrow_init() noexcept
 {
   return __and_<typename _Base::_Local_storage,
   is_nothrow_constructible<_Functor, _Fn>>::value;
 }
    };


  template<>
    class _Function_handler<void, void>
    {
    public:
      static bool
      _M_manager(_Any_data&, const _Any_data&, _Manager_operation)
      { return false; }
    };





  template<typename _Signature, typename _Functor,
    bool __valid = is_object<_Functor>::value>
    struct _Target_handler
    : _Function_handler<_Signature, typename remove_cv<_Functor>::type>
    { };

  template<typename _Signature, typename _Functor>
    struct _Target_handler<_Signature, _Functor, false>
    : _Function_handler<void, void>
    { };






  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {


      template<typename _Func,
        bool _Self = is_same<__remove_cvref_t<_Func>, function>::value>
 using _Decay_t
   = typename __enable_if_t<!_Self, decay<_Func>>::type;

      template<typename _Func,
        typename _DFunc = _Decay_t<_Func>,
        typename _Res2 = __invoke_result<_DFunc&, _ArgTypes...>>
 struct _Callable
 : __is_invocable_impl<_Res2, _Res>::type
 { };

      template<typename _Cond, typename _Tp = void>
 using _Requires = __enable_if_t<_Cond::value, _Tp>;

      template<typename _Functor>
 using _Handler
   = _Function_handler<_Res(_ArgTypes...), __decay_t<_Functor>>;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      function(const function& __x)
      : _Function_base()
      {
 if (static_cast<bool>(__x))
   {
     __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
     _M_invoker = __x._M_invoker;
     _M_manager = __x._M_manager;
   }
      }
# 404 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      function(function&& __x) noexcept
      : _Function_base(), _M_invoker(__x._M_invoker)
      {
 if (static_cast<bool>(__x))
   {
     _M_functor = __x._M_functor;
     _M_manager = __x._M_manager;
     __x._M_manager = nullptr;
     __x._M_invoker = nullptr;
   }
      }
# 433 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      template<typename _Functor,
        typename _Constraints = _Requires<_Callable<_Functor>>>
 function(_Functor&& __f)
 noexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())
 : _Function_base()
 {
   static_assert(is_copy_constructible<__decay_t<_Functor>>::value,
       "std::function target must be copy-constructible");
   static_assert(is_constructible<__decay_t<_Functor>, _Functor>::value,
       "std::function target must be constructible from the "
       "constructor argument");

   using _My_handler = _Handler<_Functor>;

   if (_My_handler::_M_not_empty_function(__f))
     {
       _My_handler::_M_init_functor(_M_functor,
        std::forward<_Functor>(__f));
       _M_invoker = &_My_handler::_M_invoke;
       _M_manager = &_My_handler::_M_manager;
     }
 }
# 468 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 486 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      function&
      operator=(function&& __x) noexcept
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 500 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 528 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      template<typename _Functor>
 _Requires<_Callable<_Functor>, function&>
 operator=(_Functor&& __f)
 noexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 555 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      void swap(function& __x) noexcept
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 572 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 585 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      _Res
      operator()(_ArgTypes... __args) const
      {
 if (_M_empty())
   __throw_bad_function_call();
 return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
      }
# 604 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      const type_info&
      target_type() const noexcept
      {
 if (_M_manager)
   {
     _Any_data __typeinfo_result;
     _M_manager(__typeinfo_result, _M_functor, __get_type_info);
     if (auto __ti = __typeinfo_result._M_access<const type_info*>())
       return *__ti;
   }
 return typeid(void);
      }
# 629 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
      template<typename _Functor>
 _Functor*
 target() noexcept
 {
   const function* __const_this = this;
   const _Functor* __func = __const_this->template target<_Functor>();


   return *const_cast<_Functor**>(&__func);
 }

      template<typename _Functor>
 const _Functor*
 target() const noexcept
 {
   if constexpr (is_object<_Functor>::value)
     {


       using _Handler = _Target_handler<_Res(_ArgTypes...), _Functor>;

       if (_M_manager == &_Handler::_M_manager

    || (_M_manager && typeid(_Functor) == target_type())

   )
  {
    _Any_data __ptr;
    _M_manager(__ptr, _M_functor, __get_functor_ptr);
    return __ptr._M_access<const _Functor*>();
  }
     }
   return nullptr;
 }


    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker = nullptr;
    };


  template<typename>
    struct __function_guide_helper
    { };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) & noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) const noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) const & noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename... _ArgTypes>
    function(_Res(*)(_ArgTypes...)) -> function<_Res(_ArgTypes...)>;

  template<typename _Functor, typename _Signature = typename
    __function_guide_helper<decltype(&_Functor::operator())>::type>
    function(_Functor) -> function<_Signature>;
# 716 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }



  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 735 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 756 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
    { __x.swap(__y); }


  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Signature>
      struct _Never_valueless_alt<std::function<_Signature>>
      : std::true_type
      { };
  }



}
# 60 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 1 3
# 32 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 3
       
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 3
# 46 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 1 3
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;

namespace __detail
{





  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _Hash, typename _RangeHash,
    typename _Unused, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return __first != __last ? 1 : 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    { return __distance_fw(__first, __last,
      std::__iterator_category(__first)); }

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const noexcept
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const noexcept
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
      : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       auto& __a = _M_h._M_node_allocator();
       __node_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __node_alloc_traits::construct(__a, __node->_M_valptr(),
       std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    _M_h._M_deallocate_node_ptr(__node);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
      : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
# 199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 215 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<bool _Cache_hash_code>
    struct _Hash_node_code_cache
    { };




  template<>
    struct _Hash_node_code_cache<true>
    { std::size_t _M_hash_code; };

  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node_value
    : _Hash_node_value_base<_Value>
    , _Hash_node_code_cache<_Cache_hash_code>
    { };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node
    : _Hash_node_base
    , _Hash_node_value<_Value, _Cache_hash_code>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base() : _M_cur(nullptr) { }
      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }

      friend bool
      operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
      noexcept
      { return __x._M_cur == __y._M_cur; }


      friend bool
      operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
      noexcept
      { return __x._M_cur != __y._M_cur; }

    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const value_type*, value_type*>::type;

      using reference = typename std::conditional<__constant_iterators,
      const value_type&, value_type&>::type;

      _Node_iterator() = default;

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const value_type* pointer;
      typedef const value_type& reference;

      _Node_const_iterator() = default;

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    using __has_load_factor = true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };


  struct _Mask_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num & (__den - 1); }
  };


  inline std::size_t
  __clp2(std::size_t __n) noexcept
  {
    using __gnu_cxx::__int_traits;

    if (__n < 2)
      return __n;
    const unsigned __lz = sizeof(size_t) > sizeof(long)
      ? __builtin_clzll(__n - 1ull)
      : __builtin_clzl(__n - 1ul);

    return (size_t(1) << (__int_traits<size_t>::__digits - __lz - 1)) << 1;
  }



  struct _Power2_rehash_policy
  {
    using __has_load_factor = true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }



    std::size_t
    _M_next_bkt(std::size_t __n) noexcept
    {
      if (__n == 0)



 return 1;

      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == 0)
 __res = __max_bkt;
      else if (__res == 1)



 __res = 2;

      if (__res == __max_bkt)



 _M_next_resize = size_t(-1);
      else
 _M_next_resize
   = __builtin_floor(__res * (double)_M_max_load_factor);

      return __res;
    }


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const noexcept
    { return __builtin_ceil(__n / (double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) noexcept
    {
      if (__n_elt + __n_ins > _M_next_resize)
 {



   double __min_bkts
     = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)
       / (double)_M_max_load_factor;
   if (__min_bkts >= __n_bkt)
     return { true,
       _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,
      __n_bkt * _S_growth_factor)) };

   _M_next_resize
     = __builtin_floor(__n_bkt * (double)_M_max_load_factor);
   return { false, 0 };
 }
      else
 return { false, 0 };
    }

    typedef std::size_t _State;

    _State
    _M_state() const noexcept
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state) noexcept
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };
# 638 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = _Hashtable_base<_Key, _Pair, _Select1st, _Equal,
            _Hash, _RangeHash, _Unused,
            _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _Hash, _RangeHash,
         _Unused, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;

    public:
      using key_type = typename __hashtable_base::key_type;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__code);
      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::tuple<const key_type&>(__k),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__code);
      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::forward_as_tuple(std::move(__k)),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      auto __ite = __h->find(__k);

      if (!__ite._M_cur)
 __throw_out_of_range(("_Map_base::at"));
      return __ite->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    -> const mapped_type&
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      auto __ite = __h->find(__k);

      if (!__ite._M_cur)
 __throw_out_of_range(("_Map_base::at"));
      return __ite->second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _Hash, _RangeHash,
            _Unused, _Traits>;

      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _Hash, _RangeHash,
         _Unused, _RehashPolicy, _Traits>;

      using __hash_cached = typename _Traits::__hash_cached;
      using __constant_iterators = typename _Traits::__constant_iterators;

      using __hashtable_alloc = _Hashtable_alloc<
 __alloc_rebind<_Alloc, _Hash_node<_Value,
       __hash_cached::value>>>;

      using value_type = typename __hashtable_base::value_type;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename _Traits::__unique_keys;
      using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, true_type __uks);

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, false_type __uks);

    public:
      using iterator = _Node_iterator<_Value, __constant_iterators::value,
          __hash_cached::value>;

      using const_iterator = _Node_const_iterator<_Value, __constant_iterators::value,
        __hash_cached::value>;

      using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;

      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys{});
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys{});
      }

      template<typename _KType, typename... _Args>
 std::pair<iterator, bool>
 try_emplace(const_iterator, _KType&& __k, _Args&&... __args)
 {
   __hashtable& __h = _M_conjure_hashtable();
   auto __code = __h._M_hash_code(__k);
   std::size_t __bkt = __h._M_bucket_index(__code);
   if (auto __node = __h._M_find_node(__bkt, __k, __code))
     return { iterator(__node), false };

   typename __hashtable::_Scoped_node __node {
     &__h,
     std::piecewise_construct,
     std::forward_as_tuple(std::forward<_KType>(__k)),
     std::forward_as_tuple(std::forward<_Args>(__args)...)
     };
   auto __it
     = __h._M_insert_unique_node(__bkt, __code, __node._M_node);
   __node._M_node = nullptr;
   return { __it, true };
 }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen, __unique_keys{});
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, true_type __uks)
      {
 __hashtable& __h = _M_conjure_hashtable();
 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __uks);
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, false_type __uks)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __uks);
      }







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _Hash, _RangeHash, _Unused,
           _RehashPolicy, _Traits>;

      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      __ireturn_type
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys{});
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys{});
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _Hash, _RangeHash, _Unused,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys{}, std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys{},
    std::forward<_Pair>(__v));
 }
   };

  template<typename _Policy>
    using __has_load_factor = typename _Policy::__has_load_factor;







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    typename =
      __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
   false_type >
    {
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
   true_type >
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_RehashPolicy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _Tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return _M_tp; }
      _Tp& _M_get() { return _M_tp; }

    private:
      _Tp _M_tp{};
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1185 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __cache_hash_code>
    struct _Hash_code_base
    : private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey,
      _Hash, _RangeHash, _Unused, false>;

    public:
      typedef _Hash hasher;

      hasher
      hash_function() const
      { return _M_hash(); }

    protected:
      typedef std::size_t __hash_code;



      _Hash_code_base() = default;

      _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _Hash&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_hash()(__k);
      }

      template<typename _Kt>
 __hash_code
 _M_hash_code_tr(const _Kt& __k) const
 {
   static_assert(__is_invocable<const _Hash&, const _Kt&>{},
     "hash function must be invocable with an argument of key type");
   return _M_hash()(__k);
 }

      std::size_t
      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      { return _RangeHash{}(__c, __bkt_count); }

      std::size_t
      _M_bucket_index(const _Hash_node_value<_Value, false>& __n,
        std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))
    && noexcept(declval<const _RangeHash&>()((__hash_code)0,
          (std::size_t)0)) )
      {
 return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
       __bkt_count);
      }

      std::size_t
      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }

      void
      _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
      { }

      void
      _M_copy_code(_Hash_node_code_cache<false>&,
     const _Hash_node_code_cache<false>&) const
      { }

      void
      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
      { __n._M_hash_code = __c; }

      void
      _M_copy_code(_Hash_node_code_cache<true>& __to,
     const _Hash_node_code_cache<true>& __from) const
      { __to._M_hash_code = __from._M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }

      const _Hash&
      _M_hash() const { return __ebo_hash::_M_cget(); }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _Hash, _RangeHash, _Unused, true>
    : public _Node_iterator_base<_Value, true>
    {
    protected:
      using __base_node_iter = _Node_iterator_base<_Value, true>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
           _Hash, _RangeHash, _Unused, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base&,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_node_iter(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { }

      void
      _M_incr()
      {
 __base_node_iter::_M_incr();
 if (this->_M_cur)
   {
     std::size_t __bkt
       = _RangeHash{}(this->_M_cur->_M_hash_code, _M_bucket_count);
     if (__bkt != _M_bucket)
       this->_M_cur = nullptr;
   }
      }

      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _Hash, _RangeHash, _Unused, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
     _Unused>
    , _Node_iterator_base<_Value, false>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _Hash, _RangeHash, _Unused, false>;
      using __node_iter_base = _Node_iterator_base<_Value, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __node_iter_base(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != size_t(-1))
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : __node_iter_base(__iter._M_cur), _M_bucket(__iter._M_bucket)
      , _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != size_t(-1))
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 this->_M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 __node_iter_base::_M_incr();
 if (this->_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(*this->_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       this->_M_cur = nullptr;
   }
      }

      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _Hash, _RangeHash, _Unused, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const value_type*, value_type*>::type
       pointer;
      typedef typename std::conditional<__constant_iterators,
     const value_type&, value_type&>::type
       reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __n,
        std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Hash, typename _RangeHash, typename _Unused,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _Hash, _RangeHash, _Unused, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const value_type* pointer;
      typedef const value_type& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __n,
       std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _Hash, _RangeHash, _Unused,
        __constant_iterators,
        __cache>& __x)
      : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1558 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _Hash, typename _RangeHash,
    typename _Unused, typename _Traits>
    struct _Hashtable_base
    : public _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
        _Unused, _Traits::__hash_cached::value>,
      private _Hashtable_ebo_helper<0, _Equal>
    {
    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Equal key_equal;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;

      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;

      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _Hash, _RangeHash, _Unused,
            __hash_cached::value>;

      using __hash_code = typename __hash_code_base::__hash_code;

    private:
      using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;

      static bool
      _S_equals(__hash_code, const _Hash_node_code_cache<false>&)
      { return true; }

      static bool
      _S_node_equals(const _Hash_node_code_cache<false>&,
       const _Hash_node_code_cache<false>&)
      { return true; }

      static bool
      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
      { return __c == __n._M_hash_code; }

      static bool
      _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
       const _Hash_node_code_cache<true>& __rhn)
      { return __lhn._M_hash_code == __rhn._M_hash_code; }

    protected:
      _Hashtable_base() = default;

      _Hashtable_base(const _Hash& __hash, const _Equal& __eq)
      : __hash_code_base(__hash), _EqualEBO(__eq)
      { }

      bool
      _M_equals(const _Key& __k, __hash_code __c,
  const _Hash_node_value<_Value, __hash_cached::value>& __n) const
      {
 static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
   "key equality predicate must be invocable with two arguments of "
   "key type");
 return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
      }

      template<typename _Kt>
 bool
 _M_equals_tr(const _Kt& __k, __hash_code __c,
       const _Hash_node_value<_Value,
         __hash_cached::value>& __n) const
 {
   static_assert(
     __is_invocable<const _Equal&, const _Kt&, const _Key&>{},
     "key equality predicate must be invocable with two arguments of "
     "key type");
   return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
 }

      bool
      _M_node_equals(
 const _Hash_node_value<_Value, __hash_cached::value>& __lhn,
 const _Hash_node_value<_Value, __hash_cached::value>& __rhn) const
      {
 return _S_node_equals(__lhn, __rhn)
   && _M_eq()(_ExtractKey{}(__lhn._M_v()), _ExtractKey{}(__rhn._M_v()));
      }

      void
      _M_swap(_Hashtable_base& __x)
      {
 __hash_code_base::_M_swap(__x);
 std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
      }

      const _Equal&
      _M_eq() const { return _EqualEBO::_M_cget(); }
    };
# 1661 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      using __node_type = typename __hashtable::__node_type;
      const __hashtable* __this = static_cast<const __hashtable*>(this);
      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   std::size_t __ybkt = __other._M_bucket_index(*__itx._M_cur);
   auto __prev_n = __other._M_buckets[__ybkt];
   if (!__prev_n)
     return false;

   for (__node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);;
        __n = __n->_M_next())
     {
       if (__n->_M_v() == *__itx)
  break;

       if (!__n->_M_nxt
    || __other._M_bucket_index(*__n->_M_next()) != __ybkt)
  return false;
     }
 }

      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      using __node_type = typename __hashtable::__node_type;
      const __hashtable* __this = static_cast<const __hashtable*>(this);
      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   std::size_t __x_count = 1;
   auto __itx_end = __itx;
   for (++__itx_end; __itx_end != __this->end()
   && __this->key_eq()(_ExtractKey{}(*__itx),
         _ExtractKey{}(*__itx_end));
        ++__itx_end)
     ++__x_count;

   std::size_t __ybkt = __other._M_bucket_index(*__itx._M_cur);
   auto __y_prev_n = __other._M_buckets[__ybkt];
   if (!__y_prev_n)
     return false;

   __node_type* __y_n = static_cast<__node_type*>(__y_prev_n->_M_nxt);
   for (;;)
     {
       if (__this->key_eq()(_ExtractKey{}(__y_n->_M_v()),
       _ExtractKey{}(*__itx)))
  break;

       auto __y_ref_n = __y_n;
       for (__y_n = __y_n->_M_next(); __y_n; __y_n = __y_n->_M_next())
  if (!__other._M_node_equals(*__y_ref_n, *__y_n))
    break;

       if (!__y_n || __other._M_bucket_index(*__y_n) != __ybkt)
  return false;
     }

   typename __hashtable::const_iterator __ity(__y_n);
   for (auto __ity_end = __ity; __ity_end != __other.end(); ++__ity_end)
     if (--__x_count == 0)
       break;

   if (__x_count != 0)
     return false;

   if (!std::is_permutation(__itx, __itx_end, __ity))
     return false;

   __itx = __itx_end;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_alloc_traits = typename __node_alloc_traits::template
 rebind_traits<typename __node_type::value_type>;

      using __node_ptr = __node_type*;
      using __node_base = _Hash_node_base;
      using __node_base_ptr = __node_base*;
      using __buckets_alloc_type =
 __alloc_rebind<__node_alloc_type, __node_base_ptr>;
      using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;
      using __buckets_ptr = __node_base_ptr*;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
 : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_M_get(); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_M_cget(); }


      template<typename... _Args>
 __node_ptr
 _M_allocate_node(_Args&&... __args);


      void
      _M_deallocate_node(__node_ptr __n);


      void
      _M_deallocate_node_ptr(__node_ptr __n);



      void
      _M_deallocate_nodes(__node_ptr __n);

      __buckets_ptr
      _M_allocate_buckets(std::size_t __bkt_count);

      void
      _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      auto
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      -> __node_ptr
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_ptr __n = std::__to_address(__nptr);
 try
   {
     ::new ((void*)__n) __node_type;
     __node_alloc_traits::construct(_M_node_allocator(),
        __n->_M_valptr(),
        std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
    {
      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
      _M_deallocate_node_ptr(__n);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
    {
      while (__n)
 {
   __node_ptr __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    auto
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
    -> __buckets_ptr
    {
      __buckets_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
      __buckets_ptr __p = std::__to_address(__ptr);
      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::
    _M_deallocate_buckets(__buckets_ptr __bkts,
     std::size_t __bkt_count)
    {
      typedef typename __buckets_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __buckets_alloc_type __alloc(_M_node_allocator());
      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    }


}


}
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/enable_special_members.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/enable_special_members.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/enable_special_members.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  struct _Enable_default_constructor_tag
  {
    explicit constexpr _Enable_default_constructor_tag() = default;
  };






template<bool _Switch, typename _Tag = void>
  struct _Enable_default_constructor
  {
    constexpr _Enable_default_constructor() noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };







template<bool _Switch, typename _Tag = void>
  struct _Enable_destructor { };






template<bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_copy_move { };
# 96 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/enable_special_members.h" 3
template<bool _Default, bool _Destructor,
         bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_special_members
  : private _Enable_default_constructor<_Default, _Tag>,
    private _Enable_destructor<_Destructor, _Tag>,
    private _Enable_copy_move<_Copy, _CopyAssignment,
                              _Move, _MoveAssignment,
                              _Tag>
  { };



template<typename _Tag>
  struct _Enable_default_constructor<false, _Tag>
  {
    constexpr _Enable_default_constructor() noexcept = delete;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };

template<typename _Tag>
  struct _Enable_destructor<false, _Tag>
  { ~_Enable_destructor() noexcept = delete; };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };



}
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/node_handle.h" 1 3
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/node_handle.h" 3
       
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/node_handle.h" 3
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/node_handle.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/node_handle.h" 3
  template<typename _Val, typename _NodeAlloc>
    class _Node_handle_common
    {
      using _AllocTraits = allocator_traits<_NodeAlloc>;

    public:
      using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;

      allocator_type
      get_allocator() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!this->empty())) __builtin_unreachable(); } while (false);
 return allocator_type(_M_alloc._M_alloc);
      }

      explicit operator bool() const noexcept { return _M_ptr != nullptr; }

      [[nodiscard]] bool empty() const noexcept { return _M_ptr == nullptr; }


    protected:
      constexpr _Node_handle_common() noexcept : _M_ptr() { }

      ~_Node_handle_common()
      {
 if (!empty())
   _M_reset();
      }

      _Node_handle_common(_Node_handle_common&& __nh) noexcept
      : _M_ptr(__nh._M_ptr)
      {
 if (_M_ptr)
   _M_move(std::move(__nh));
      }

      _Node_handle_common&
      operator=(_Node_handle_common&& __nh) noexcept
      {
 if (empty())
   {
     if (!__nh.empty())
       _M_move(std::move(__nh));
   }
 else if (__nh.empty())
   _M_reset();
 else
   {

     _AllocTraits::destroy(*_M_alloc, _M_ptr->_M_valptr());
     _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);

     _M_alloc = __nh._M_alloc.release();
     _M_ptr = __nh._M_ptr;
     __nh._M_ptr = nullptr;
   }
 return *this;
      }

      _Node_handle_common(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _M_ptr(__ptr), _M_alloc(__alloc)
      {
 do { if (__builtin_is_constant_evaluated() && !bool(__ptr != nullptr)) __builtin_unreachable(); } while (false);
      }

      void
      _M_swap(_Node_handle_common& __nh) noexcept
      {
 if (empty())
   {
     if (!__nh.empty())
       _M_move(std::move(__nh));
   }
 else if (__nh.empty())
   __nh._M_move(std::move(*this));
 else
   {
     using std::swap;
     swap(_M_ptr, __nh._M_ptr);
     _M_alloc.swap(__nh._M_alloc);
   }
      }

    private:



      void
      _M_move(_Node_handle_common&& __nh) noexcept
      {
 ::new (std::__addressof(_M_alloc)) _NodeAlloc(__nh._M_alloc.release());
 _M_ptr = __nh._M_ptr;
 __nh._M_ptr = nullptr;
      }




      void
      _M_reset() noexcept
      {
 _NodeAlloc __alloc = _M_alloc.release();
 _AllocTraits::destroy(__alloc, _M_ptr->_M_valptr());
 _AllocTraits::deallocate(__alloc, _M_ptr, 1);
 _M_ptr = nullptr;
      }

    protected:
      typename _AllocTraits::pointer _M_ptr;

    private:


      union _Optional_alloc
      {
 _Optional_alloc() { }
 ~_Optional_alloc() { }

 _Optional_alloc(_Optional_alloc&&) = delete;
 _Optional_alloc& operator=(_Optional_alloc&&) = delete;

 _Optional_alloc(const _NodeAlloc& __alloc) noexcept
 : _M_alloc(__alloc)
 { }


 void
 operator=(_NodeAlloc&& __alloc) noexcept
 {
   using _ATr = _AllocTraits;
   if constexpr (_ATr::propagate_on_container_move_assignment::value)
     _M_alloc = std::move(__alloc);
   else if constexpr (!_AllocTraits::is_always_equal::value)
     do { if (__builtin_is_constant_evaluated() && !bool(_M_alloc == __alloc)) __builtin_unreachable(); } while (false);
 }


 void
 swap(_Optional_alloc& __other) noexcept
 {
   using std::swap;
   if constexpr (_AllocTraits::propagate_on_container_swap::value)
     swap(_M_alloc, __other._M_alloc);
   else if constexpr (!_AllocTraits::is_always_equal::value)
     do { if (__builtin_is_constant_evaluated() && !bool(_M_alloc == __other._M_alloc)) __builtin_unreachable(); } while (false);
 }


 _NodeAlloc& operator*() noexcept { return _M_alloc; }


 _NodeAlloc release() noexcept
 {
   _NodeAlloc __tmp = std::move(_M_alloc);
   _M_alloc.~_NodeAlloc();
   return __tmp;
 }

 struct _Empty { };

 [[__no_unique_address__]] _Empty _M_empty;
 [[__no_unique_address__]] _NodeAlloc _M_alloc;
      };

      [[__no_unique_address__]] _Optional_alloc _M_alloc;

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;


    };


  template<typename _Key, typename _Value, typename _NodeAlloc>
    class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using key_type = _Key;
      using mapped_type = typename _Value::second_type;

      key_type&
      key() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!this->empty())) __builtin_unreachable(); } while (false);
 return *_M_pkey;
      }

      mapped_type&
      mapped() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!this->empty())) __builtin_unreachable(); } while (false);
 return *_M_pmapped;
      }

      void
      swap(_Node_handle& __nh) noexcept
      {
 this->_M_swap(__nh);
 using std::swap;
 swap(_M_pkey, __nh._M_pkey);
 swap(_M_pmapped, __nh._M_pmapped);
      }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)
      {
 if (__ptr)
   {
     auto& __key = const_cast<_Key&>(__ptr->_M_valptr()->first);
     _M_pkey = _S_pointer_to(__key);
     _M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);
   }
 else
   {
     _M_pkey = nullptr;
     _M_pmapped = nullptr;
   }
      }

      template<typename _Tp>
 using __pointer
   = __ptr_rebind<typename _AllocTraits::pointer,
    remove_reference_t<_Tp>>;

      __pointer<_Key> _M_pkey = nullptr;
      __pointer<typename _Value::second_type> _M_pmapped = nullptr;

      template<typename _Tp>
 __pointer<_Tp>
 _S_pointer_to(_Tp& __obj)
 { return pointer_traits<__pointer<_Tp>>::pointer_to(__obj); }

      const key_type&
      _M_key() const noexcept { return key(); }

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _Hash, typename _RangeHash, typename _Unused,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Value, typename _NodeAlloc>
    class _Node_handle<_Value, _Value, _NodeAlloc>
    : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using value_type = _Value;

      value_type&
      value() const noexcept
      {
 do { if (__builtin_is_constant_evaluated() && !bool(!this->empty())) __builtin_unreachable(); } while (false);
 return *this->_M_ptr->_M_valptr();
      }

      void
      swap(_Node_handle& __nh) noexcept
      { this->_M_swap(__nh); }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) { }

      const value_type&
      _M_key() const noexcept { return value(); }

      template<typename _Key, typename _Val, typename _KeyOfValue,
        typename _Compare, typename _Alloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _Hash, typename _RangeHash, typename _Unused,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Iterator, typename _NodeHandle>
    struct _Node_insert_return
    {
      _Iterator position = _Iterator();
      bool inserted = false;
      _NodeHandle node;
    };




}
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __is_nothrow_invocable<const _Hash&, const _Tp&>>>;




  template<typename _Equal, typename _Hash, typename _Allocator>
    using _Hashtable_enable_default_ctor
      = _Enable_default_constructor<__and_<is_default_constructible<_Equal>,
           is_default_constructible<_Hash>,
           is_default_constructible<_Allocator>>{},
        __detail::_Hash_node_base>;
# 176 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _Hash, _RangeHash, _Unused, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _Hash, _RangeHash, _Unused,
          _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused,
        _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _Hash, _RangeHash, _Unused,
     _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 __alloc_rebind<_Alloc,
         __detail::_Hash_node<_Value,
         _Traits::__hash_cached::value>>>,
      private _Hashtable_enable_default_ctor<_Equal, _Hash, _Alloc>
    {
      static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
   "unordered container must have a non-const, non-volatile value_type");





      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __node_value_type =
 __detail::_Hash_node_value<_Value, __hash_cached::value>;
      using __node_ptr = typename __hashtable_alloc::__node_ptr;
      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __node_base_ptr = typename __hashtable_alloc::__node_base_ptr;
      using __buckets_ptr = typename __hashtable_alloc::__buckets_ptr;

      using __insert_base = __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _Hash,
           _RangeHash, _Unused,
           _RehashPolicy, _Traits>;
      using __enable_default_ctor
 = _Hashtable_enable_default_ctor<_Equal, _Hash, _Alloc>;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

      using iterator = typename __insert_base::iterator;

      using const_iterator = typename __insert_base::const_iterator;

      using local_iterator = __detail::_Local_iterator<key_type, _Value,
   _ExtractKey, _Hash, _RangeHash, _Unused,
          __constant_iterators::value,
          __hash_cached::value>;

      using const_local_iterator = __detail::_Local_const_iterator<
   key_type, _Value,
   _ExtractKey, _Hash, _RangeHash, _Unused,
   __constant_iterators::value, __hash_cached::value>;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __unique_keys = typename __traits_type::__unique_keys;

      using __hashtable_base = __detail::
 _Hashtable_base<_Key, _Value, _ExtractKey,
   _Equal, _Hash, _RangeHash, _Unused, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __insert_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _Hash, _RangeHash, _Unused,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _Hash, _RangeHash, _Unused,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_gen_t =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;
      using __alloc_node_gen_t =
 __detail::_AllocNode<__node_alloc_type>;


      struct _Scoped_node
      {

 _Scoped_node(__node_ptr __n, __hashtable_alloc* __h)
 : _M_h(__h), _M_node(__n) { }


 template<typename... _Args>
   _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
   : _M_h(__h),
     _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
   { }


 ~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };

 _Scoped_node(const _Scoped_node&) = delete;
 _Scoped_node& operator=(const _Scoped_node&) = delete;

 __hashtable_alloc* _M_h;
 __node_ptr _M_node;
      };

      template<typename _Ht>
 static constexpr
 typename conditional<std::is_lvalue_reference<_Ht>::value,
        const value_type&, value_type&&>::type
 __fwd_value_for(value_type& __val) noexcept
 { return std::move(__val); }





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
   ._M_bucket_index(declval<const __node_value_type&>(),
      (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");


      static_assert(is_nothrow_default_constructible<_RangeHash>::value,
      "Functor used to map hash code to bucket index"
      " must be nothrow default constructible");
      static_assert(noexcept(
 std::declval<const _RangeHash&>()((std::size_t)0, (std::size_t)0)),
      "Functor used to map hash code to bucket index must be"
      " noexcept");


      static_assert(is_nothrow_default_constructible<_ExtractKey>::value,
      "_ExtractKey must be nothrow default constructible");
      static_assert(noexcept(
 std::declval<const _ExtractKey&>()(std::declval<_Value>())),
      "_ExtractKey functor must be noexcept invocable");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa>
 friend struct __detail::_Insert;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _Hasha, typename _RangeHasha, typename _Unuseda,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Equality;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;


      using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;
      using insert_return_type = _Node_insert_return<iterator, node_type>;


    private:
      __buckets_ptr _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __node_base_ptr _M_single_bucket = nullptr;

      void
      _M_update_bbegin()
      {
 if (_M_begin())
   _M_buckets[_M_bucket_index(*_M_begin())] = &_M_before_begin;
      }

      void
      _M_update_bbegin(__node_ptr __n)
      {
 _M_before_begin._M_nxt = __n;
 _M_update_bbegin();
      }

      bool
      _M_uses_single_bucket(__buckets_ptr __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __buckets_ptr
      _M_allocate_buckets(size_type __bkt_count)
      {
 if (__builtin_expect(__bkt_count == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
      }

      void
      _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_ptr
      _M_bucket_begin(size_type __bkt) const;

      __node_ptr
      _M_begin() const
      { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }



      template<typename _Ht>
 void
 _M_assign_elements(_Ht&&);

      template<typename _Ht, typename _NodeGenerator>
 void
 _M_assign(_Ht&&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, true_type);

      void
      _M_move_assign(_Hashtable&&, false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _Hash& __h, const _Equal& __eq,
   const allocator_type& __a)
      : __hashtable_base(__h, __eq),
 __hashtable_alloc(__node_alloc_type(__a)),
 __enable_default_ctor(_Enable_default_constructor_tag{})
      { }

      template<bool _No_realloc = true>
 static constexpr bool
 _S_nothrow_move()
 {





   if constexpr (_No_realloc)
     if constexpr (is_nothrow_copy_constructible<_Hash>())
       return is_nothrow_copy_constructible<_Equal>();
   return false;

 }

      _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
   true_type )
 noexcept(_S_nothrow_move());

      _Hashtable(_Hashtable&&, __node_alloc_type&&,
   false_type );

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bkt_count_hint,
     const _Hash&, const _Equal&, const allocator_type&,
     true_type __uks);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bkt_count_hint,
     const _Hash&, const _Equal&, const allocator_type&,
     false_type __uks);

    public:

      _Hashtable() = default;

      _Hashtable(const _Hashtable&);

      _Hashtable(const _Hashtable&, const allocator_type&);

      explicit
      _Hashtable(size_type __bkt_count_hint,
   const _Hash& __hf = _Hash(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type());


      _Hashtable(_Hashtable&& __ht)
 noexcept(_S_nothrow_move())
      : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
     true_type{})
      { }

      _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
 noexcept(_S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
      : _Hashtable(std::move(__ht), __node_alloc_type(__a),
     typename __node_alloc_traits::is_always_equal{})
      { }

      explicit
      _Hashtable(const allocator_type& __a)
      : __hashtable_alloc(__node_alloc_type(__a)),
 __enable_default_ctor(_Enable_default_constructor_tag{})
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __bkt_count_hint = 0,
     const _Hash& __hf = _Hash(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
       __unique_keys{})
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __bkt_count_hint = 0,
   const _Hash& __hf = _Hash(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
     __hf, __eql, __a, __unique_keys{})
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Hash>::value
        && is_nothrow_move_assignable<_Equal>::value)
      {
 constexpr bool __move_storage =
   __node_alloc_traits::_S_propagate_on_move_assign()
   || __node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();


 auto __l_bkt_count = _M_rehash_policy._M_bkt_for_elements(__l.size());


 if (_M_bucket_count < __l_bkt_count)
   rehash(__l_bkt_count);

 this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys{});
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__and_<__is_nothrow_swappable<_Hash>,
        __is_nothrow_swappable<_Equal>>::value);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      [[__nodiscard__]] bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __bkt) const
      { return std::distance(begin(__bkt), end(__bkt)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __bkt)
      {
 return local_iterator(*this, _M_bucket_begin(__bkt),
         __bkt, _M_bucket_count);
      }

      local_iterator
      end(size_type __bkt)
      { return local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      const_local_iterator
      begin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy& __pol)
      { _M_rehash_policy = __pol; }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;
# 787 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3
    private:

      size_type
      _M_bucket_index(const __node_value_type& __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(__hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }



      __node_base_ptr
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      template<typename _Kt>
 __node_base_ptr
 _M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;

      __node_ptr
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_ptr>(__before_n->_M_nxt);
 return nullptr;
      }

      template<typename _Kt>
 __node_ptr
 _M_find_node_tr(size_type __bkt, const _Kt& __key,
   __hash_code __c) const
 {
   auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
   if (__before_n)
     return static_cast<__node_ptr>(__before_n->_M_nxt);
   return nullptr;
 }


      void
      _M_insert_bucket_begin(size_type, __node_ptr);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_ptr __next_n,
        size_type __next_bkt);


      __node_base_ptr
      _M_get_previous_node(size_type __bkt, __node_ptr __n);




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code,
       __node_ptr __n, size_type __n_elt = 1);



      iterator
      _M_insert_multi_node(__node_ptr __hint,
      __hash_code __code, __node_ptr __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(true_type __uks, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(false_type __uks, _Args&&... __args)
 { return _M_emplace(cend(), __uks, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, true_type __uks, _Args&&... __args)
 { return _M_emplace(__uks, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, false_type __uks, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, true_type __uks);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    false_type __uks)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uks);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, true_type __uks)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uks).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, false_type __uks);

      size_type
      _M_erase(true_type __uks, const key_type&);

      size_type
      _M_erase(false_type __uks, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys{}, std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys{},
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys{}, __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;



      void rehash(size_type __bkt_count);






      insert_return_type
      _M_reinsert_node(node_type&& __nh)
      {
 insert_return_type __ret;
 if (__nh.empty())
   __ret.position = end();
 else
   {
     do { if (__builtin_is_constant_evaluated() && !bool(get_allocator() == __nh.get_allocator())) __builtin_unreachable(); } while (false);

     const key_type& __k = __nh._M_key();
     __hash_code __code = this->_M_hash_code(__k);
     size_type __bkt = _M_bucket_index(__code);
     if (__node_ptr __n = _M_find_node(__bkt, __k, __code))
       {
  __ret.node = std::move(__nh);
  __ret.position = iterator(__n);
  __ret.inserted = false;
       }
     else
       {
  __ret.position
    = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);
  __nh._M_ptr = nullptr;
  __ret.inserted = true;
       }
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)
      {
 if (__nh.empty())
   return end();

 do { if (__builtin_is_constant_evaluated() && !bool(get_allocator() == __nh.get_allocator())) __builtin_unreachable(); } while (false);

 const key_type& __k = __nh._M_key();
 auto __code = this->_M_hash_code(__k);
 auto __ret
   = _M_insert_multi_node(__hint._M_cur, __code, __nh._M_ptr);
 __nh._M_ptr = nullptr;
 return __ret;
      }

    private:
      node_type
      _M_extract_node(size_t __bkt, __node_base_ptr __prev_n)
      {
 __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
 if (__prev_n == _M_buckets[__bkt])
   _M_remove_bucket_begin(__bkt, __n->_M_next(),
      __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);
 else if (__n->_M_nxt)
   {
     size_type __next_bkt = _M_bucket_index(*__n->_M_next());
     if (__next_bkt != __bkt)
       _M_buckets[__next_bkt] = __prev_n;
   }

 __prev_n->_M_nxt = __n->_M_nxt;
 __n->_M_nxt = nullptr;
 --_M_element_count;
 return { __n, this->_M_node_allocator() };
      }

    public:

      node_type
      extract(const_iterator __pos)
      {
 size_t __bkt = _M_bucket_index(*__pos._M_cur);
 return _M_extract_node(__bkt,
          _M_get_previous_node(__bkt, __pos._M_cur));
      }


      node_type
      extract(const _Key& __k)
      {
 node_type __nh;
 __hash_code __code = this->_M_hash_code(__k);
 std::size_t __bkt = _M_bucket_index(__code);
 if (__node_base_ptr __prev_node = _M_find_before_node(__bkt, __k, __code))
   __nh = _M_extract_node(__bkt, __prev_node);
 return __nh;
      }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_unique(_Compatible_Hashtable& __src) noexcept
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
   do { if (__builtin_is_constant_evaluated() && !bool(get_allocator() == __src.get_allocator())) __builtin_unreachable(); } while (false);

   auto __n_elt = __src.size();
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     {
       auto __pos = __i++;
       const key_type& __k = _ExtractKey{}(*__pos);
       __hash_code __code = this->_M_hash_code(__k);
       size_type __bkt = _M_bucket_index(__code);
       if (_M_find_node(__bkt, __k, __code) == nullptr)
  {
    auto __nh = __src.extract(__pos);
    _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);
    __nh._M_ptr = nullptr;
    __n_elt = 1;
  }
       else if (__n_elt != 1)
  --__n_elt;
     }
 }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_multi(_Compatible_Hashtable& __src) noexcept
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
   do { if (__builtin_is_constant_evaluated() && !bool(get_allocator() == __src.get_allocator())) __builtin_unreachable(); } while (false);

   this->reserve(size() + __src.size());
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     _M_reinsert_node_multi(cend(), __src.extract(__i++));
 }


    private:

      void _M_rehash_aux(size_type __bkt_count, true_type __uks);


      void _M_rehash_aux(size_type __bkt_count, false_type __uks);



      void _M_rehash(size_type __bkt_count, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    -> __node_ptr
    {
      __node_base_ptr __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bkt_count_hint,
        const _Hash& __h, const _Equal& __eq, const allocator_type& __a)
    : _Hashtable(__h, __eq, __a)
    {
      auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
      if (__bkt_count > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt_count);
   _M_bucket_count = __bkt_count;
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bkt_count_hint,
   const _Hash& __h, const _Equal& __eq,
   const allocator_type& __a, true_type )
      : _Hashtable(__bkt_count_hint, __h, __eq, __a)
      {
 for (; __f != __l; ++__f)
   this->insert(*__f);
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bkt_count_hint,
   const _Hash& __h, const _Equal& __eq,
   const allocator_type& __a, false_type )
      : _Hashtable(__h, __eq, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bkt_count_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 for (; __f != __l; ++__f)
   this->insert(*__f);
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       __alloc_node_gen_t __alloc_node_gen(*this);
       try
  {
    _M_assign(__ht, __alloc_node_gen);
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      _M_assign_elements(__ht);
      return *this;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Ht>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_assign_elements(_Ht&& __ht)
      {
 __buckets_ptr __former_buckets = nullptr;
 std::size_t __former_bucket_count = _M_bucket_count;
 const __rehash_state& __former_state = _M_rehash_policy._M_state();

 if (_M_bucket_count != __ht._M_bucket_count)
   {
     __former_buckets = _M_buckets;
     _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
     _M_bucket_count = __ht._M_bucket_count;
   }
 else
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__node_base_ptr));

 try
   {
     __hashtable_base::operator=(std::forward<_Ht>(__ht));
     _M_element_count = __ht._M_element_count;
     _M_rehash_policy = __ht._M_rehash_policy;
     __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
     _M_before_begin._M_nxt = nullptr;
     _M_assign(std::forward<_Ht>(__ht), __roan);
     if (__former_buckets)
       _M_deallocate_buckets(__former_buckets, __former_bucket_count);
   }
 catch(...)
   {
     if (__former_buckets)
       {

  _M_deallocate_buckets();
  _M_rehash_policy._M_reset(__former_state);
  _M_buckets = __former_buckets;
  _M_bucket_count = __former_bucket_count;
       }
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__node_base_ptr));
     throw;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Ht, typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)
      {
 __buckets_ptr __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_ptr __ht_n = __ht._M_begin();
     __node_ptr __this_n
       = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
     this->_M_copy_code(*__this_n, *__ht_n);
     _M_update_bbegin(__this_n);


     __node_ptr __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(*__this_n, *__ht_n);
  size_type __bkt = _M_bucket_index(*__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, true_type)
    {
      if (__builtin_expect(std::__addressof(__ht) == this, false))
 return;

      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }

      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());


      _M_update_bbegin();
      __ht._M_reset();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), true_type{});
      else
 {

   _M_assign_elements(std::move(__ht));
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      __enable_default_ctor(__ht),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      __alloc_node_gen_t __alloc_node_gen(*this);
      _M_assign(__ht, __alloc_node_gen);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
        true_type )
    noexcept(_S_nothrow_move())
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }


      _M_update_bbegin();

      __ht._M_reset();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      __alloc_node_gen_t __alloc_node_gen(*this);
      _M_assign(__ht, __alloc_node_gen);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,
        false_type )
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__a)),
      __enable_default_ctor(__ht),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;



   _M_update_bbegin(__ht._M_begin());

   __ht._M_reset();
 }
      else
 {
   __alloc_node_gen_t __alloc_gen(*this);

   using _Fwd_Ht = typename
     conditional<__move_if_noexcept_cond<value_type>::value,
   const _Hashtable&, _Hashtable&&>::type;
   _M_assign(std::forward<_Fwd_Ht>(__ht), __alloc_gen);
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__and_<__is_nothrow_swappable<_Hash>,
   __is_nothrow_swappable<_Equal>>::value)
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      _M_update_bbegin();
      __x._M_update_bbegin();
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);
      return iterator(_M_find_node(__bkt, __k, __code));
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);
      return const_iterator(_M_find_node(__bkt, __k, __code));
    }
# 1647 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      auto __it = find(__k);
      if (!__it._M_cur)
 return 0;

      if (__unique_keys::value)
 return 1;




      size_type __result = 1;
      for (auto __ref = __it++;
    __it._M_cur && this->_M_node_equals(*__ref._M_cur, *__it._M_cur);
    ++__it)
 ++__result;

      return __result;
    }
# 1708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      auto __ite = find(__k);
      if (!__ite._M_cur)
 return { __ite, __ite };

      auto __beg = __ite++;
      if (__unique_keys::value)
 return { __beg, __ite };




      while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
 ++__ite;

      return { __beg, __ite };
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      auto __ite = find(__k);
      if (!__ite._M_cur)
 return { __ite, __ite };

      auto __beg = __ite++;
      if (__unique_keys::value)
 return { __beg, __ite };




      while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
 ++__ite;

      return { __beg, __ite };
    }
# 1822 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __bkt, const key_type& __k,
   __hash_code __code) const
    -> __node_base_ptr
    {
      __node_base_ptr __prev_p = _M_buckets[__bkt];
      if (!__prev_p)
 return nullptr;

      for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, *__p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
     break;
   __prev_p = __p;
 }

      return nullptr;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Kt>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_find_before_node_tr(size_type __bkt, const _Kt& __k,
        __hash_code __code) const
      -> __node_base_ptr
      {
 __node_base_ptr __prev_p = _M_buckets[__bkt];
 if (!__prev_p)
   return nullptr;

 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
      __p = __p->_M_next())
   {
     if (this->_M_equals_tr(__k, __code, *__p))
       return __prev_p;

     if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
       break;
     __prev_p = __p;
   }

 return nullptr;
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;

   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;

   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_ptr __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_ptr __n)
    -> __node_base_ptr
    {
      __node_base_ptr __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_emplace(true_type , _Args&&... __args)
      -> pair<iterator, bool>
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__code);
 if (__node_ptr __p = _M_find_node(__bkt, __k, __code))

   return std::make_pair(iterator(__p), false);


 auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
 __node._M_node = nullptr;
 return { __pos, true };
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, false_type ,
   _Args&&... __args)
      -> iterator
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = _ExtractKey{}(__node._M_node->_M_v());

 __hash_code __code = this->_M_hash_code(__k);
 auto __pos
   = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_ptr __node, size_type __n_elt)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
       __n_elt);

      if (__do_rehash.first)
 {
   _M_rehash(__do_rehash.second, __saved_state);
   __bkt = _M_bucket_index(__code);
 }

      this->_M_store_code(*__node, __code);


      _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_ptr __hint,
    __hash_code __code, __node_ptr __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      if (__do_rehash.first)
 _M_rehash(__do_rehash.second, __saved_state);

      this->_M_store_code(*__node, __code);
      const key_type& __k = _ExtractKey{}(__node->_M_v());
      size_type __bkt = _M_bucket_index(__code);



      __node_base_ptr __prev
 = __builtin_expect(__hint != nullptr, false)
   && this->_M_equals(__k, __code, *__hint)
     ? __hint
     : _M_find_before_node(__bkt, __k, __code);

      if (__prev)
 {

   __node->_M_nxt = __prev->_M_nxt;
   __prev->_M_nxt = __node;
   if (__builtin_expect(__prev == __hint, false))


     if (__node->_M_nxt
  && !this->_M_equals(__k, __code, *__node->_M_next()))
       {
  size_type __next_bkt = _M_bucket_index(*__node->_M_next());
  if (__next_bkt != __bkt)
    _M_buckets[__next_bkt] = __node;
       }
 }
      else



 _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen,
  true_type )
      -> pair<iterator, bool>
      {
 const key_type& __k = _ExtractKey{}(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__code);

 if (__node_ptr __node = _M_find_node(__bkt, __k, __code))
   return { iterator(__node), false };

 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
 auto __pos
   = _M_insert_unique_node(__bkt, __code, __node._M_node);
 __node._M_node = nullptr;
 return { __pos, true };
      }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen,
  false_type )
      -> iterator
      {


 __hash_code __code = this->_M_hash_code(_ExtractKey{}(__v));


 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
 auto __pos
   = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_ptr __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(*__n);




      __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base_ptr __prev_n, __node_ptr __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
   __n->_M_nxt ? _M_bucket_index(*__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(*__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_erase(true_type , const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);


      __node_base_ptr __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_erase(false_type , const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);


      __node_base_ptr __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
      __node_ptr __n_last = __n->_M_next();
      while (__n_last && this->_M_node_equals(*__n, *__n_last))
 __n_last = __n_last->_M_next();

      std::size_t __n_last_bkt = __n_last ? _M_bucket_index(*__n_last) : __bkt;


      size_type __result = 0;
      do
 {
   __node_ptr __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
 }
      while (__n != __n_last);

      _M_element_count -= __result;
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_ptr __n = __first._M_cur;
      __node_ptr __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(*__n);

      __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_ptr __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(*__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0,
         _M_bucket_count * sizeof(__node_base_ptr));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    rehash(size_type __bkt_count)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      __bkt_count
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __bkt_count);
      __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);

      if (__bkt_count != _M_bucket_count)
 _M_rehash(__bkt_count, __saved_state);
      else


 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_rehash(size_type __bkt_count, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__bkt_count, __unique_keys{});
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __bkt_count, true_type )
    {
      __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
      __node_ptr __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_ptr __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }

   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _Hash, typename _RangeHash, typename _Unused,
    typename _RehashPolicy, typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __bkt_count, false_type )
    {
      __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
      __node_ptr __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_ptr __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_ptr __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(*__p, __bkt_count);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(
     *__prev_p->_M_next(), __bkt_count);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(*__prev_p->_M_next(),
      __bkt_count);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }


  template<typename, typename, typename> class _Hash_merge_helper { };




  template<typename _Hash>
    using _RequireNotAllocatorOrIntegral
      = __enable_if_t<!__or_<is_integral<_Hash>, __is_allocator<_Hash>>::value>;




}
# 47 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    class unordered_multimap;
# 98 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;
      using insert_return_type = typename _Hashtable::insert_return_type;





      unordered_map() = default;
# 150 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 171 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
      : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
 noexcept( noexcept(_Hashtable(std::move(__umap._M_h), __a)) )
      : _M_h(std::move(__umap._M_h), __a)
      { }
# 227 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a)
      { }

      unordered_map(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
   : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_map(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 289 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 386 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 417 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }



      node_type
      extract(const_iterator __pos)
      {
 do { if (__builtin_is_constant_evaluated() && !bool(__pos != end())) __builtin_unreachable(); } while (false);
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      insert_return_type
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)); }


      iterator
      insert(const_iterator, node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)).position; }
# 469 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template <typename... _Args>
 pair<iterator, bool>
 try_emplace(const key_type& __k, _Args&&... __args)
 {
   return _M_h.try_emplace(cend(), __k, std::forward<_Args>(__args)...);
 }


      template <typename... _Args>
 pair<iterator, bool>
 try_emplace(key_type&& __k, _Args&&... __args)
 {
   return _M_h.try_emplace(cend(), std::move(__k),
      std::forward<_Args>(__args)...);
 }
# 513 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template <typename... _Args>
 iterator
 try_emplace(const_iterator __hint, const key_type& __k,
      _Args&&... __args)
 {
   return _M_h.try_emplace(__hint, __k,
      std::forward<_Args>(__args)...).first;
 }


      template <typename... _Args>
 iterator
 try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)
 {
   return _M_h.try_emplace(__hint, std::move(__k),
      std::forward<_Args>(__args)...).first;
 }
# 550 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }



      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 589 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 614 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 626 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 652 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template <typename _Obj>
 pair<iterator, bool>
 insert_or_assign(const key_type& __k, _Obj&& __obj)
 {
   auto __ret = _M_h.try_emplace(cend(), __k,
     std::forward<_Obj>(__obj));
   if (!__ret.second)
     __ret.first->second = std::forward<_Obj>(__obj);
   return __ret;
 }


      template <typename _Obj>
 pair<iterator, bool>
 insert_or_assign(key_type&& __k, _Obj&& __obj)
 {
   auto __ret = _M_h.try_emplace(cend(), std::move(__k),
     std::forward<_Obj>(__obj));
   if (!__ret.second)
     __ret.first->second = std::forward<_Obj>(__obj);
   return __ret;
 }
# 701 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template <typename _Obj>
 iterator
 insert_or_assign(const_iterator __hint, const key_type& __k,
    _Obj&& __obj)
 {
   auto __ret = _M_h.try_emplace(__hint, __k, std::forward<_Obj>(__obj));
   if (!__ret.second)
     __ret.first->second = std::forward<_Obj>(__obj);
   return __ret.first;
 }


      template <typename _Obj>
 iterator
 insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)
 {
   auto __ret = _M_h.try_emplace(__hint, std::move(__k),
     std::forward<_Obj>(__obj));
   if (!__ret.second)
     __ret.first->second = std::forward<_Obj>(__obj);
   return __ret.first;
 }
# 739 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 761 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 779 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 803 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class std::_Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 867 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }
# 878 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 900 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 940 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }
# 952 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 978 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 995 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1051 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1066 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1077 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1114 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1125 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
     const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };



  template<typename _InputIterator,
    typename _Hash = hash<__iter_key_t<_InputIterator>>,
    typename _Pred = equal_to<__iter_key_t<_InputIterator>>,
    typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator,
    typename unordered_map<int, int>::size_type = {},
    _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>,
       _Hash, _Pred, _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Allocator = allocator<pair<const _Key, _Tp>>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>,
    typename unordered_map<int, int>::size_type = {},
    _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
    -> unordered_map<_Key, _Tp, _Hash, _Pred, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator,
    typename unordered_map<int, int>::size_type, _Allocator)
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>,
       hash<__iter_key_t<_InputIterator>>,
       equal_to<__iter_key_t<_InputIterator>>,
       _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator, _Allocator)
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>,
       hash<__iter_key_t<_InputIterator>>,
       equal_to<__iter_key_t<_InputIterator>>,
       _Allocator>;

  template<typename _InputIterator, typename _Hash, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator,
    typename unordered_map<int, int>::size_type,
    _Hash, _Allocator)
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>, _Hash,
       equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>,
    typename unordered_map<int, int>::size_type,
    _Allocator)
    -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator)
    -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash, typename _Allocator,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>,
    typename unordered_map<int, int>::size_type,
    _Hash, _Allocator)
    -> unordered_map<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;
# 1241 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;





      unordered_multimap() = default;
# 1292 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 1313 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
      : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
 noexcept( noexcept(_Hashtable(std::move(__ummap._M_h), __a)) )
      : _M_h(std::move(__ummap._M_h), __a)
      { }
# 1369 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 1431 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1550 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1565 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 1599 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 1624 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1637 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }



      node_type
      extract(const_iterator __pos)
      {
 do { if (__builtin_is_constant_evaluated() && !bool(__pos != end())) __builtin_unreachable(); } while (false);
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      iterator
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }


      iterator
      insert(const_iterator __hint, node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
# 1680 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 1701 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1720 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1744 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class std::_Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1810 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }
# 1821 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 1839 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1877 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }
# 1889 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 1905 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1949 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1964 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1975 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 2012 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 2023 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };



  template<typename _InputIterator,
    typename _Hash = hash<__iter_key_t<_InputIterator>>,
    typename _Pred = equal_to<__iter_key_t<_InputIterator>>,
    typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator,
         unordered_multimap<int, int>::size_type = {},
         _Hash = _Hash(), _Pred = _Pred(),
         _Allocator = _Allocator())
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>, _Hash, _Pred,
     _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Allocator = allocator<pair<const _Key, _Tp>>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>,
         unordered_multimap<int, int>::size_type = {},
         _Hash = _Hash(), _Pred = _Pred(),
         _Allocator = _Allocator())
    -> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator,
         unordered_multimap<int, int>::size_type, _Allocator)
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>,
     hash<__iter_key_t<_InputIterator>>,
     equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator, _Allocator)
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>,
     hash<__iter_key_t<_InputIterator>>,
     equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _InputIterator, typename _Hash, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator,
         unordered_multimap<int, int>::size_type, _Hash,
         _Allocator)
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>, _Hash,
     equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>,
         unordered_multimap<int, int>::size_type,
         _Allocator)
    -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
    -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash, typename _Allocator,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>,
         unordered_multimap<int, int>::size_type,
         _Hash, _Allocator)
    -> unordered_multimap<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;



  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }


  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }


  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }






  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,
    typename _Alloc, typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_map = std::unordered_map<_Tp...>;
      template<typename... _Tp>
 using unordered_multimap = std::unordered_multimap<_Tp...>;

      friend unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }

      static auto&
      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }
    };


  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,
    typename _Alloc, typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_map = std::unordered_map<_Tp...>;
      template<typename... _Tp>
 using unordered_multimap = std::unordered_multimap<_Tp...>;

      friend unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }

      static auto&
      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }
    };



}
# 48 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 2 3

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/erase_if.h" 1 3
# 33 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/erase_if.h" 3
       
# 34 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/erase_if.h" 3





namespace std
{






  namespace __detail
  {
    template<typename _Container, typename _Predicate>
      typename _Container::size_type
      __erase_nodes_if(_Container& __cont, _Predicate __pred)
      {
 typename _Container::size_type __num = 0;
 for (auto __iter = __cont.begin(), __last = __cont.end();
      __iter != __last;)
   {
     if (__pred(*__iter))
       {
  __iter = __cont.erase(__iter);
  ++__num;
       }
     else
       ++__iter;
   }
 return __num;
      }
  }


}
# 50 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/unordered_map" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr
  {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,
      typename _Pred = std::equal_to<_Key>>
      using unordered_map
 = std::unordered_map<_Key, _Tp, _Hash, _Pred,
        polymorphic_allocator<pair<const _Key, _Tp>>>;
    template<typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,
      typename _Pred = std::equal_to<_Key>>
      using unordered_multimap
 = std::unordered_multimap<_Key, _Tp, _Hash, _Pred,
      polymorphic_allocator<pair<const _Key, _Tp>>>;
  }

}
# 62 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 1 3
# 58 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 3
       
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 3
# 67 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 1 3
# 77 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl_data
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl_data(_Vector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish),
   _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }


 void
 _M_copy_data(_Vector_impl_data const& __x) noexcept
 {
   _M_start = __x._M_start;
   _M_finish = __x._M_finish;
   _M_end_of_storage = __x._M_end_of_storage;
 }

 void
 _M_swap_data(_Vector_impl_data& __x) noexcept
 {


   _Vector_impl_data __tmp;
   __tmp._M_copy_data(*this);
   _M_copy_data(__x);
   __x._M_copy_data(__tmp);
 }
      };

      struct _Vector_impl
 : public _Tp_alloc_type, public _Vector_impl_data
      {
 _Vector_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)

 : _Tp_alloc_type()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a)
 { }




 _Vector_impl(_Vector_impl&& __x) noexcept
 : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
 { }

 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 _Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
 : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
 { }
# 270 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }


      _Vector_base() = default;




      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }



      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }


      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Vector_base&&) = default;



      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      { }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    protected:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 388 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 401 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");






      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:

      static constexpr bool
      _S_nothrow_relocate(true_type)
      {
 return noexcept(std::__relocate_a(std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<_Tp_alloc_type&>()));
      }

      static constexpr bool
      _S_nothrow_relocate(false_type)
      { return false; }

      static constexpr bool
      _S_use_relocate()
      {



 return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
      }

      static pointer
      _S_do_relocate(pointer __first, pointer __last, pointer __result,
       _Tp_alloc_type& __alloc, true_type) noexcept
      {
 return std::__relocate_a(__first, __last, __result, __alloc);
      }

      static pointer
      _S_do_relocate(pointer, pointer, pointer __result,
       _Tp_alloc_type&, false_type) noexcept
      { return __result; }

      static pointer
      _S_relocate(pointer __first, pointer __last, pointer __result,
    _Tp_alloc_type& __alloc) noexcept
      {
 using __do_it = __bool_constant<_S_use_relocate()>;
 return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
      }


    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:







      vector() = default;
# 496 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 509 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_default_initialize(__n); }
# 522 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_fill_initialize(__n, __value); }
# 553 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 572 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector(vector&&) noexcept = default;


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }

    private:
      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
      : _Base(__m, std::move(__rv))
      { }

      vector(vector&& __rv, const allocator_type& __m, false_type)
      : _Base(__m)
      {
 if (__rv.get_allocator() == __m)
   this->_M_impl._M_swap_data(__rv._M_impl);
 else if (!__rv.empty())
   {
     this->_M_create_storage(__rv.size());
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }

    public:

      vector(vector&& __rv, const allocator_type& __m)
      noexcept( noexcept(
 vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
        std::declval<typename _Alloc_traits::is_always_equal>())) )
      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
      { }
# 625 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 651 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 678 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 ;
      }
# 694 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 708 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 729 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 748 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 765 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 793 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 936 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 956 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 988 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      [[__nodiscard__]] bool
      empty() const noexcept
      { return begin() == end(); }
# 1027 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 1042 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 1060 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1091 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1109 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 1167 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1186 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>

 reference



 emplace_back(_Args&&... __args);
# 1224 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
 ;
      }
# 1246 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1262 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1292 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1309 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1334 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1376 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1428 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1455 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1479 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {

 do { if (__builtin_is_constant_evaluated() && !bool(_Alloc_traits::propagate_on_container_swap::value || _M_get_Tp_allocator() == __x._M_get_Tp_allocator())) __builtin_unreachable(); } while (false)
                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1556 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start
     = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1618 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1705 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *_M_ptr(); }

      private:
 _Tp*
 _M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + (std::max)(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }


      static size_type
      _S_check_init_len(size_type __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(_Tp_alloc_type(__a)))
   __throw_length_error(
       ("cannot create std::vector larger than max_size()"));
 return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {



 const size_t __diffmax
   = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
     ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__x._M_impl);
 __tmp._M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), true_type());
 else
   {


     this->_M_assign_aux(std::make_move_iterator(__x.begin()),
           std::make_move_iterator(__x.end()),
    std::random_access_iterator_tag());
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1868 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
    };


  template<typename _InputIterator, typename _ValT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_ValT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> vector<_ValT, _Allocator>;
# 1890 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1928 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }



  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Alloc>
      struct _Never_valueless_alt<std::vector<_Tp, _Alloc>>
      : std::is_nothrow_move_assignable<std::vector<_Tp, _Alloc>>
      { };
  }



}
# 68 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 1 3
# 64 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }


    _Bit_reference(const _Bit_reference&) = default;


    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    friend bool
    operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }
# 199 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
    friend bool
    operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return __x._M_p < __y._M_p
     || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
    }

    friend bool
    operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x == __y); }

    friend bool
    operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __y < __x; }

    friend bool
    operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__y < __x); }

    friend bool
    operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x < __y); }


    friend ptrdiff_t
    operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return (int(_S_word_bit) * (__x._M_p - __y._M_p)
       + __x._M_offset - __y._M_offset);
    }
  };

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;



    typedef _Bit_reference* pointer;

    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend iterator
    operator+(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend iterator
    operator+(difference_type __n, const iterator& __x)
    { return __x + __n; }

    friend iterator
    operator-(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }
  };

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;



    typedef const bool* pointer;

    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend const_iterator
    operator+(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend const_iterator
    operator-(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }

    friend const_iterator
    operator+(difference_type __n, const const_iterator& __x)
    { return __x + __n; }
  };

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {

 _Bit_iterator _M_start;
# 440 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(const _Bvector_impl_data&) = default;
 _Bvector_impl_data&
 operator=(const _Bvector_impl_data&) = default;

 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _Bvector_impl_data(__x)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   *this = __x;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 { *this = _Bvector_impl_data(); }

 void
 _M_swap_data(_Bvector_impl_data& __x) noexcept
 {


   std::swap(*this, __x);
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
      {
 _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)

 : _Bit_alloc_type()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a) noexcept
 : _Bit_alloc_type(__a)
 { }




 _Bvector_impl(_Bvector_impl&& __x) noexcept
 : _Bit_alloc_type(std::move(__x)), _Bvector_impl_data(std::move(__x))
 { }

 _Bvector_impl(_Bit_alloc_type&& __a, _Bvector_impl&& __x) noexcept
 : _Bit_alloc_type(std::move(__a)), _Bvector_impl_data(std::move(__x))
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;

      _Bvector_base(_Bvector_base&& __x, const allocator_type& __a) noexcept
      : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl))
      { }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };
# 595 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), begin());
      }


      vector(vector&&) = default;

    private:
      vector(vector&& __x, const allocator_type& __a, true_type) noexcept
      : _Base(std::move(__x), __a)
      { }

      vector(vector&& __x, const allocator_type& __a, false_type)
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

    public:
      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : vector(std::move(__x), __a,
        typename _Bit_alloc_traits::is_always_equal{})
      { }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), begin());
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_initialize_range(__first, __last,
         std::__iterator_category(__first));
 }
# 733 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 825 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      [[__nodiscard__]] bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      { return begin()[__n]; }

      const_reference
      operator[](size_type __n) const
      { return begin()[__n]; }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {

 do { if (__builtin_is_constant_evaluated() && !bool(_Bit_alloc_traits::propagate_on_container_swap::value || _M_get_Bit_allocator() == __x._M_get_Bit_allocator())) __builtin_unreachable(); } while (false)
                                                            ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_range(__position._M_const_cast(),
     __first, __last,
     std::__iterator_category(__first));
   return begin() + __offset;
 }
# 1038 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>

 reference



 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));

   return back();

 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     iterator __start = iterator(std::__addressof(*__q), 0);
     this->_M_impl._M_start = __start;
     this->_M_impl._M_finish = __start + difference_type(__n);
   }
      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();
# 1185 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, begin());
 }
# 1219 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }
# 1283 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/stl_bvector.h" 3
      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



  inline void
  __fill_bvector(std::_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    using std::_Bit_type;
    using std::_S_word_bit;
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  __fill_a1(std::_Bit_iterator __first,
     std::_Bit_iterator __last, const bool& __x)
  {
    using std::_Bit_type;
    using std::_S_word_bit;
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };



}
# 69 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 2 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/vector.tcc" 1 3
# 59 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp;

   if constexpr (_S_use_relocate())
     {
       __tmp = this->_M_allocate(__n);
       _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
     __tmp, _M_get_Tp_allocator());
     }
   else

     {
       __tmp = _M_allocate_and_copy(__n,
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   ;
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>

      typename vector<_Tp, _Alloc>::reference



      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);

 return back();

      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
   ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
   ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     _S_check_init_len(__len, _M_get_Tp_allocator());
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     ;
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
      ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();


   if constexpr (_S_use_relocate())
     {
       __new_finish = _S_relocate(__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish = _S_relocate(__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
     }
   else

     {
       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__old_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), __old_finish,
   __new_finish, _M_get_Tp_allocator());
     }
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }

      if constexpr (!_S_use_relocate())

 std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      ;
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));
       if constexpr (_S_use_relocate())
  {
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
      }
    catch(...)
      {
        _M_deallocate(__new_start, __len);
        throw;
      }
    _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
  }
       else
  {
    pointer __destroy_from = pointer();
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
        __destroy_from = __new_start + __size;
        std::__uninitialized_move_if_noexcept_a(
         this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
      }
    catch(...)
      {
        if (__destroy_from)
   std::_Destroy(__destroy_from, __destroy_from + __n,
          _M_get_Tp_allocator());
        _M_deallocate(__new_start, __len);
        throw;
      }
    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
    _M_get_Tp_allocator());
  }
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  ;
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   if (size_type __n = size())
     _M_reallocate(__n);
   else
     {
       this->_M_deallocate();
       this->_M_impl._M_reset();
     }
   return true;
 }
      catch(...)
 { return false; }
    }




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 73 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/vector" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Tp>
      using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
  }








}
# 63 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 2 3
# 74 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  template<int _Num> struct _Placeholder { };
# 92 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
  template<typename _Callable, typename... _Args>
    inline invoke_result_t<_Callable, _Args...>
    invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Callable, _Args...>)
    {
      return std::__invoke(std::forward<_Callable>(__fn),
      std::forward<_Args>(__args)...);
    }


  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>

 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>

 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _MemberPointer>
    struct _Mem_fn;

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 176 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
  template<typename _Tp, typename _Class>
   
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 192 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 203 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };


  template <typename _Tp> inline constexpr bool is_bind_expression_v
    = is_bind_expression<_Tp>::value;
  template <typename _Tp> inline constexpr int is_placeholder_v
    = is_placeholder<_Tp>::value;






  namespace placeholders
  {




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
  }






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
# 289 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>

 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>

 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>

 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::get<_Indexes>(std::move(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>

 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return
     ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>

 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    class _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>

 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>

 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }

      template<typename _BoundArg, typename _CallArgs>
 using _Mu_type = decltype(
     _Mu<typename remove_cv<_BoundArg>::type>()(
       std::declval<_BoundArg&>(), std::declval<_CallArgs&>()) );

      template<typename _Fn, typename _CallArgs, typename... _BArgs>
 using _Res_type_impl
   = typename result_of< _Fn&(_Mu_type<_BArgs, _CallArgs>&&...) >::type;

      template<typename _CallArgs>
 using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

      template<typename _CallArgs>
 using __dependent = typename
   enable_if<bool(tuple_size<_CallArgs>::value+1), _Functor>::type;

      template<typename _CallArgs, template<class> class __cv_quals>
 using _Res_type_cv = _Res_type_impl<
   typename __cv_quals<__dependent<_CallArgs>>::type,
   _CallArgs,
   typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
 explicit
 _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit
 _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;
      _Bind(_Bind&&) = default;


      template<typename... _Args,
        typename _Result = _Res_type<tuple<_Args...>>>

 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>

 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
# 527 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>
 [[deprecated("std::bind does not support volatile in C++17")]]
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_cv>>
 [[deprecated("std::bind does not support volatile in C++17")]]
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    class _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res, typename... _Args, std::size_t... _Indexes>

 _Res
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>

 _Res
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>

 _Res
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>

 _Res
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit
 _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit
 _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;
      _Bind_result(_Bind_result&&) = default;


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 [[deprecated("std::bind does not support volatile in C++17")]]
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 [[deprecated("std::bind does not support volatile in C++17")]]
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };






  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }
# 922 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
  template<typename _Fn>
    class _Not_fn
    {
      template<typename _Fn2, typename... _Args>
 using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

      template<typename _Tp>
 static decltype(!std::declval<_Tp>())
 _S_not() noexcept(noexcept(!std::declval<_Tp>()));

    public:
      template<typename _Fn2>
 constexpr
 _Not_fn(_Fn2&& __fn, int)
 : _M_fn(std::forward<_Fn2>(__fn)) { }

      _Not_fn(const _Not_fn& __fn) = default;
      _Not_fn(_Not_fn&& __fn) = default;
      ~_Not_fn() = default;
# 956 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/functional" 3
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &, _Args...>>()) operator()(_Args&&... __args) & noexcept(__is_nothrow_invocable<_Fn &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) { return !std::__invoke(std::forward< _Fn & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>()) operator()(_Args&&... __args) const & noexcept(__is_nothrow_invocable<_Fn const &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) { return !std::__invoke(std::forward< _Fn const & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>()) operator()(_Args&&... __args) && noexcept(__is_nothrow_invocable<_Fn &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn && >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>()) operator()(_Args&&... __args) const && noexcept(__is_nothrow_invocable<_Fn const &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn const && >(_M_fn), std::forward<_Args>(__args)...); }


    private:
      _Fn _M_fn;
    };

  template<typename _Tp, typename _Pred>
    struct __is_byte_like : false_type { };

  template<typename _Tp>
    struct __is_byte_like<_Tp, equal_to<_Tp>>
    : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> { };

  template<typename _Tp>
    struct __is_byte_like<_Tp, equal_to<void>>
    : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> { };



  enum class byte : unsigned char;

  template<>
    struct __is_byte_like<byte, equal_to<byte>>
    : true_type { };

  template<>
    struct __is_byte_like<byte, equal_to<void>>
    : true_type { };



  template<typename _Fn>
   
    inline auto
    not_fn(_Fn&& __fn)
    noexcept(std::is_nothrow_constructible<std::decay_t<_Fn>, _Fn&&>::value)
    {
      return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn), 0};
    }




  template<typename _ForwardIterator1, typename _BinaryPredicate = equal_to<>>
    class default_searcher
    {
    public:
     
      default_searcher(_ForwardIterator1 __pat_first,
         _ForwardIterator1 __pat_last,
         _BinaryPredicate __pred = _BinaryPredicate())
      : _M_m(__pat_first, __pat_last, std::move(__pred))
      { }

      template<typename _ForwardIterator2>

 pair<_ForwardIterator2, _ForwardIterator2>
 operator()(_ForwardIterator2 __first, _ForwardIterator2 __last) const
 {
   _ForwardIterator2 __first_ret =
     std::search(__first, __last, std::get<0>(_M_m), std::get<1>(_M_m),
   std::get<2>(_M_m));
   auto __ret = std::make_pair(__first_ret, __first_ret);
   if (__ret.first != __last)
     std::advance(__ret.second, std::distance(std::get<0>(_M_m),
           std::get<1>(_M_m)));
   return __ret;
 }

    private:
      tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate> _M_m;
    };

  template<typename _Key, typename _Tp, typename _Hash, typename _Pred>
    struct __boyer_moore_map_base
    {
      template<typename _RAIter>
 __boyer_moore_map_base(_RAIter __pat, size_t __patlen,
          _Hash&& __hf, _Pred&& __pred)
 : _M_bad_char{ __patlen, std::move(__hf), std::move(__pred) }
 {
   if (__patlen > 0)
     for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
       _M_bad_char[__pat[__i]] = __patlen - 1 - __i;
 }

      using __diff_type = _Tp;

      __diff_type
      _M_lookup(_Key __key, __diff_type __not_found) const
      {
 auto __iter = _M_bad_char.find(__key);
 if (__iter == _M_bad_char.end())
   return __not_found;
 return __iter->second;
      }

      _Pred
      _M_pred() const { return _M_bad_char.key_eq(); }

      std::unordered_map<_Key, _Tp, _Hash, _Pred> _M_bad_char;
    };

  template<typename _Tp, size_t _Len, typename _Pred>
    struct __boyer_moore_array_base
    {
      template<typename _RAIter, typename _Unused>
 __boyer_moore_array_base(_RAIter __pat, size_t __patlen,
     _Unused&&, _Pred&& __pred)
 : _M_bad_char{ array<_Tp, _Len>{}, std::move(__pred) }
 {
   std::get<0>(_M_bad_char).fill(__patlen);
   if (__patlen > 0)
     for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
       {
  auto __ch = __pat[__i];
  using _UCh = make_unsigned_t<decltype(__ch)>;
  auto __uch = static_cast<_UCh>(__ch);
  std::get<0>(_M_bad_char)[__uch] = __patlen - 1 - __i;
       }
 }

      using __diff_type = _Tp;

      template<typename _Key>
 __diff_type
 _M_lookup(_Key __key, __diff_type __not_found) const
 {
   auto __ukey = static_cast<make_unsigned_t<_Key>>(__key);
   if (__ukey >= _Len)
     return __not_found;
   return std::get<0>(_M_bad_char)[__ukey];
 }

      const _Pred&
      _M_pred() const { return std::get<1>(_M_bad_char); }

      tuple<array<_Tp, _Len>, _Pred> _M_bad_char;
    };



  template<typename _RAIter, typename _Hash, typename _Pred,
           typename _Val = typename iterator_traits<_RAIter>::value_type,
    typename _Diff = typename iterator_traits<_RAIter>::difference_type>
    using __boyer_moore_base_t
      = conditional_t<__is_byte_like<_Val, _Pred>::value,
        __boyer_moore_array_base<_Diff, 256, _Pred>,
        __boyer_moore_map_base<_Val, _Diff, _Hash, _Pred>>;

  template<typename _RAIter, typename _Hash
      = hash<typename iterator_traits<_RAIter>::value_type>,
    typename _BinaryPredicate = equal_to<>>
    class boyer_moore_searcher
    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>
    {
      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
      using typename _Base::__diff_type;

    public:
      boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,
      _Hash __hf = _Hash(),
      _BinaryPredicate __pred = _BinaryPredicate());

      template<typename _RandomAccessIterator2>
        pair<_RandomAccessIterator2, _RandomAccessIterator2>
 operator()(_RandomAccessIterator2 __first,
     _RandomAccessIterator2 __last) const;

    private:
      bool
      _M_is_prefix(_RAIter __word, __diff_type __len,
     __diff_type __pos)
      {
 const auto& __pred = this->_M_pred();
 __diff_type __suffixlen = __len - __pos;
 for (__diff_type __i = 0; __i < __suffixlen; ++__i)
   if (!__pred(__word[__i], __word[__pos + __i]))
     return false;
 return true;
      }

      __diff_type
      _M_suffix_length(_RAIter __word, __diff_type __len,
         __diff_type __pos)
      {
 const auto& __pred = this->_M_pred();
 __diff_type __i = 0;
 while (__pred(__word[__pos - __i], __word[__len - 1 - __i])
        && __i < __pos)
   {
     ++__i;
   }
 return __i;
      }

      template<typename _Tp>
 __diff_type
 _M_bad_char_shift(_Tp __c) const
 { return this->_M_lookup(__c, _M_pat_end - _M_pat); }

      _RAIter _M_pat;
      _RAIter _M_pat_end;
      std::vector<__diff_type> _M_good_suffix;
    };

  template<typename _RAIter, typename _Hash
      = hash<typename iterator_traits<_RAIter>::value_type>,
    typename _BinaryPredicate = equal_to<>>
    class boyer_moore_horspool_searcher
    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>
    {
      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
      using typename _Base::__diff_type;

    public:
      boyer_moore_horspool_searcher(_RAIter __pat,
        _RAIter __pat_end,
        _Hash __hf = _Hash(),
        _BinaryPredicate __pred
        = _BinaryPredicate())
      : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
 _M_pat(__pat), _M_pat_end(__pat_end)
      { }

      template<typename _RandomAccessIterator2>
        pair<_RandomAccessIterator2, _RandomAccessIterator2>
 operator()(_RandomAccessIterator2 __first,
     _RandomAccessIterator2 __last) const
 {
   const auto& __pred = this->_M_pred();
   auto __patlen = _M_pat_end - _M_pat;
   if (__patlen == 0)
     return std::make_pair(__first, __first);
   auto __len = __last - __first;
   while (__len >= __patlen)
     {
       for (auto __scan = __patlen - 1;
     __pred(__first[__scan], _M_pat[__scan]); --__scan)
  if (__scan == 0)
    return std::make_pair(__first, __first + __patlen);
       auto __shift = _M_bad_char_shift(__first[__patlen - 1]);
       __len -= __shift;
       __first += __shift;
     }
   return std::make_pair(__last, __last);
 }

    private:
      template<typename _Tp>
 __diff_type
 _M_bad_char_shift(_Tp __c) const
 { return this->_M_lookup(__c, _M_pat_end - _M_pat); }

      _RAIter _M_pat;
      _RAIter _M_pat_end;
    };

  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>
    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::
    boyer_moore_searcher(_RAIter __pat, _RAIter __pat_end,
    _Hash __hf, _BinaryPredicate __pred)
    : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
      _M_pat(__pat), _M_pat_end(__pat_end), _M_good_suffix(__pat_end - __pat)
    {
      auto __patlen = __pat_end - __pat;
      if (__patlen == 0)
 return;
      __diff_type __last_prefix = __patlen - 1;
      for (__diff_type __p = __patlen - 1; __p >= 0; --__p)
 {
   if (_M_is_prefix(__pat, __patlen, __p + 1))
     __last_prefix = __p + 1;
   _M_good_suffix[__p] = __last_prefix + (__patlen - 1 - __p);
 }
      for (__diff_type __p = 0; __p < __patlen - 1; ++__p)
 {
   auto __slen = _M_suffix_length(__pat, __patlen, __p);
   auto __pos = __patlen - 1 - __slen;
   if (!__pred(__pat[__p - __slen], __pat[__pos]))
     _M_good_suffix[__pos] = __patlen - 1 - __p + __slen;
 }
    }

  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>
  template<typename _RandomAccessIterator2>
    pair<_RandomAccessIterator2, _RandomAccessIterator2>
    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::
    operator()(_RandomAccessIterator2 __first,
        _RandomAccessIterator2 __last) const
    {
      auto __patlen = _M_pat_end - _M_pat;
      if (__patlen == 0)
 return std::make_pair(__first, __first);
      const auto& __pred = this->_M_pred();
      __diff_type __i = __patlen - 1;
      auto __stringlen = __last - __first;
      while (__i < __stringlen)
 {
   __diff_type __j = __patlen - 1;
   while (__j >= 0 && __pred(__first[__i], _M_pat[__j]))
     {
       --__i;
       --__j;
     }
   if (__j < 0)
     {
       const auto __match = __first + __i + 1;
       return std::make_pair(__match, __match + __patlen);
     }
   __i += std::max(_M_bad_char_shift(__first[__i]),
     _M_good_suffix[__j]);
 }
      return std::make_pair(__last, __last);
    }






}
# 14 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/pstl/glue_algorithm_defs.h" 2 3



namespace std
{



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
any_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
all_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
none_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Function __f);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
for_each_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, _Function __f);



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
find_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
find_if_not(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 typename iterator_traits<_ForwardIterator>::difference_type>
count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 typename iterator_traits<_ForwardIterator>::difference_type>
count_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp& __value, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
copy_n(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Size __n, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 result,
        _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
            _ForwardIterator2 __first2);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
          _UnaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator __result, _BinaryOperation __op);



template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,
           const _Tp& __new_value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value,
        const _Tp& __new_value);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
replace_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
                _ForwardIterator2 __result, _UnaryPredicate __pred, const _Tp& __new_value);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
replace_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
             const _Tp& __old_value, const _Tp& __new_value);



template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, const _Tp& __value);


template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
generate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Generator __g);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
generate_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size count, _Generator __g);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
remove_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
               _ForwardIterator2 __result, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
remove_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
            const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
remove_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
remove(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
            _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result);



template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,
             _ForwardIterator __d_first);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
rotate_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __middle, _ForwardIterator1 __last,
            _ForwardIterator2 __result);



template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _BidirectionalIterator>
stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,
                 _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardIterator1, class _ForwardIterator2,
          class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
partition_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,
               _ForwardIterator1 __out_true, _ForwardIterator2 __out_false, _UnaryPredicate __pred);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2);


template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
move(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __d_first);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,
                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,
                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last);


template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last);


template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator result,
                         _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);


template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                        _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                        _ForwardIterator2 __first2, _ForwardIterator2 __last2);

}
# 75 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/algorithm" 2 3
# 33 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2

# 1 "/usr/include/sys/time.h" 1 3 4
# 28 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 29 "/usr/include/sys/time.h" 2 3 4
# 38 "/usr/include/sys/time.h" 3 4
extern "C" {
# 56 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 72 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 190 "/usr/include/sys/time.h" 3 4
}
# 35 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h" 2
# 156 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"

# 156 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"
namespace owl {
  namespace common {


    using ::min;
    using ::max;


    using std::abs;





    using ::saturate;
# 181 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"
    inline __attribute__((host)) __attribute__((device)) float rcp(float f) { return 1.f/f; }
    inline __attribute__((host)) __attribute__((device)) double rcp(double d) { return 1./d; }

    inline __attribute__((host)) __attribute__((device)) int32_t divRoundUp(int32_t a, int32_t b) { return (a+b-1)/b; }
    inline __attribute__((host)) __attribute__((device)) uint32_t divRoundUp(uint32_t a, uint32_t b) { return (a+b-1)/b; }
    inline __attribute__((host)) __attribute__((device)) int64_t divRoundUp(int64_t a, int64_t b) { return (a+b-1)/b; }
    inline __attribute__((host)) __attribute__((device)) uint64_t divRoundUp(uint64_t a, uint64_t b) { return (a+b-1)/b; }







    using ::sin;
    using ::cos;
# 205 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"
    namespace polymorphic {

      inline __attribute__((host)) __attribute__((device)) float sqrt(const float f) { return ::sqrtf(f); }
      inline __attribute__((host)) __attribute__((device)) double sqrt(const double d) { return ::sqrt(d); }





      inline __attribute__((host)) __attribute__((device)) float rsqrt(const float f) { return 1.f/owl::common::polymorphic::sqrt(f); }
      inline __attribute__((host)) __attribute__((device)) double rsqrt(const double d) { return 1./owl::common::polymorphic::sqrt(d); }
    }
# 226 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"
    inline std::string prettyDouble(const double val) {
      const double absVal = abs(val);
      char result[1000];

      if (absVal >= 1e+18f) snprintf(result,1000,"%.1f%c",float(val/1e18f),'E');
      else if (absVal >= 1e+15f) snprintf(result,1000,"%.1f%c",float(val/1e15f),'P');
      else if (absVal >= 1e+12f) snprintf(result,1000,"%.1f%c",float(val/1e12f),'T');
      else if (absVal >= 1e+09f) snprintf(result,1000,"%.1f%c",float(val/1e09f),'G');
      else if (absVal >= 1e+06f) snprintf(result,1000,"%.1f%c",float(val/1e06f),'M');
      else if (absVal >= 1e+03f) snprintf(result,1000,"%.1f%c",float(val/1e03f),'k');
      else if (absVal <= 1e-12f) snprintf(result,1000,"%.1f%c",float(val*1e15f),'f');
      else if (absVal <= 1e-09f) snprintf(result,1000,"%.1f%c",float(val*1e12f),'p');
      else if (absVal <= 1e-06f) snprintf(result,1000,"%.1f%c",float(val*1e09f),'n');
      else if (absVal <= 1e-03f) snprintf(result,1000,"%.1f%c",float(val*1e06f),'u');
      else if (absVal <= 1e-00f) snprintf(result,1000,"%.1f%c",float(val*1e03f),'m');
      else snprintf(result,1000,"%f",(float)val);

      return result;
    }






    inline std::string prettyNumber(const size_t s)
    {
      char buf[1000];
      if (s >= (1000LL*1000LL*1000LL*1000LL)) {
        snprintf(buf, 1000,"%.2fT",s/(1000.f*1000.f*1000.f*1000.f));
      } else if (s >= (1000LL*1000LL*1000LL)) {
        snprintf(buf, 1000, "%.2fG",s/(1000.f*1000.f*1000.f));
      } else if (s >= (1000LL*1000LL)) {
        snprintf(buf, 1000, "%.2fM",s/(1000.f*1000.f));
      } else if (s >= (1000LL)) {
        snprintf(buf, 1000, "%.2fK",s/(1000.f));
      } else {
        snprintf(buf,1000,"%zi",s);
      }
      return buf;
    }




    inline std::string prettyBytes(const size_t s)
    {
      char buf[1000];
      if (s >= (1024LL*1024LL*1024LL*1024LL)) {
        snprintf(buf, 1000,"%.2fT",s/(1024.f*1024.f*1024.f*1024.f));
      } else if (s >= (1024LL*1024LL*1024LL)) {
        snprintf(buf, 1000, "%.2fG",s/(1024.f*1024.f*1024.f));
      } else if (s >= (1024LL*1024LL)) {
        snprintf(buf, 1000, "%.2fM",s/(1024.f*1024.f));
      } else if (s >= (1024LL)) {
        snprintf(buf, 1000, "%.2fK",s/(1024.f));
      } else {
        snprintf(buf,1000,"%zi",s);
      }
      return buf;
    }

    inline double getCurrentTime()
    {
# 303 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/owl-common.h"
      struct timeval tp; gettimeofday(&tp,nullptr);
      return double(tp.tv_sec) + double(tp.tv_usec)/1E6;

    }

    inline bool hasSuffix(const std::string &s, const std::string &suffix)
    {
      return s.substr(s.size()-suffix.size()) == suffix;
    }

  }
}
# 20 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
       


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 1 3 4
# 21 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/CUDA/11.7.0/include/math_constants.h" 1
# 23 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 2






namespace owl {
  namespace common {

    static struct ZeroTy
    {
      __attribute__((host)) __attribute__((device)) operator double ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator float ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator long long( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator unsigned long long( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator long ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator unsigned long ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator int ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator unsigned int ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator short ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator unsigned short ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator char ( ) const { return 0; }
      __attribute__((host)) __attribute__((device)) operator unsigned char ( ) const { return 0; }
    } zero __attribute__((unused));

    static struct OneTy
    {
      __attribute__((host)) __attribute__((device)) operator double ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator float ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator long long( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator unsigned long long( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator long ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator unsigned long ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator int ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator unsigned int ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator short ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator unsigned short ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator char ( ) const { return 1; }
      __attribute__((host)) __attribute__((device)) operator unsigned char ( ) const { return 1; }
    } one __attribute__((unused));

    static struct NegInfTy
    {

      __attribute__((device)) operator double ( ) const { return -__longlong_as_double(0x7ff0000000000000ULL); }
      __attribute__((device)) operator float ( ) const { return -__int_as_float(0x7f800000U); }
# 83 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
    } neg_inf __attribute__((unused));

    inline __attribute__((host)) __attribute__((device)) float infty() {

      return __int_as_float(0x7f800000U);



    }

    static struct PosInfTy
    {

      __attribute__((device)) operator double ( ) const { return __longlong_as_double(0x7ff0000000000000ULL); }
      __attribute__((device)) operator float ( ) const { return __int_as_float(0x7f800000U); }
# 112 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
    } inf __attribute__((unused)), pos_inf __attribute__((unused));

    static struct NaNTy
    {

      __attribute__((device)) operator double( ) const { return __longlong_as_double(0xfff8000000000000ULL); }
      __attribute__((device)) operator float ( ) const { return __int_as_float(0x7fffffffU); }




    } nan __attribute__((unused));

    static struct UlpTy
    {






    } ulp __attribute__((unused));



    template<bool is_integer>
    struct limits_traits;

    template<> struct limits_traits<true> {
      template<typename T> static inline __attribute__((host)) __attribute__((device)) T value_limits_lower(T) { return std::numeric_limits<T>::min(); }
      template<typename T> static inline __attribute__((host)) __attribute__((device)) T value_limits_upper(T) { return std::numeric_limits<T>::max(); }
    };
    template<> struct limits_traits<false> {
      template<typename T> static inline __attribute__((host)) __attribute__((device)) T value_limits_lower(T) { return (T)NegInfTy(); }
      template<typename T> static inline __attribute__((host)) __attribute__((device)) T value_limits_upper(T) { return (T)PosInfTy(); }
    };


    template<typename T> inline __attribute__((host)) __attribute__((device)) T empty_bounds_lower()
    {
      return limits_traits<std::numeric_limits<T>::is_integer>::value_limits_upper(T());
    }


    template<typename T> inline __attribute__((host)) __attribute__((device)) T empty_bounds_upper()
    {
      return limits_traits<std::numeric_limits<T>::is_integer>::value_limits_lower(T());
    }


    template<typename T> inline __attribute__((host)) __attribute__((device)) T empty_range_lower()
    {
      return limits_traits<std::numeric_limits<T>::is_integer>::value_limits_upper(T());
    }


    template<typename T> inline __attribute__((host)) __attribute__((device)) T empty_range_upper()
    {
      return limits_traits<std::numeric_limits<T>::is_integer>::value_limits_lower(T());
    }


    template<typename T> inline __attribute__((host)) __attribute__((device)) T open_range_lower()
    {
      return limits_traits<std::numeric_limits<T>::is_integer>::value_limits_lower(T());
    }


    template<typename T> inline __attribute__((host)) __attribute__((device)) T open_range_upper()
    {
      return limits_traits<std::numeric_limits<T>::is_integer>::value_limits_upper(T());
    }

    template<> inline __attribute__((host)) __attribute__((device)) uint32_t empty_bounds_lower<uint32_t>()
    { return uint32_t(
# 186 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                     (0x7fffffff * 2U + 1U)
# 186 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                             ); }
    template<> inline __attribute__((host)) __attribute__((device)) uint32_t empty_bounds_upper<uint32_t>()
    { return uint32_t(0); }
    template<> inline __attribute__((host)) __attribute__((device)) uint32_t open_range_lower<uint32_t>()
    { return uint32_t(0); }
    template<> inline __attribute__((host)) __attribute__((device)) uint32_t open_range_upper<uint32_t>()
    { return uint32_t(
# 192 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                     (0x7fffffff * 2U + 1U)
# 192 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                             ); }

    template<> inline __attribute__((host)) __attribute__((device)) int32_t empty_bounds_lower<int32_t>()
    { return int32_t(0x7fffffff); }
    template<> inline __attribute__((host)) __attribute__((device)) int32_t empty_bounds_upper<int32_t>()
    { return int32_t(
# 197 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                    (-0x7fffffff - 1)
# 197 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                           ); }
    template<> inline __attribute__((host)) __attribute__((device)) int32_t open_range_lower<int32_t>()
    { return int32_t(
# 199 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                    (-0x7fffffff - 1)
# 199 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                           ); }
    template<> inline __attribute__((host)) __attribute__((device)) int32_t open_range_upper<int32_t>()
    { return int32_t(0x7fffffff); }


    template<> inline __attribute__((host)) __attribute__((device)) uint16_t empty_bounds_lower<uint16_t>()
    { return uint16_t(
# 205 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                     (0x7fff * 2 + 1)
# 205 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                              ); }
    template<> inline __attribute__((host)) __attribute__((device)) uint16_t empty_bounds_upper<uint16_t>()
    { return uint16_t(0); }
    template<> inline __attribute__((host)) __attribute__((device)) uint16_t open_range_lower<uint16_t>()
    { return uint16_t(0); }
    template<> inline __attribute__((host)) __attribute__((device)) uint16_t open_range_upper<uint16_t>()
    { return uint16_t(
# 211 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                     (0x7fff * 2 + 1)
# 211 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                              ); }

    template<> inline __attribute__((host)) __attribute__((device)) int16_t empty_bounds_lower<int16_t>()
    { return int16_t(0x7fff); }
    template<> inline __attribute__((host)) __attribute__((device)) int16_t empty_bounds_upper<int16_t>()
    { return int16_t(
# 216 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                    (-0x7fff - 1)
# 216 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                            ); }
    template<> inline __attribute__((host)) __attribute__((device)) int16_t open_range_lower<int16_t>()
    { return int16_t(
# 218 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                    (-0x7fff - 1)
# 218 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                            ); }
    template<> inline __attribute__((host)) __attribute__((device)) int16_t open_range_upper<int16_t>()
    { return int16_t(0x7fff); }

    template<> inline __attribute__((host)) __attribute__((device)) uint8_t empty_bounds_lower<uint8_t>()
    { return uint8_t(0x7f); }
    template<> inline __attribute__((host)) __attribute__((device)) uint8_t empty_bounds_upper<uint8_t>()
    { return uint8_t(
# 225 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                    (-0x7f - 1)
# 225 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                            ); }
    template<> inline __attribute__((host)) __attribute__((device)) uint8_t open_range_lower<uint8_t>()
    { return uint8_t(
# 227 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                    (-0x7f - 1)
# 227 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                            ); }
    template<> inline __attribute__((host)) __attribute__((device)) uint8_t open_range_upper<uint8_t>()
    { return uint8_t(0x7f); }

    template<> inline __attribute__((host)) __attribute__((device)) int8_t empty_bounds_lower<int8_t>()
    { return int8_t(
# 232 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                   (-0x7f - 1)
# 232 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                            ); }
    template<> inline __attribute__((host)) __attribute__((device)) int8_t empty_bounds_upper<int8_t>()
    { return int8_t(0x7f); }
    template<> inline __attribute__((host)) __attribute__((device)) int8_t open_range_lower<int8_t>()
    { return int8_t(0x7f); }
    template<> inline __attribute__((host)) __attribute__((device)) int8_t open_range_upper<int8_t>()
    { return int8_t(
# 238 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h" 3 4
                   (-0x7f - 1)
# 238 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/constants.h"
                            ); }

  }
}
# 21 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 1 3
# 23 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 2


namespace owl {
  namespace common {

    template<typename T> struct long_type_of { typedef T type; };
    template<> struct long_type_of<int32_t> { typedef int64_t type; };
    template<> struct long_type_of<uint32_t> { typedef uint64_t type; };

    template<typename T, int N>
    struct vec_t { T t[N]; };


    template<typename ScalarTypeA, typename ScalarTypeB> struct BinaryOpResultType;


    template<typename ScalarType>
    struct BinaryOpResultType<ScalarType,ScalarType> { typedef ScalarType type; };

    template<> struct BinaryOpResultType<int,float> { typedef float type; };
    template<> struct BinaryOpResultType<float,int> { typedef float type; };
    template<> struct BinaryOpResultType<unsigned int,float> { typedef float type; };
    template<> struct BinaryOpResultType<float,unsigned int> { typedef float type; };

    template<> struct BinaryOpResultType<int,double> { typedef double type; };
    template<> struct BinaryOpResultType<double,int> { typedef double type; };
    template<> struct BinaryOpResultType<unsigned int,double> { typedef double type; };
    template<> struct BinaryOpResultType<double,unsigned int> { typedef double type; };





    template<typename T>
    struct vec_t<T,1> {
      enum { dims = 1 };
      typedef T scalar_t;

      inline __attribute__((host)) __attribute__((device)) vec_t() {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const T &v) : v(v) {}


      inline __attribute__((host)) __attribute__((device)) vec_t<T,1> &operator=(const vec_t<T,1> &other) {
        this->v = other.v;
        return *this;
      }


      template<typename OT>
        inline __attribute__((host)) __attribute__((device)) explicit vec_t(const vec_t<OT,1> &o) : v(o.v) {}

      inline __attribute__((host)) __attribute__((device)) T &operator[](size_t dim) {
        
# 75 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 3 4
       ((
# 75 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
       dim == 0
# 75 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 75 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
       "dim == 0"
# 75 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h", 75, __PRETTY_FUNCTION__))
# 75 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
                       ;
        return x;

      }
      inline __attribute__((host)) __attribute__((device)) const T &operator[](size_t dim) const
      {
        
# 81 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 3 4
       ((
# 81 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
       dim == 0
# 81 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 81 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
       "dim == 0"
# 81 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h", 81, __PRETTY_FUNCTION__))
# 81 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
                       ;
        return x;

      }

      union {
        T v;
        T x;
      };
    };




    template<typename T>
    struct vec_t<T,2> {
      enum { dims = 2 };
      typedef T scalar_t;

      inline __attribute__((host)) __attribute__((device)) vec_t() {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const T &t) : x(t), y(t) {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const T &x, const T &y) : x(x), y(y) {}

      inline __attribute__((host)) __attribute__((device)) vec_t(const float2 v) : x(v.x), y(v.y) {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const int2 v) : x(v.x), y(v.y) {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const uint2 v) : x(v.x), y(v.y) {}

      inline __attribute__((host)) __attribute__((device)) operator float2() const { return make_float2(x,y); }
      inline __attribute__((host)) __attribute__((device)) operator int2() const { return make_int2(x,y); }
      inline __attribute__((host)) __attribute__((device)) operator uint2() const { return make_uint2(x,y); }



      inline __attribute__((host)) __attribute__((device)) operator dim3() const { dim3 d; d.x = x; d.y = y; d.z = 1; return d; }
      inline explicit __attribute__((host)) __attribute__((device)) vec_t(const dim3 v) : x(v.x), y(v.y) {}



      inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator=(const vec_t<T,2> &other) {
        this->x = other.x;
        this->y = other.y;
        return *this;
      }


      template<typename OT>
        inline __attribute__((host)) __attribute__((device)) explicit vec_t(const vec_t<OT,2> &o) : x((T)o.x), y((T)o.y) {}

      inline __attribute__((host)) __attribute__((device)) T &operator[](size_t dim) { return (&x)[dim]; }
      inline __attribute__((host)) __attribute__((device)) const T &operator[](size_t dim) const { return (&x)[dim]; }

      union {
        struct { T x, y; };
        struct { T s, t; };
        struct { T u, v; };
      };
    };




    template<typename T>
    struct vec_t<T,3> {
      enum { dims = 3 };
      typedef T scalar_t;

      inline
        vec_t(const vec_t &) = default;
      inline __attribute__((host)) __attribute__((device)) vec_t() {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const T &t) : x(t), y(t), z(t) {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const T &_x, const T &_y, const T &_z) : x(_x), y(_y), z(_z) {}

      inline __attribute__((host)) __attribute__((device)) vec_t(const int3 &v) : x(v.x), y(v.y), z(v.z) {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const uint3 &v) : x(v.x), y(v.y), z(v.z) {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const float3 &v) : x(v.x), y(v.y), z(v.z) {}



      inline __attribute__((host)) __attribute__((device)) vec_t(const float4 v) : x(v.x), y(v.y), z(v.z) {}



      inline __attribute__((host)) __attribute__((device)) vec_t(const int4 v) : x(v.x), y(v.y), z(v.z) {}



      inline __attribute__((host)) __attribute__((device)) vec_t(const uint4 v) : x(v.x), y(v.y), z(v.z) {}
      inline __attribute__((host)) __attribute__((device)) operator float3() const { return make_float3(x,y,z); }
      inline __attribute__((host)) __attribute__((device)) operator int3() const { return make_int3(x,y,z); }
      inline __attribute__((host)) __attribute__((device)) operator uint3() const { return make_uint3(x,y,z); }

      inline __attribute__((host)) __attribute__((device)) explicit vec_t(const vec_t<T,4> &v);

      template<typename OT>
        inline __attribute__((host)) __attribute__((device)) explicit vec_t(const vec_t<OT,3> &o) : x((T)o.x), y((T)o.y), z((T)o.z) {}


      inline __attribute__((host)) __attribute__((device)) vec_t<T,3> yzx() const { return vec_t<T,3>(y,z,x); }


      inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator=(const vec_t<T,3> &other) {
        this->x = other.x;
        this->y = other.y;
        this->z = other.z;
        return *this;
      }

      inline __attribute__((host)) __attribute__((device)) T &operator[](size_t dim) { return (&x)[dim]; }
      inline __attribute__((host)) __attribute__((device)) const T &operator[](size_t dim) const { return (&x)[dim]; }

      template<typename OT, typename Lambda>
        static inline __attribute__((host)) __attribute__((device)) vec_t<T,3> make_from(const vec_t<OT,3> &v, const Lambda &lambda)
      { return vec_t<T,3>(lambda(v.x),lambda(v.y),lambda(v.z)); }

      union {
        struct { T x, y, z; };
        struct { T r, s, t; };
        struct { T u, v, w; };
      };
    };




    template<typename T>
    struct __attribute__((aligned(16))) vec3a_t : public vec_t<T,3> {
      inline vec3a_t() {}
      inline vec3a_t(const T &t) : vec_t<T,3>(t) {}
      inline vec3a_t(const T &x, const T &y, const T &z) : vec_t<T,3>(x,y,z) {}

      inline __attribute__((host)) __attribute__((device)) vec3a_t(const int3 &v) : vec_t<T,3>(v) {};
      inline __attribute__((host)) __attribute__((device)) vec3a_t(const uint3 &v) : vec_t<T,3>(v) {};
      inline __attribute__((host)) __attribute__((device)) vec3a_t(const float3 &v) : vec_t<T,3>(v) {};
      inline __attribute__((host)) __attribute__((device)) vec3a_t(const int4 v) : vec_t<T,3>(v) {};
      inline __attribute__((host)) __attribute__((device)) vec3a_t(const uint4 v) : vec_t<T,3>(v) {};
      inline __attribute__((host)) __attribute__((device)) vec3a_t(const float4 v) : vec_t<T,3>(v) {};


      template<typename OT>
        inline vec3a_t(const vec_t<OT,3> &v) : vec_t<T,3>(v.x,v.y,v.z) {}

      T a;

    };




    template<typename T>
    struct vec_t<T,4> {
      enum { dims = 4 };
      typedef T scalar_t;

      inline __attribute__((host)) __attribute__((device)) vec_t() {}

      inline __attribute__((host)) __attribute__((device)) vec_t(const T &t)
        : x(t), y(t), z(t), w(t)
      {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const vec_t<T,3> &xyz, const T &_w)
        : x(xyz.x), y(xyz.y), z(xyz.z), w(_w)
      {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const T &_x, const T &_y, const T &_z, const T &_w)
        : x(_x), y(_y), z(_z), w(_w)
      {}


      inline __attribute__((host)) __attribute__((device)) vec_t(const float4 &v)
        : x(v.x), y(v.y), z(v.z), w(v.w)
        {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const int4 &v)
        : x(v.x), y(v.y), z(v.z), w(v.w)
        {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const uint4 &v)
        : x(v.x), y(v.y), z(v.z), w(v.w)
        {}
      inline __attribute__((host)) __attribute__((device)) operator float4() const { return make_float4(x,y,z,w); }
      inline __attribute__((host)) __attribute__((device)) operator uint4() const { return make_uint4(x,y,z,w); }
      inline __attribute__((host)) __attribute__((device)) operator int4() const { return make_int4(x,y,z,w); }


      template<typename OT>
        inline __attribute__((host)) __attribute__((device)) explicit vec_t(const vec_t<OT,4> &o)
        : x((T)o.x), y((T)o.y), z((T)o.z), w((T)o.w)
        {}
      inline __attribute__((host)) __attribute__((device)) vec_t(const vec_t<T,4> &o) : x(o.x), y(o.y), z(o.z), w(o.w) {}


      inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator=(const vec_t<T,4> &other) {
        this->x = other.x;
        this->y = other.y;
        this->z = other.z;
        this->w = other.w;
        return *this;
      }

      inline __attribute__((host)) __attribute__((device)) T &operator[](size_t dim) { return (&x)[dim]; }
      inline __attribute__((host)) __attribute__((device)) const T &operator[](size_t dim) const { return (&x)[dim]; }

      template<typename OT, typename Lambda>
        static inline __attribute__((host)) __attribute__((device)) vec_t<T,4> make_from(const vec_t<OT,4> &v,
                                                    const Lambda &lambda)
      { return vec_t<T,4>(lambda(v.x),lambda(v.y),lambda(v.z),lambda(v.w)); }

      T x, y, z, w;
    };

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,3>::vec_t(const vec_t<T,4> &v)
      : x(v.x), y(v.y), z(v.z)
    {}





    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type area(const vec_t<T,2> &v)
    { return (typename long_type_of<T>::type)(v.x)*(typename long_type_of<T>::type)(v.y); }


    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type volume(const vec_t<T,3> &v)
    { return
        (typename long_type_of<T>::type)(v.x)*
        (typename long_type_of<T>::type)(v.y)*
        (typename long_type_of<T>::type)(v.z);
    }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type volume(const vec_t<T,4> &v)
    { return
        (typename long_type_of<T>::type)(v.x)*
        (typename long_type_of<T>::type)(v.y)*
        (typename long_type_of<T>::type)(v.z)*
        (typename long_type_of<T>::type)(v.w);
    }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type area(const vec_t<T,3> &v)
    { return
        T(2)*((typename long_type_of<T>::type)(v.x)*v.y+
              (typename long_type_of<T>::type)(v.y)*v.z+
              (typename long_type_of<T>::type)(v.z)*v.x);
    }




    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,3> cross(const vec_t<T,3> &a, const vec_t<T,3> &b)
    {
      return vec_t<T,3>(a.y*b.z-b.y*a.z,
                        a.z*b.x-b.z*a.x,
                        a.x*b.y-b.x*a.y);
    }


    template<typename T>
    inline __attribute__((host)) __attribute__((device)) T dot(const vec_t<T,3> &a, const vec_t<T,3> &b)
    {
      return a.x*b.x + a.y*b.y + a.z*b.z;
    }


    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,3> normalize(const vec_t<T,3> &v)
    {
      return v * owl::common::polymorphic::rsqrt(dot(v,v));
    }


    template<typename T>
    inline __attribute__((host)) __attribute__((device)) T length(const vec_t<T,3> &v)
    {
      return owl::common::polymorphic::sqrt(dot(v,v));
    }

    template<typename T>
    inline __attribute__((host)) std::ostream &operator<<(std::ostream &o, const vec_t<T,1> &v)
    {
      o << "(" << v.x << ")";
      return o;
    }

    template<typename T>
    inline __attribute__((host)) std::ostream &operator<<(std::ostream &o, const vec_t<T,2> &v)
    {
      o << "(" << v.x << "," << v.y << ")";
      return o;
    }

    template<typename T>
    inline __attribute__((host)) std::ostream &operator<<(std::ostream &o, const vec_t<T,3> &v)
    {
      o << "(" << v.x << "," << v.y << "," << v.z << ")";
      return o;
    }

    template<typename T>
    inline __attribute__((host)) std::ostream &operator<<(std::ostream &o, const vec_t<T,4> &v)
    {
      o << "(" << v.x << "," << v.y << "," << v.z << "," << v.w << ")";
      return o;
    }
# 396 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h"
    using vec2b = vec_t<bool,2>; using vec3b = vec_t<bool,3>; using vec4b = vec_t<bool,4>; using vec3ba = vec3a_t<bool>;;
    using vec2c = vec_t<int8_t,2>; using vec3c = vec_t<int8_t,3>; using vec4c = vec_t<int8_t,4>; using vec3ca = vec3a_t<int8_t>;;
    using vec2s = vec_t<int16_t,2>; using vec3s = vec_t<int16_t,3>; using vec4s = vec_t<int16_t,4>; using vec3sa = vec3a_t<int16_t>;;
    using vec2i = vec_t<int32_t,2>; using vec3i = vec_t<int32_t,3>; using vec4i = vec_t<int32_t,4>; using vec3ia = vec3a_t<int32_t>;;
    using vec2l = vec_t<int64_t,2>; using vec3l = vec_t<int64_t,3>; using vec4l = vec_t<int64_t,4>; using vec3la = vec3a_t<int64_t>;;
    using vec2uc = vec_t<uint8_t,2>; using vec3uc = vec_t<uint8_t,3>; using vec4uc = vec_t<uint8_t,4>; using vec3uca = vec3a_t<uint8_t>;;
    using vec2us = vec_t<uint16_t,2>; using vec3us = vec_t<uint16_t,3>; using vec4us = vec_t<uint16_t,4>; using vec3usa = vec3a_t<uint16_t>;;
    using vec2ui = vec_t<uint32_t,2>; using vec3ui = vec_t<uint32_t,3>; using vec4ui = vec_t<uint32_t,4>; using vec3uia = vec3a_t<uint32_t>;;
    using vec2ul = vec_t<uint64_t,2>; using vec3ul = vec_t<uint64_t,3>; using vec4ul = vec_t<uint64_t,4>; using vec3ula = vec3a_t<uint64_t>;;
    using vec2f = vec_t<float,2>; using vec3f = vec_t<float,3>; using vec4f = vec_t<float,4>; using vec3fa = vec3a_t<float>;;
    using vec2d = vec_t<double,2>; using vec3d = vec_t<double,3>; using vec4d = vec_t<double,4>; using vec3da = vec3a_t<double>;;



  }

  using namespace owl::common;
}


# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/compare.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/compare.h"
       

namespace owl {
  namespace common {






    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator==(const vec_t<T,2> &a, const vec_t<T,2> &b)
    { return (a.x==b.x) & (a.y==b.y); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator==(const vec_t<T,3> &a, const vec_t<T,3> &b)
    { return (a.x==b.x) & (a.y==b.y) & (a.z==b.z); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator==(const vec_t<T,4> &a, const vec_t<T,4> &b)
    { return (a.x==b.x) & (a.y==b.y) & (a.z==b.z) & (a.w==b.w); }
# 56 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/compare.h"
    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) bool operator!=(const vec_t<T,N> &a, const vec_t<T,N> &b)
    { return !(a==b); }
# 69 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/compare.h"
    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto nt(const vec_t<T,2> &a)
      -> vec_t<decltype(!a.x),2>
    { return { !a.x, !a.y }; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto nt(const vec_t<T,3> &a)
      -> vec_t<decltype(!a.x),3>
    { return { !a.x, !a.y, !a.z }; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto nt(const vec_t<T,4> &a)
      -> vec_t<decltype(!a.x),4>
    { return { !a.x, !a.y, !a.z, !a.w }; }





    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto eq(const vec_t<T,2> &a, const vec_t<T,2> &b)
      -> vec_t<decltype(a.x==b.x),2>
    { return { a.x==b.x, a.y==b.y }; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto eq(const vec_t<T,3> &a, const vec_t<T,3> &b)
      -> vec_t<decltype(a.x==b.x),3>
    { return { a.x==b.x, a.y==b.y, a.z==b.z }; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto eq(const vec_t<T,4> &a, const vec_t<T,4> &b)
      -> vec_t<decltype(a.x==b.x),4>
    { return { a.x==b.x, a.y==b.y, a.z==b.z, a.w==b.w }; }





    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) auto neq(const vec_t<T,N> &a, const vec_t<T,N> &b)
      -> decltype(nt(eq(a,b)))
    { return nt(eq(a,b)); }





    template<typename T>
    inline __attribute__((host)) __attribute__((device)) auto lt(const vec_t<T,2> &a, const vec_t<T,2> &b)
      -> vec_t<decltype(a.x<b.x),2>
    { return { a.x<b.x, a.y<b.y }; }

      template<typename T>
      inline __attribute__((host)) __attribute__((device)) auto lt(const vec_t<T,3> &a, const vec_t<T,3> &b)
        -> vec_t<decltype(a.x<b.x),3>
      { return { a.x<b.x, a.y<b.y, a.z<b.z }; }

        template<typename T>
        inline __attribute__((host)) __attribute__((device)) auto lt(const vec_t<T,4> &a, const vec_t<T,4> &b)
          -> vec_t<decltype(a.x<b.x),4>
        { return { a.x<b.x, a.y<b.y, a.z<b.z, a.w<b.w }; }





          template<typename T, int N>
          inline __attribute__((host)) __attribute__((device)) auto le(const vec_t<T,N> &a, const vec_t<T,N> &b)
            -> decltype(nt(lt(b,a)))
          { return nt(lt(b,a)); }





    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) auto gt(const vec_t<T,N> &a, const vec_t<T,N> &b)
      -> decltype(lt(b,a))
    { return lt(b,a); }





    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) auto ge(const vec_t<T,N> &a, const vec_t<T,N> &b)
      -> decltype(nt(lt(a,b)))
    { return nt(lt(a,b)); }





    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) bool any(const vec_t<T,N> &a)
    { for (int i=0;i<N;++i) if (a[i]) return true; return false; }

    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) bool all(const vec_t<T,N> &a)
    { for (int i=0;i<N;++i) if (!a[i]) return false; return true; }
# 178 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/compare.h"
    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,2> select(const vec_t<bool,2> &mask,
                                      const vec_t<T,2> &a,
                                      const vec_t<T,2> &b)
    { return { mask.x?a.x:b.x, mask.y?a.y:b.y }; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,3> select(const vec_t<bool,3> &mask,
                                      const vec_t<T,3> &a,
                                      const vec_t<T,3> &b)
    { return { mask.x?a.x:b.x, mask.y?a.y:b.y, mask.z?a.z:b.z }; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,4> select(const vec_t<bool,4> &mask,
                                      const vec_t<T,4> &a,
                                      const vec_t<T,4> &b)
    { return { mask.x?a.x:b.x, mask.y?a.y:b.y, mask.z?a.z:b.z }; }

    template<typename T, int N>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,N> select(const vec_t<bool,N> &mask,
                                      const vec_t<T,N> &a,
                                      const vec_t<T,N> &b)
    {
      vec_t<T,N> res;
      for (int i=0; i<N; ++i)
        res[i] = mask[i]?a[i]:b[i];
      return res;
    }

  }
}
# 417 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h"
       



namespace owl {
  namespace common {





    template<typename T, int N> inline __attribute__((host)) __attribute__((device))
    bool any_less_than(const vec_t<T,N> &a, const vec_t<T,N> &b)
    { return common::any(lt(a,b)); }

    template<typename T, int N> inline __attribute__((host)) __attribute__((device))
    bool all_less_than(const vec_t<T,N> &a, const vec_t<T,N> &b)
    { return common::all(lt(a,b)); }

    template<typename T, int N> inline __attribute__((host)) __attribute__((device))
    bool any_greater_than(const vec_t<T,N> &a, const vec_t<T,N> &b)
    { return common::any(gt(a,b)); }



    template<typename T, int N> inline __attribute__((host)) __attribute__((device))
    bool any_greater_or_equal(const vec_t<T,N> &a, const vec_t<T,N> &b)
    { return common::any(ge(a,b)); }





    template<typename T>
    inline __attribute__((host)) __attribute__((device)) T clamp(const T &val, const T &lo, const T &hi)
    { return min(hi,max(lo,val)); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) T clamp(const T &val, const T &hi)
    { return clamp(val,(T)0,hi); }
# 68 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h"
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> rcp(const vec_t<T,2> &v) { return vec_t<T,2>(owl::common::rcp(v.x),owl::common::rcp(v.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> rcp(const vec_t<T,3> &v) { return vec_t<T,3>(owl::common::rcp(v.x),owl::common::rcp(v.y),owl::common::rcp(v.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> rcp(const vec_t<T,4> &v) { return vec_t<T,4>(owl::common::rcp(v.x),owl::common::rcp(v.y),owl::common::rcp(v.z),owl::common::rcp(v.w)); }
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> sin(const vec_t<T,2> &v) { return vec_t<T,2>(owl::common::sin(v.x),owl::common::sin(v.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> sin(const vec_t<T,3> &v) { return vec_t<T,3>(owl::common::sin(v.x),owl::common::sin(v.y),owl::common::sin(v.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> sin(const vec_t<T,4> &v) { return vec_t<T,4>(owl::common::sin(v.x),owl::common::sin(v.y),owl::common::sin(v.z),owl::common::sin(v.w)); }
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> cos(const vec_t<T,2> &v) { return vec_t<T,2>(owl::common::cos(v.x),owl::common::cos(v.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> cos(const vec_t<T,3> &v) { return vec_t<T,3>(owl::common::cos(v.x),owl::common::cos(v.y),owl::common::cos(v.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> cos(const vec_t<T,4> &v) { return vec_t<T,4>(owl::common::cos(v.x),owl::common::cos(v.y),owl::common::cos(v.z),owl::common::cos(v.w)); }
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> abs(const vec_t<T,2> &v) { return vec_t<T,2>(owl::common::abs(v.x),owl::common::abs(v.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> abs(const vec_t<T,3> &v) { return vec_t<T,3>(owl::common::abs(v.x),owl::common::abs(v.y),owl::common::abs(v.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> abs(const vec_t<T,4> &v) { return vec_t<T,4>(owl::common::abs(v.x),owl::common::abs(v.y),owl::common::abs(v.z),owl::common::abs(v.w)); }
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> saturate(const vec_t<T,2> &v) { return vec_t<T,2>(owl::common::saturate(v.x),owl::common::saturate(v.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> saturate(const vec_t<T,3> &v) { return vec_t<T,3>(owl::common::saturate(v.x),owl::common::saturate(v.y),owl::common::saturate(v.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> saturate(const vec_t<T,4> &v) { return vec_t<T,4>(owl::common::saturate(v.x),owl::common::saturate(v.y),owl::common::saturate(v.z),owl::common::saturate(v.w)); }
# 129 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h"
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,1> divRoundUp(const vec_t<T,1> &a, const vec_t<T,1> &b) { return vec_t<T,1>(divRoundUp(a.x,b.x)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> divRoundUp(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(divRoundUp(a.x,b.x), divRoundUp(a.y,b.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> divRoundUp(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(divRoundUp(a.x,b.x), divRoundUp(a.y,b.y), divRoundUp(a.z,b.z)); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> divRoundUp(const vec_t<T1,3> &a, const vec_t<T2,3> &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (divRoundUp(a.x,b.x), divRoundUp(a.y,b.y), divRoundUp(a.z,b.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> divRoundUp(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(divRoundUp(a.x,b.x), divRoundUp(a.y,b.y), divRoundUp(a.z,b.z), divRoundUp(a.w,b.w)); }
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,1> min(const vec_t<T,1> &a, const vec_t<T,1> &b) { return vec_t<T,1>(min(a.x,b.x)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> min(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(min(a.x,b.x), min(a.y,b.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> min(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> min(const vec_t<T1,3> &a, const vec_t<T2,3> &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> min(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z), min(a.w,b.w)); }
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,1> max(const vec_t<T,1> &a, const vec_t<T,1> &b) { return vec_t<T,1>(max(a.x,b.x)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> max(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(max(a.x,b.x), max(a.y,b.y)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> max(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z)); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> max(const vec_t<T1,3> &a, const vec_t<T2,3> &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (max(a.x,b.x), max(a.y,b.y), max(a.z,b.z)); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> max(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(max(a.x,b.x), max(a.y,b.y), max(a.z,b.z), max(a.w,b.w)); }
# 195 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h"
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator *(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(a.x * b.x, a.y * b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator *(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(a.x * b.x, a.y * b.y, a.z * b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator *(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(a.x * b.x,a.y * b.y,a.z * b.z,a.w * b.w); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator *(const vec_t<T,2> &a, const T &b) { return vec_t<T,2>(a.x * b, a.y * b); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> operator *(const vec_t<T1,3> &a, const T2 &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (a.x * b, a.y * b, a.z * b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator *(const vec_t<T,4> &a, const T &b) { return vec_t<T,4>(a.x * b, a.y * b, a.z * b, a.w * b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator *(const T &a, const vec_t<T,2> &b) { return vec_t<T,2>(a * b.x, a * b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator *(const T &a, const vec_t<T,3> &b) { return vec_t<T,3>(a * b.x, a * b.y, a * b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator *(const T &a, const vec_t<T,4> &b) { return vec_t<T,4>(a * b.x, a * b.y, a * b.z, a * b.w); };
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator /(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(a.x / b.x, a.y / b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator /(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(a.x / b.x, a.y / b.y, a.z / b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator /(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(a.x / b.x,a.y / b.y,a.z / b.z,a.w / b.w); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator /(const vec_t<T,2> &a, const T &b) { return vec_t<T,2>(a.x / b, a.y / b); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> operator /(const vec_t<T1,3> &a, const T2 &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (a.x / b, a.y / b, a.z / b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator /(const vec_t<T,4> &a, const T &b) { return vec_t<T,4>(a.x / b, a.y / b, a.z / b, a.w / b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator /(const T &a, const vec_t<T,2> &b) { return vec_t<T,2>(a / b.x, a / b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator /(const T &a, const vec_t<T,3> &b) { return vec_t<T,3>(a / b.x, a / b.y, a / b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator /(const T &a, const vec_t<T,4> &b) { return vec_t<T,4>(a / b.x, a / b.y, a / b.z, a / b.w); };
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator +(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(a.x + b.x, a.y + b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator +(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(a.x + b.x, a.y + b.y, a.z + b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator +(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(a.x + b.x,a.y + b.y,a.z + b.z,a.w + b.w); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator +(const vec_t<T,2> &a, const T &b) { return vec_t<T,2>(a.x + b, a.y + b); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> operator +(const vec_t<T1,3> &a, const T2 &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (a.x + b, a.y + b, a.z + b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator +(const vec_t<T,4> &a, const T &b) { return vec_t<T,4>(a.x + b, a.y + b, a.z + b, a.w + b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator +(const T &a, const vec_t<T,2> &b) { return vec_t<T,2>(a + b.x, a + b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator +(const T &a, const vec_t<T,3> &b) { return vec_t<T,3>(a + b.x, a + b.y, a + b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator +(const T &a, const vec_t<T,4> &b) { return vec_t<T,4>(a + b.x, a + b.y, a + b.z, a + b.w); };
    template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator -(const vec_t<T,2> &a, const vec_t<T,2> &b) { return vec_t<T,2>(a.x - b.x, a.y - b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator -(const vec_t<T,3> &a, const vec_t<T,3> &b) { return vec_t<T,3>(a.x - b.x, a.y - b.y, a.z - b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator -(const vec_t<T,4> &a, const vec_t<T,4> &b) { return vec_t<T,4>(a.x - b.x,a.y - b.y,a.z - b.z,a.w - b.w); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator -(const vec_t<T,2> &a, const T &b) { return vec_t<T,2>(a.x - b, a.y - b); } template<typename T1, typename T2> inline __attribute__((host)) __attribute__((device)) vec_t<typename BinaryOpResultType<T1,T2>::type,3> operator -(const vec_t<T1,3> &a, const T2 &b) { return vec_t<typename BinaryOpResultType<T1,T2>::type,3> (a.x - b, a.y - b, a.z - b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator -(const vec_t<T,4> &a, const T &b) { return vec_t<T,4>(a.x - b, a.y - b, a.z - b, a.w - b); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator -(const T &a, const vec_t<T,2> &b) { return vec_t<T,2>(a - b.x, a - b.y); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator -(const T &a, const vec_t<T,3> &b) { return vec_t<T,3>(a - b.x, a - b.y, a - b.z); } template<typename T> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> operator -(const T &a, const vec_t<T,4> &b) { return vec_t<T,4>(a - b.x, a - b.y, a - b.z, a - b.w); };
# 209 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h"
    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator-(const vec_t<T,2> &v)
    { return vec_t<T,2>(-v.x, -v.y); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,2> operator+(const vec_t<T,2> &v)
    { return vec_t<T,2>(v.x, v.y); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator-(const vec_t<T,3> &v)
    { return vec_t<T,3>(-v.x, -v.y, -v.z); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec_t<T,3> operator+(const vec_t<T,3> &v)
    { return vec_t<T,3>(v.x, v.y, v.z); }
# 278 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/functors.h"
    template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator*=(vec_t<T,2> &a, const vec_t<OT,2> &b) { a.x *= (T)b.x; a.y *= (T)b.y; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator*=(vec_t<T,3> &a, const vec_t<OT,3> &b) { a.x *= (T)b.x; a.y *= (T)b.y; a.z *= (T)b.z; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator*=(vec_t<T,4> &a, const vec_t<OT,4> &b) { a.x *= (T)b.x; a.y *= (T)b.y; a.z *= (T)b.z; a.w *= (T)b.w; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator*=(vec_t<T,2> &a, const OT &b) { a.x *= (T)b; a.y *= (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator*=(vec_t<T,3> &a, const OT &b) { a.x *= (T)b; a.y *= (T)b; a.z *= (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator*=(vec_t<T,4> &a, const OT &b) { a.x *= (T)b; a.y *= (T)b; a.z *= (T)b; a.w *= (T)b; return a; };
    template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator/=(vec_t<T,2> &a, const vec_t<OT,2> &b) { a.x /= (T)b.x; a.y /= (T)b.y; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator/=(vec_t<T,3> &a, const vec_t<OT,3> &b) { a.x /= (T)b.x; a.y /= (T)b.y; a.z /= (T)b.z; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator/=(vec_t<T,4> &a, const vec_t<OT,4> &b) { a.x /= (T)b.x; a.y /= (T)b.y; a.z /= (T)b.z; a.w /= (T)b.w; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator/=(vec_t<T,2> &a, const OT &b) { a.x /= (T)b; a.y /= (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator/=(vec_t<T,3> &a, const OT &b) { a.x /= (T)b; a.y /= (T)b; a.z /= (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator/=(vec_t<T,4> &a, const OT &b) { a.x /= (T)b; a.y /= (T)b; a.z /= (T)b; a.w /= (T)b; return a; };
    template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator+=(vec_t<T,2> &a, const vec_t<OT,2> &b) { a.x += (T)b.x; a.y += (T)b.y; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator+=(vec_t<T,3> &a, const vec_t<OT,3> &b) { a.x += (T)b.x; a.y += (T)b.y; a.z += (T)b.z; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator+=(vec_t<T,4> &a, const vec_t<OT,4> &b) { a.x += (T)b.x; a.y += (T)b.y; a.z += (T)b.z; a.w += (T)b.w; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator+=(vec_t<T,2> &a, const OT &b) { a.x += (T)b; a.y += (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator+=(vec_t<T,3> &a, const OT &b) { a.x += (T)b; a.y += (T)b; a.z += (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator+=(vec_t<T,4> &a, const OT &b) { a.x += (T)b; a.y += (T)b; a.z += (T)b; a.w += (T)b; return a; };
    template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator-=(vec_t<T,2> &a, const vec_t<OT,2> &b) { a.x -= (T)b.x; a.y -= (T)b.y; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator-=(vec_t<T,3> &a, const vec_t<OT,3> &b) { a.x -= (T)b.x; a.y -= (T)b.y; a.z -= (T)b.z; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator-=(vec_t<T,4> &a, const vec_t<OT,4> &b) { a.x -= (T)b.x; a.y -= (T)b.y; a.z -= (T)b.z; a.w -= (T)b.w; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,2> &operator-=(vec_t<T,2> &a, const OT &b) { a.x -= (T)b; a.y -= (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,3> &operator-=(vec_t<T,3> &a, const OT &b) { a.x -= (T)b; a.y -= (T)b; a.z -= (T)b; return a; } template<typename T, typename OT> inline __attribute__((host)) __attribute__((device)) vec_t<T,4> &operator-=(vec_t<T,4> &a, const OT &b) { a.x -= (T)b; a.y -= (T)b; a.z -= (T)b; a.w -= (T)b; return a; };




    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_min(const vec_t<T,1> &v) { return v.x; }
    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_min(const vec_t<T,2> &v) { return min(v.x,v.y); }
    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_min(const vec_t<T,3> &v) { return min(min(v.x,v.y),v.z); }
    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_min(const vec_t<T,4> &v) { return min(min(v.x,v.y),min(v.z,v.w)); }
    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_max(const vec_t<T,2> &v) { return max(v.x,v.y); }
    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_max(const vec_t<T,3> &v) { return max(max(v.x,v.y),v.z); }
    template<typename T>
    __attribute__((host)) __attribute__((device)) T reduce_max(const vec_t<T,4> &v) { return max(max(v.x,v.y),max(v.z,v.w)); }


    template<typename T, int N>
    __attribute__((host)) __attribute__((device)) vec_t<T,3> madd(const vec_t<T,N> &a, const vec_t<T,N> &b, const vec_t<T,N> &c)
    {
      return a*b + c;
    }


    template<typename T, int N>
    __attribute__((host)) __attribute__((device)) int arg_max(const vec_t<T,N> &v)
    {
      int biggestDim = 0;
      for (int i=1;i<N;i++)
        if ((v[i]) > (v[biggestDim])) biggestDim = i;
      return biggestDim;
    }

    template<typename T, int N>
    __attribute__((host)) __attribute__((device)) int arg_min(const vec_t<T,N> &v)
    {
      int biggestDim = 0;
      for (int i=1;i<N;i++)
        if ((v[i]) < (v[biggestDim])) biggestDim = i;
      return biggestDim;
    }



    template<typename T>
    __attribute__((host)) __attribute__((device)) bool operator<(const vec_t<T,3> &a, const vec_t<T,3> &b)
    {
      if (a.x < b.x) return true;
      if (a.x == b.x && a.y < b.y) return true;
      if (a.x == b.x && a.y == b.y && a.z < b.z) return true;
      return false;




    }


    inline __attribute__((host)) __attribute__((device)) vec3f randomColor(int i)
    {
      int r = unsigned(i)*13*17 + 0x234235;
      int g = unsigned(i)*7*3*5 + 0x773477;
      int b = unsigned(i)*11*19 + 0x223766;
      return vec3f((r&255)/255.f,
                   (g&255)/255.f,
                   (b&255)/255.f);
    }


    inline __attribute__((host)) __attribute__((device)) vec3f randomColor(size_t idx)
    {
      unsigned int r = (unsigned int)(idx*13*17 + 0x234235);
      unsigned int g = (unsigned int)(idx*7*3*5 + 0x773477);
      unsigned int b = (unsigned int)(idx*11*19 + 0x223766);
      return vec3f((r&255)/255.f,
                   (g&255)/255.f,
                   (b&255)/255.f);
    }


    template<typename T>
    inline __attribute__((host)) __attribute__((device)) vec3f randomColor(const T *ptr)
    {
      return randomColor((size_t)ptr);
    }

    inline __attribute__((host)) __attribute__((device)) float sqrt(const float v) { return sqrtf(v); }
inline __attribute__((host)) __attribute__((device)) vec2f sqrt(const vec2f v) { return vec2f(sqrtf(v.x),sqrtf(v.y)); }
inline __attribute__((host)) __attribute__((device)) vec3f sqrt(const vec3f v) { return vec3f(sqrtf(v.x),sqrtf(v.y),sqrtf(v.z)); }
inline __attribute__((host)) __attribute__((device)) vec4f sqrt(const vec4f v) { return vec4f(sqrtf(v.x),sqrtf(v.y),sqrtf(v.z),sqrtf(v.w)); }

  }
}
# 418 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/rotate.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec/rotate.h"
       

namespace owl {
  namespace common {






    inline __attribute__((host)) __attribute__((device)) float rotate(const float a, const float b)
    {
      float sum = a+b;
      return ((sum-1.f)<0.f)?(sum):(sum-1.f);
    }






    inline __attribute__((host)) __attribute__((device)) vec2f rotate(const vec2f a, const vec2f b)
    { return vec2f(rotate(a.x,b.x),rotate(a.y,b.y)); }

  }
}
# 419 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/vec.h" 2
# 20 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/box.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/box.h"
       



namespace owl {
  namespace common {

    template<typename T>
    struct interval {
      typedef T scalar_t;
      inline __attribute__((host)) __attribute__((device)) interval()
        : lower(owl::common::empty_bounds_lower<T>()),
          upper(owl::common::empty_bounds_upper<T>())
      {}
      inline __attribute__((host)) __attribute__((device)) interval(T begin, T end) : begin(begin), end(end) {}

      union {
        T begin;
        T lower;
        T lo;
      };
      union {
        T end;
        T upper;
        T hi;
      };

      inline __attribute__((host)) __attribute__((device)) bool contains(const T &t) const { return t >= lower && t <= upper; }
      inline __attribute__((host)) __attribute__((device)) bool is_empty() const { return begin > end; }
      inline __attribute__((host)) __attribute__((device)) T center() const { return (begin+end)/2; }
      inline __attribute__((host)) __attribute__((device)) T span() const { return end - begin; }
      inline __attribute__((host)) __attribute__((device)) T diagonal() const { return end - begin; }
      inline __attribute__((host)) __attribute__((device)) interval<T> &extend(const T &t)
      { lower = min(lower,t); upper = max(upper,t); return *this; }
      inline __attribute__((host)) __attribute__((device)) interval<T> &extend(const interval<T> &t)
      { lower = min(lower,t.lower); upper = max(upper,t.upper); return *this; }
      inline __attribute__((host)) __attribute__((device)) interval<T> including(const T &t)
      { return interval<T>(min(lower,t),max(upper,t)); }

      static inline __attribute__((host)) __attribute__((device)) interval<T> positive()
      {
        return interval<T>(0.f,owl::common::open_range_upper<T>());
      }
    };

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) std::ostream &operator<<(std::ostream &o, const interval<T> &b)
    {



      return o;
    }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) interval<T> build_interval(const T &a, const T &b)
    { return interval<T>(min(a,b),max(a,b)); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) interval<T> intersect(const interval<T> &a, const interval<T> &b)
    { return interval<T>(max(a.lower,b.lower),min(a.upper,b.upper)); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) interval<T> operator-(const interval<T> &a, const T &b)
    { return interval<T>(a.lower-b,a.upper-b); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) interval<T> operator*(const interval<T> &a, const T &b)
    { return build_interval<T>(a.lower*b,a.upper*b); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator==(const interval<T> &a, const interval<T> &b)
    { return a.lower == b.lower && a.upper == b.upper; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator!=(const interval<T> &a, const interval<T> &b)
    { return !(a == b); }



    template<typename T>
    struct box_t {
      typedef T vec_t;
      typedef typename T::scalar_t scalar_t;
      enum { dims = T::dims };

      inline __attribute__((host)) __attribute__((device)) box_t()
        : lower(owl::common::empty_bounds_lower<typename T::scalar_t>()),
          upper(owl::common::empty_bounds_upper<typename T::scalar_t>())
      {}







      explicit inline __attribute__((host)) __attribute__((device)) box_t(const vec_t &v)
        : lower(v),
          upper(v)
      {}


      inline __attribute__((host)) __attribute__((device)) box_t(const vec_t &lo, const vec_t &hi)
        : lower(lo),
          upper(hi)
      {}


      inline __attribute__((host)) __attribute__((device)) box_t including(const vec_t &other) const
      { return box_t(min(lower,other),max(upper,other)); }

      inline __attribute__((host)) __attribute__((device)) box_t including(const box_t &other) const
      { return box_t(min(lower,other.lower),max(upper,other.upper)); }



      inline __attribute__((host)) __attribute__((device)) box_t &extend(const vec_t &other)
      { lower = min(lower,other); upper = max(upper,other); return *this; }

      inline __attribute__((host)) __attribute__((device)) box_t &extend(const box_t &other)
      { lower = min(lower,other.lower); upper = max(upper,other.upper); return *this; }



      inline __attribute__((host)) __attribute__((device)) interval<scalar_t> get_slab(const uint32_t dim)
      {
        return interval<scalar_t>(lower[dim],upper[dim]);
      }

      inline __attribute__((host)) __attribute__((device)) bool contains(const vec_t &point) const
      { return !(any_less_than(point,lower) || any_greater_than(point,upper)); }

      inline __attribute__((host)) __attribute__((device)) bool overlaps(const box_t &other) const
      { return !(any_less_than(other.upper,lower) || any_greater_than(other.lower,upper)); }

      inline __attribute__((host)) __attribute__((device)) vec_t center() const { return (lower+upper)/(typename vec_t::scalar_t)2; }
      inline __attribute__((host)) __attribute__((device)) vec_t span() const { return upper-lower; }
      inline __attribute__((host)) __attribute__((device)) vec_t size() const { return upper-lower; }

      inline __attribute__((host)) __attribute__((device)) typename long_type_of<typename T::scalar_t>::type volume() const
      { return owl::common::volume(size()); }

      inline __attribute__((host)) __attribute__((device)) bool empty() const { return any_less_than(upper,lower); }

      vec_t lower, upper;
    };





    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type area(const box_t<vec_t<T,2>> &b)
    { return area(b.upper - b.lower); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type area(const box_t<vec_t<T,3>> &b)
    {
      const vec_t<T,3> diag = b.upper - b.lower;
      return 2.f*(area(vec_t<T,2>(diag.x,diag.y))+
                  area(vec_t<T,2>(diag.y,diag.z))+
                  area(vec_t<T,2>(diag.z,diag.x)));
    }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) typename long_type_of<T>::type volume(const box_t<vec_t<T,3>> &b)
    {
      const vec_t<T,3> diag = b.upper - b.lower;
      return diag.x*diag.y*diag.z;
    }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) std::ostream &operator<<(std::ostream &o, const box_t<T> &b)
    {



      return o;
    }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) box_t<T> intersection(const box_t<T> &a, const box_t<T> &b)
    { return box_t<T>(max(a.lower,b.lower),min(a.upper,b.upper)); }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator==(const box_t<T> &a, const box_t<T> &b)
    { return a.lower == b.lower && a.upper == b.upper; }

    template<typename T>
    inline __attribute__((host)) __attribute__((device)) bool operator!=(const box_t<T> &a, const box_t<T> &b)
    { return !(a == b); }
# 223 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/box.h"
    typedef box_t<vec_t<short int,2>> box2s; typedef box_t<vec_t<short int,3>> box3s; typedef box_t<vec_t<short int,4>> box4s; typedef box_t<vec3a_t<short int>> box3sa;;
    typedef box_t<vec_t<unsigned short int,2>> box2us; typedef box_t<vec_t<unsigned short int,3>> box3us; typedef box_t<vec_t<unsigned short int,4>> box4us; typedef box_t<vec3a_t<unsigned short int>> box3usa;;
    typedef box_t<vec_t<int,2>> box2i; typedef box_t<vec_t<int,3>> box3i; typedef box_t<vec_t<int,4>> box4i; typedef box_t<vec3a_t<int>> box3ia;;
    typedef box_t<vec_t<unsigned int,2>> box2ui; typedef box_t<vec_t<unsigned int,3>> box3ui; typedef box_t<vec_t<unsigned int,4>> box4ui; typedef box_t<vec3a_t<unsigned int>> box3uia;;
    typedef box_t<vec_t<float,2>> box2f; typedef box_t<vec_t<float,3>> box3f; typedef box_t<vec_t<float,4>> box4f; typedef box_t<vec3a_t<float>> box3fa;;



  }
}
# 21 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device.h" 2
# 33 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device.h"
namespace owl {

  using namespace owl::common;

  inline __attribute__((device)) vec2i getLaunchIndex()
  {
    return (vec2i)optixGetLaunchIndex();
  }



  inline __attribute__((device)) vec2i getLaunchDims()
  {
    return (vec2i)optixGetLaunchDimensions();
  }





  inline __attribute__((device)) const void *getProgramDataPointer()
  {
    return (const void*)optixGetSbtDataPointer();
  }





  template<typename T>
  inline __attribute__((device)) const T &getProgramData()
  {
    return *(const T*)getProgramDataPointer();
  }





  inline __attribute__((device)) float linear_to_srgb(float x) {
    if (x <= 0.0031308f) {
      return 12.92f * x;
    }
    return 1.055f * pow(x, 1.f/2.4f) - 0.055f;
  }

  inline __attribute__((device)) uint32_t make_8bit(const float f)
  {
    return min(255,max(0,int(f*256.f)));
  }

  inline __attribute__((device)) uint32_t make_rgba(const vec3f color)
  {
    return
      (make_8bit(color.x) << 0) +
      (make_8bit(color.y) << 8) +
      (make_8bit(color.z) << 16) +
      (0xffU << 24);
  }
  inline __attribute__((device)) uint32_t make_rgba(const vec4f color)
  {
    return
      (make_8bit(color.x) << 0) +
      (make_8bit(color.y) << 8) +
      (make_8bit(color.z) << 16) +
      (make_8bit(color.w) << 24);
  }


  static __inline__ __attribute__((always_inline)) __attribute__((device)) void* unpackPointer( uint32_t i0, uint32_t i1 )
  {
    const uint64_t uptr = static_cast<uint64_t>( i0 ) << 32 | i1;
    void* ptr = reinterpret_cast<void*>( uptr );
    return ptr;
  }


  static __inline__ __attribute__((always_inline)) __attribute__((device)) void packPointer( void* ptr, uint32_t& i0, uint32_t& i1 )
  {
    const uint64_t uptr = reinterpret_cast<uint64_t>( ptr );
    i0 = uptr >> 32;
    i1 = uptr & 0x00000000ffffffff;
  }


  static __inline__ __attribute__((always_inline)) __attribute__((device)) void *getPRDPointer()
  {
    const uint32_t u0 = optixGetPayload_0();
    const uint32_t u1 = optixGetPayload_1();
    return unpackPointer(u0, u1);
  }

  template<typename T>
  static __inline__ __attribute__((always_inline)) __attribute__((device)) T &getPRD()
  { return *(T*)getPRDPointer(); }

  template<int _rayType=0, int _numRayTypes=1>
  struct RayT {
    enum { rayType = _rayType };
    enum { numRayTypes = _numRayTypes };
    inline __attribute__((device)) RayT() {}
    inline __attribute__((device)) RayT(const vec3f &origin,
                          const vec3f &direction,
                          float tmin,
                          float tmax,
                          OptixVisibilityMask visibilityMask=(OptixVisibilityMask)(-1))
      : origin(origin),
        direction(direction),
        tmin(tmin),
        tmax(tmax),
        visibilityMask(visibilityMask)
    {}

    vec3f origin, direction;
    float tmin=0.f,tmax=1e30f,time=0.f;
    OptixVisibilityMask visibilityMask=(OptixVisibilityMask)-1;
  };
  typedef RayT<0,1> Ray;


  template<typename RayType, typename PRD>
  inline __attribute__((device))
  void traceRay(OptixTraversableHandle traversable,
                const RayType &ray,
                PRD &prd,
                uint32_t rayFlags = 0u)
  {
    unsigned int p0 = 0;
    unsigned int p1 = 0;
    owl::packPointer(&prd,p0,p1);

    optixTrace(traversable,
               (const float3&)ray.origin,
               (const float3&)ray.direction,
               ray.tmin,
               ray.tmax,
               ray.time,
               ray.visibilityMask,
                                rayFlags,
                                ray.rayType,
                                ray.numRayTypes,
                                ray.rayType,
               p0,
               p1);
  }

  template<typename PRD>
  inline __attribute__((device))
  void trace(OptixTraversableHandle traversable,
             const Ray &ray,
             int numRayTypes,
             PRD &prd,
             int sbtOffset = 0)
  {
    unsigned int p0 = 0;
    unsigned int p1 = 0;
    owl::packPointer(&prd,p0,p1);

    optixTrace(traversable,
               (const float3&)ray.origin,
               (const float3&)ray.direction,
               ray.tmin,
               ray.tmax,
               ray.time,
               ray.visibilityMask,
                                0u,
                                ray.rayType + numRayTypes*sbtOffset,
                                numRayTypes,
                                ray.rayType,
               p0,
               p1);
  }

}
# 29 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl.h" 2
# 4 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device_buffer.h" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/owl_device_buffer.h"
       



namespace owl {
  namespace device {



    struct Buffer {
      OWLDataType type;
      size_t count;
      void *data;
    };

  }
}
# 5 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 1
# 103 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp"
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/_fixes.hpp" 1
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 2 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/_fixes.hpp" 2
# 104 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp" 1


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 1 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3
       
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4

# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 2 3
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp" 2
# 33 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp"
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/../simd/platform.h" 1
       
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp" 2
# 585 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp"

# 585 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp"
namespace glm
{
 using std::size_t;



  typedef int length_t;

}







 namespace glm
 {
  template<typename T, std::size_t N>
  constexpr std::size_t countof(T const (&)[N])
  {
   return N;
  }
 }
# 623 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp"
namespace glm{
namespace detail
{
 template<typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template<>
 struct is_int<unsigned int>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<signed int>
 {
  enum test {value = ~0};
 };
}

 typedef unsigned int uint;
}
# 655 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp"
namespace glm{
namespace detail
{

  typedef std::uint64_t uint64;
  typedef std::int64_t int64;
# 679 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp"
}
}







namespace glm{
namespace detail
{
 using std::make_unsigned;
}
}
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2

       

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 110 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/climits" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/climits" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/climits" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/limits.h" 1 3 4
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/climits" 2 3
# 111 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cfloat" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cfloat" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cfloat" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/float.h" 1 3 4
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cfloat" 2 3
# 112 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 1 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3
       
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4

# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 2 3
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/fwd.hpp" 1
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/qualifier.hpp" 1
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp" 1
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/qualifier.hpp" 2


# 5 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/qualifier.hpp"
namespace glm
{

 enum qualifier
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/qualifier.hpp"
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

 typedef qualifier precision;

 template<length_t L, typename T, qualifier Q = defaultp> struct vec;
 template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
 template<typename T, qualifier Q = defaultp> struct qua;


  template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;


namespace detail
{
 template<glm::qualifier P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 84 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/qualifier.hpp"
 template<length_t L, typename T, bool is_aligned>
 struct storage
 {
  typedef struct type {
   T data[L];
  } type;
 };


  template<length_t L, typename T>
  struct storage<L, T, true>
  {
   typedef struct alignas(L * sizeof(T)) type {
    T data[L];
   } type;
  };

  template<typename T>
  struct storage<3, T, true>
  {
   typedef struct alignas(4 * sizeof(T)) type {
    T data[4];
   } type;
  };
# 190 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/qualifier.hpp"
 enum genTypeEnum
 {
  GENTYPE_VEC,
  GENTYPE_MAT,
  GENTYPE_QUAT
 };

 template <typename genType>
 struct genTypeTrait
 {};

 template <length_t C, length_t R, typename T>
 struct genTypeTrait<mat<C, R, T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_MAT;
 };

 template<typename genType, genTypeEnum type>
 struct init_gentype
 {
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_QUAT>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static genType identity()
  {
   return genType(1, 0, 0, 0);
  }
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_MAT>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static genType identity()
  {
   return genType(1);
  }
 };
}
}
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/fwd.hpp" 2

namespace glm
{

 typedef std::int8_t int8;
 typedef std::int16_t int16;
 typedef std::int32_t int32;
 typedef std::int64_t int64;

 typedef std::uint8_t uint8;
 typedef std::uint16_t uint16;
 typedef std::uint32_t uint32;
 typedef std::uint64_t uint64;
# 31 "/beegfs/teran_parrales/NVISII/externals/glm/glm/fwd.hpp"
 typedef int8 lowp_i8;
 typedef int8 mediump_i8;
 typedef int8 highp_i8;
 typedef int8 i8;

 typedef int8 lowp_int8;
 typedef int8 mediump_int8;
 typedef int8 highp_int8;

 typedef int8 lowp_int8_t;
 typedef int8 mediump_int8_t;
 typedef int8 highp_int8_t;
 typedef int8 int8_t;

 typedef int16 lowp_i16;
 typedef int16 mediump_i16;
 typedef int16 highp_i16;
 typedef int16 i16;

 typedef int16 lowp_int16;
 typedef int16 mediump_int16;
 typedef int16 highp_int16;

 typedef int16 lowp_int16_t;
 typedef int16 mediump_int16_t;
 typedef int16 highp_int16_t;
 typedef int16 int16_t;

 typedef int32 lowp_i32;
 typedef int32 mediump_i32;
 typedef int32 highp_i32;
 typedef int32 i32;

 typedef int32 lowp_int32;
 typedef int32 mediump_int32;
 typedef int32 highp_int32;

 typedef int32 lowp_int32_t;
 typedef int32 mediump_int32_t;
 typedef int32 highp_int32_t;
 typedef int32 int32_t;

 typedef int64 lowp_i64;
 typedef int64 mediump_i64;
 typedef int64 highp_i64;
 typedef int64 i64;

 typedef int64 lowp_int64;
 typedef int64 mediump_int64;
 typedef int64 highp_int64;

 typedef int64 lowp_int64_t;
 typedef int64 mediump_int64_t;
 typedef int64 highp_int64_t;
 typedef int64 int64_t;



 typedef unsigned int uint;

 typedef uint8 lowp_u8;
 typedef uint8 mediump_u8;
 typedef uint8 highp_u8;
 typedef uint8 u8;

 typedef uint8 lowp_uint8;
 typedef uint8 mediump_uint8;
 typedef uint8 highp_uint8;

 typedef uint8 lowp_uint8_t;
 typedef uint8 mediump_uint8_t;
 typedef uint8 highp_uint8_t;
 typedef uint8 uint8_t;

 typedef uint16 lowp_u16;
 typedef uint16 mediump_u16;
 typedef uint16 highp_u16;
 typedef uint16 u16;

 typedef uint16 lowp_uint16;
 typedef uint16 mediump_uint16;
 typedef uint16 highp_uint16;

 typedef uint16 lowp_uint16_t;
 typedef uint16 mediump_uint16_t;
 typedef uint16 highp_uint16_t;
 typedef uint16 uint16_t;

 typedef uint32 lowp_u32;
 typedef uint32 mediump_u32;
 typedef uint32 highp_u32;
 typedef uint32 u32;

 typedef uint32 lowp_uint32;
 typedef uint32 mediump_uint32;
 typedef uint32 highp_uint32;

 typedef uint32 lowp_uint32_t;
 typedef uint32 mediump_uint32_t;
 typedef uint32 highp_uint32_t;
 typedef uint32 uint32_t;

 typedef uint64 lowp_u64;
 typedef uint64 mediump_u64;
 typedef uint64 highp_u64;
 typedef uint64 u64;

 typedef uint64 lowp_uint64;
 typedef uint64 mediump_uint64;
 typedef uint64 highp_uint64;

 typedef uint64 lowp_uint64_t;
 typedef uint64 mediump_uint64_t;
 typedef uint64 highp_uint64_t;
 typedef uint64 uint64_t;



 typedef float lowp_f32;
 typedef float mediump_f32;
 typedef float highp_f32;
 typedef float f32;

 typedef float lowp_float32;
 typedef float mediump_float32;
 typedef float highp_float32;
 typedef float float32;

 typedef float lowp_float32_t;
 typedef float mediump_float32_t;
 typedef float highp_float32_t;
 typedef float float32_t;


 typedef double lowp_f64;
 typedef double mediump_f64;
 typedef double highp_f64;
 typedef double f64;

 typedef double lowp_float64;
 typedef double mediump_float64;
 typedef double highp_float64;
 typedef double float64;

 typedef double lowp_float64_t;
 typedef double mediump_float64_t;
 typedef double highp_float64_t;
 typedef double float64_t;



 typedef vec<1, bool, lowp> lowp_bvec1;
 typedef vec<2, bool, lowp> lowp_bvec2;
 typedef vec<3, bool, lowp> lowp_bvec3;
 typedef vec<4, bool, lowp> lowp_bvec4;

 typedef vec<1, bool, mediump> mediump_bvec1;
 typedef vec<2, bool, mediump> mediump_bvec2;
 typedef vec<3, bool, mediump> mediump_bvec3;
 typedef vec<4, bool, mediump> mediump_bvec4;

 typedef vec<1, bool, highp> highp_bvec1;
 typedef vec<2, bool, highp> highp_bvec2;
 typedef vec<3, bool, highp> highp_bvec3;
 typedef vec<4, bool, highp> highp_bvec4;

 typedef vec<1, bool, defaultp> bvec1;
 typedef vec<2, bool, defaultp> bvec2;
 typedef vec<3, bool, defaultp> bvec3;
 typedef vec<4, bool, defaultp> bvec4;



 typedef vec<1, int, lowp> lowp_ivec1;
 typedef vec<2, int, lowp> lowp_ivec2;
 typedef vec<3, int, lowp> lowp_ivec3;
 typedef vec<4, int, lowp> lowp_ivec4;

 typedef vec<1, int, mediump> mediump_ivec1;
 typedef vec<2, int, mediump> mediump_ivec2;
 typedef vec<3, int, mediump> mediump_ivec3;
 typedef vec<4, int, mediump> mediump_ivec4;

 typedef vec<1, int, highp> highp_ivec1;
 typedef vec<2, int, highp> highp_ivec2;
 typedef vec<3, int, highp> highp_ivec3;
 typedef vec<4, int, highp> highp_ivec4;

 typedef vec<1, int, defaultp> ivec1;
 typedef vec<2, int, defaultp> ivec2;
 typedef vec<3, int, defaultp> ivec3;
 typedef vec<4, int, defaultp> ivec4;

 typedef vec<1, i8, lowp> lowp_i8vec1;
 typedef vec<2, i8, lowp> lowp_i8vec2;
 typedef vec<3, i8, lowp> lowp_i8vec3;
 typedef vec<4, i8, lowp> lowp_i8vec4;

 typedef vec<1, i8, mediump> mediump_i8vec1;
 typedef vec<2, i8, mediump> mediump_i8vec2;
 typedef vec<3, i8, mediump> mediump_i8vec3;
 typedef vec<4, i8, mediump> mediump_i8vec4;

 typedef vec<1, i8, highp> highp_i8vec1;
 typedef vec<2, i8, highp> highp_i8vec2;
 typedef vec<3, i8, highp> highp_i8vec3;
 typedef vec<4, i8, highp> highp_i8vec4;

 typedef vec<1, i8, defaultp> i8vec1;
 typedef vec<2, i8, defaultp> i8vec2;
 typedef vec<3, i8, defaultp> i8vec3;
 typedef vec<4, i8, defaultp> i8vec4;

 typedef vec<1, i16, lowp> lowp_i16vec1;
 typedef vec<2, i16, lowp> lowp_i16vec2;
 typedef vec<3, i16, lowp> lowp_i16vec3;
 typedef vec<4, i16, lowp> lowp_i16vec4;

 typedef vec<1, i16, mediump> mediump_i16vec1;
 typedef vec<2, i16, mediump> mediump_i16vec2;
 typedef vec<3, i16, mediump> mediump_i16vec3;
 typedef vec<4, i16, mediump> mediump_i16vec4;

 typedef vec<1, i16, highp> highp_i16vec1;
 typedef vec<2, i16, highp> highp_i16vec2;
 typedef vec<3, i16, highp> highp_i16vec3;
 typedef vec<4, i16, highp> highp_i16vec4;

 typedef vec<1, i16, defaultp> i16vec1;
 typedef vec<2, i16, defaultp> i16vec2;
 typedef vec<3, i16, defaultp> i16vec3;
 typedef vec<4, i16, defaultp> i16vec4;

 typedef vec<1, i32, lowp> lowp_i32vec1;
 typedef vec<2, i32, lowp> lowp_i32vec2;
 typedef vec<3, i32, lowp> lowp_i32vec3;
 typedef vec<4, i32, lowp> lowp_i32vec4;

 typedef vec<1, i32, mediump> mediump_i32vec1;
 typedef vec<2, i32, mediump> mediump_i32vec2;
 typedef vec<3, i32, mediump> mediump_i32vec3;
 typedef vec<4, i32, mediump> mediump_i32vec4;

 typedef vec<1, i32, highp> highp_i32vec1;
 typedef vec<2, i32, highp> highp_i32vec2;
 typedef vec<3, i32, highp> highp_i32vec3;
 typedef vec<4, i32, highp> highp_i32vec4;

 typedef vec<1, i32, defaultp> i32vec1;
 typedef vec<2, i32, defaultp> i32vec2;
 typedef vec<3, i32, defaultp> i32vec3;
 typedef vec<4, i32, defaultp> i32vec4;

 typedef vec<1, i64, lowp> lowp_i64vec1;
 typedef vec<2, i64, lowp> lowp_i64vec2;
 typedef vec<3, i64, lowp> lowp_i64vec3;
 typedef vec<4, i64, lowp> lowp_i64vec4;

 typedef vec<1, i64, mediump> mediump_i64vec1;
 typedef vec<2, i64, mediump> mediump_i64vec2;
 typedef vec<3, i64, mediump> mediump_i64vec3;
 typedef vec<4, i64, mediump> mediump_i64vec4;

 typedef vec<1, i64, highp> highp_i64vec1;
 typedef vec<2, i64, highp> highp_i64vec2;
 typedef vec<3, i64, highp> highp_i64vec3;
 typedef vec<4, i64, highp> highp_i64vec4;

 typedef vec<1, i64, defaultp> i64vec1;
 typedef vec<2, i64, defaultp> i64vec2;
 typedef vec<3, i64, defaultp> i64vec3;
 typedef vec<4, i64, defaultp> i64vec4;



 typedef vec<1, uint, lowp> lowp_uvec1;
 typedef vec<2, uint, lowp> lowp_uvec2;
 typedef vec<3, uint, lowp> lowp_uvec3;
 typedef vec<4, uint, lowp> lowp_uvec4;

 typedef vec<1, uint, mediump> mediump_uvec1;
 typedef vec<2, uint, mediump> mediump_uvec2;
 typedef vec<3, uint, mediump> mediump_uvec3;
 typedef vec<4, uint, mediump> mediump_uvec4;

 typedef vec<1, uint, highp> highp_uvec1;
 typedef vec<2, uint, highp> highp_uvec2;
 typedef vec<3, uint, highp> highp_uvec3;
 typedef vec<4, uint, highp> highp_uvec4;

 typedef vec<1, uint, defaultp> uvec1;
 typedef vec<2, uint, defaultp> uvec2;
 typedef vec<3, uint, defaultp> uvec3;
 typedef vec<4, uint, defaultp> uvec4;

 typedef vec<1, u8, lowp> lowp_u8vec1;
 typedef vec<2, u8, lowp> lowp_u8vec2;
 typedef vec<3, u8, lowp> lowp_u8vec3;
 typedef vec<4, u8, lowp> lowp_u8vec4;

 typedef vec<1, u8, mediump> mediump_u8vec1;
 typedef vec<2, u8, mediump> mediump_u8vec2;
 typedef vec<3, u8, mediump> mediump_u8vec3;
 typedef vec<4, u8, mediump> mediump_u8vec4;

 typedef vec<1, u8, highp> highp_u8vec1;
 typedef vec<2, u8, highp> highp_u8vec2;
 typedef vec<3, u8, highp> highp_u8vec3;
 typedef vec<4, u8, highp> highp_u8vec4;

 typedef vec<1, u8, defaultp> u8vec1;
 typedef vec<2, u8, defaultp> u8vec2;
 typedef vec<3, u8, defaultp> u8vec3;
 typedef vec<4, u8, defaultp> u8vec4;

 typedef vec<1, u16, lowp> lowp_u16vec1;
 typedef vec<2, u16, lowp> lowp_u16vec2;
 typedef vec<3, u16, lowp> lowp_u16vec3;
 typedef vec<4, u16, lowp> lowp_u16vec4;

 typedef vec<1, u16, mediump> mediump_u16vec1;
 typedef vec<2, u16, mediump> mediump_u16vec2;
 typedef vec<3, u16, mediump> mediump_u16vec3;
 typedef vec<4, u16, mediump> mediump_u16vec4;

 typedef vec<1, u16, highp> highp_u16vec1;
 typedef vec<2, u16, highp> highp_u16vec2;
 typedef vec<3, u16, highp> highp_u16vec3;
 typedef vec<4, u16, highp> highp_u16vec4;

 typedef vec<1, u16, defaultp> u16vec1;
 typedef vec<2, u16, defaultp> u16vec2;
 typedef vec<3, u16, defaultp> u16vec3;
 typedef vec<4, u16, defaultp> u16vec4;

 typedef vec<1, u32, lowp> lowp_u32vec1;
 typedef vec<2, u32, lowp> lowp_u32vec2;
 typedef vec<3, u32, lowp> lowp_u32vec3;
 typedef vec<4, u32, lowp> lowp_u32vec4;

 typedef vec<1, u32, mediump> mediump_u32vec1;
 typedef vec<2, u32, mediump> mediump_u32vec2;
 typedef vec<3, u32, mediump> mediump_u32vec3;
 typedef vec<4, u32, mediump> mediump_u32vec4;

 typedef vec<1, u32, highp> highp_u32vec1;
 typedef vec<2, u32, highp> highp_u32vec2;
 typedef vec<3, u32, highp> highp_u32vec3;
 typedef vec<4, u32, highp> highp_u32vec4;

 typedef vec<1, u32, defaultp> u32vec1;
 typedef vec<2, u32, defaultp> u32vec2;
 typedef vec<3, u32, defaultp> u32vec3;
 typedef vec<4, u32, defaultp> u32vec4;

 typedef vec<1, u64, lowp> lowp_u64vec1;
 typedef vec<2, u64, lowp> lowp_u64vec2;
 typedef vec<3, u64, lowp> lowp_u64vec3;
 typedef vec<4, u64, lowp> lowp_u64vec4;

 typedef vec<1, u64, mediump> mediump_u64vec1;
 typedef vec<2, u64, mediump> mediump_u64vec2;
 typedef vec<3, u64, mediump> mediump_u64vec3;
 typedef vec<4, u64, mediump> mediump_u64vec4;

 typedef vec<1, u64, highp> highp_u64vec1;
 typedef vec<2, u64, highp> highp_u64vec2;
 typedef vec<3, u64, highp> highp_u64vec3;
 typedef vec<4, u64, highp> highp_u64vec4;

 typedef vec<1, u64, defaultp> u64vec1;
 typedef vec<2, u64, defaultp> u64vec2;
 typedef vec<3, u64, defaultp> u64vec3;
 typedef vec<4, u64, defaultp> u64vec4;



 typedef vec<1, float, lowp> lowp_vec1;
 typedef vec<2, float, lowp> lowp_vec2;
 typedef vec<3, float, lowp> lowp_vec3;
 typedef vec<4, float, lowp> lowp_vec4;

 typedef vec<1, float, mediump> mediump_vec1;
 typedef vec<2, float, mediump> mediump_vec2;
 typedef vec<3, float, mediump> mediump_vec3;
 typedef vec<4, float, mediump> mediump_vec4;

 typedef vec<1, float, highp> highp_vec1;
 typedef vec<2, float, highp> highp_vec2;
 typedef vec<3, float, highp> highp_vec3;
 typedef vec<4, float, highp> highp_vec4;

 typedef vec<1, float, defaultp> vec1;
 typedef vec<2, float, defaultp> vec2;
 typedef vec<3, float, defaultp> vec3;
 typedef vec<4, float, defaultp> vec4;

 typedef vec<1, float, lowp> lowp_fvec1;
 typedef vec<2, float, lowp> lowp_fvec2;
 typedef vec<3, float, lowp> lowp_fvec3;
 typedef vec<4, float, lowp> lowp_fvec4;

 typedef vec<1, float, mediump> mediump_fvec1;
 typedef vec<2, float, mediump> mediump_fvec2;
 typedef vec<3, float, mediump> mediump_fvec3;
 typedef vec<4, float, mediump> mediump_fvec4;

 typedef vec<1, float, highp> highp_fvec1;
 typedef vec<2, float, highp> highp_fvec2;
 typedef vec<3, float, highp> highp_fvec3;
 typedef vec<4, float, highp> highp_fvec4;

 typedef vec<1, f32, defaultp> fvec1;
 typedef vec<2, f32, defaultp> fvec2;
 typedef vec<3, f32, defaultp> fvec3;
 typedef vec<4, f32, defaultp> fvec4;

 typedef vec<1, f32, lowp> lowp_f32vec1;
 typedef vec<2, f32, lowp> lowp_f32vec2;
 typedef vec<3, f32, lowp> lowp_f32vec3;
 typedef vec<4, f32, lowp> lowp_f32vec4;

 typedef vec<1, f32, mediump> mediump_f32vec1;
 typedef vec<2, f32, mediump> mediump_f32vec2;
 typedef vec<3, f32, mediump> mediump_f32vec3;
 typedef vec<4, f32, mediump> mediump_f32vec4;

 typedef vec<1, f32, highp> highp_f32vec1;
 typedef vec<2, f32, highp> highp_f32vec2;
 typedef vec<3, f32, highp> highp_f32vec3;
 typedef vec<4, f32, highp> highp_f32vec4;

 typedef vec<1, f32, defaultp> f32vec1;
 typedef vec<2, f32, defaultp> f32vec2;
 typedef vec<3, f32, defaultp> f32vec3;
 typedef vec<4, f32, defaultp> f32vec4;

 typedef vec<1, f64, lowp> lowp_dvec1;
 typedef vec<2, f64, lowp> lowp_dvec2;
 typedef vec<3, f64, lowp> lowp_dvec3;
 typedef vec<4, f64, lowp> lowp_dvec4;

 typedef vec<1, f64, mediump> mediump_dvec1;
 typedef vec<2, f64, mediump> mediump_dvec2;
 typedef vec<3, f64, mediump> mediump_dvec3;
 typedef vec<4, f64, mediump> mediump_dvec4;

 typedef vec<1, f64, highp> highp_dvec1;
 typedef vec<2, f64, highp> highp_dvec2;
 typedef vec<3, f64, highp> highp_dvec3;
 typedef vec<4, f64, highp> highp_dvec4;

 typedef vec<1, f64, defaultp> dvec1;
 typedef vec<2, f64, defaultp> dvec2;
 typedef vec<3, f64, defaultp> dvec3;
 typedef vec<4, f64, defaultp> dvec4;

 typedef vec<1, f64, lowp> lowp_f64vec1;
 typedef vec<2, f64, lowp> lowp_f64vec2;
 typedef vec<3, f64, lowp> lowp_f64vec3;
 typedef vec<4, f64, lowp> lowp_f64vec4;

 typedef vec<1, f64, mediump> mediump_f64vec1;
 typedef vec<2, f64, mediump> mediump_f64vec2;
 typedef vec<3, f64, mediump> mediump_f64vec3;
 typedef vec<4, f64, mediump> mediump_f64vec4;

 typedef vec<1, f64, highp> highp_f64vec1;
 typedef vec<2, f64, highp> highp_f64vec2;
 typedef vec<3, f64, highp> highp_f64vec3;
 typedef vec<4, f64, highp> highp_f64vec4;

 typedef vec<1, f64, defaultp> f64vec1;
 typedef vec<2, f64, defaultp> f64vec2;
 typedef vec<3, f64, defaultp> f64vec3;
 typedef vec<4, f64, defaultp> f64vec4;



 typedef mat<2, 2, f32, lowp> lowp_mat2;
 typedef mat<3, 3, f32, lowp> lowp_mat3;
 typedef mat<4, 4, f32, lowp> lowp_mat4;

 typedef mat<2, 2, f32, mediump> mediump_mat2;
 typedef mat<3, 3, f32, mediump> mediump_mat3;
 typedef mat<4, 4, f32, mediump> mediump_mat4;

 typedef mat<2, 2, f32, highp> highp_mat2;
 typedef mat<3, 3, f32, highp> highp_mat3;
 typedef mat<4, 4, f32, highp> highp_mat4;

 typedef mat<2, 2, f32, defaultp> mat2;
 typedef mat<3, 3, f32, defaultp> mat3;
 typedef mat<4, 4, f32, defaultp> mat4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4;

 typedef mat<2, 2, f32, highp> highp_fmat2;
 typedef mat<3, 3, f32, highp> highp_fmat3;
 typedef mat<4, 4, f32, highp> highp_fmat4;

 typedef mat<2, 2, f32, defaultp> fmat2;
 typedef mat<3, 3, f32, defaultp> fmat3;
 typedef mat<4, 4, f32, defaultp> fmat4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4;

 typedef mat<2, 2, f32, highp> highp_f32mat2;
 typedef mat<3, 3, f32, highp> highp_f32mat3;
 typedef mat<4, 4, f32, highp> highp_f32mat4;

 typedef mat<2, 2, f32, defaultp> f32mat2;
 typedef mat<3, 3, f32, defaultp> f32mat3;
 typedef mat<4, 4, f32, defaultp> f32mat4;

 typedef mat<2, 2, f64, lowp> lowp_dmat2;
 typedef mat<3, 3, f64, lowp> lowp_dmat3;
 typedef mat<4, 4, f64, lowp> lowp_dmat4;

 typedef mat<2, 2, f64, mediump> mediump_dmat2;
 typedef mat<3, 3, f64, mediump> mediump_dmat3;
 typedef mat<4, 4, f64, mediump> mediump_dmat4;

 typedef mat<2, 2, f64, highp> highp_dmat2;
 typedef mat<3, 3, f64, highp> highp_dmat3;
 typedef mat<4, 4, f64, highp> highp_dmat4;

 typedef mat<2, 2, f64, defaultp> dmat2;
 typedef mat<3, 3, f64, defaultp> dmat3;
 typedef mat<4, 4, f64, defaultp> dmat4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4;

 typedef mat<2, 2, f64, highp> highp_f64mat2;
 typedef mat<3, 3, f64, highp> highp_f64mat3;
 typedef mat<4, 4, f64, highp> highp_f64mat4;

 typedef mat<2, 2, f64, defaultp> f64mat2;
 typedef mat<3, 3, f64, defaultp> f64mat3;
 typedef mat<4, 4, f64, defaultp> f64mat4;



 typedef mat<2, 2, f32, lowp> lowp_mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_mat4x4;

 typedef mat<2, 2, f32, highp> highp_mat2x2;
 typedef mat<2, 3, f32, highp> highp_mat2x3;
 typedef mat<2, 4, f32, highp> highp_mat2x4;
 typedef mat<3, 2, f32, highp> highp_mat3x2;
 typedef mat<3, 3, f32, highp> highp_mat3x3;
 typedef mat<3, 4, f32, highp> highp_mat3x4;
 typedef mat<4, 2, f32, highp> highp_mat4x2;
 typedef mat<4, 3, f32, highp> highp_mat4x3;
 typedef mat<4, 4, f32, highp> highp_mat4x4;

 typedef mat<2, 2, f32, defaultp> mat2x2;
 typedef mat<3, 2, f32, defaultp> mat3x2;
 typedef mat<4, 2, f32, defaultp> mat4x2;
 typedef mat<2, 3, f32, defaultp> mat2x3;
 typedef mat<3, 3, f32, defaultp> mat3x3;
 typedef mat<4, 3, f32, defaultp> mat4x3;
 typedef mat<2, 4, f32, defaultp> mat2x4;
 typedef mat<3, 4, f32, defaultp> mat3x4;
 typedef mat<4, 4, f32, defaultp> mat4x4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;
 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;
 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;
 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;
 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;
 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;
 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;
 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;
 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;
 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;
 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;
 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;
 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;

 typedef mat<2, 2, f32, highp> highp_fmat2x2;
 typedef mat<2, 3, f32, highp> highp_fmat2x3;
 typedef mat<2, 4, f32, highp> highp_fmat2x4;
 typedef mat<3, 2, f32, highp> highp_fmat3x2;
 typedef mat<3, 3, f32, highp> highp_fmat3x3;
 typedef mat<3, 4, f32, highp> highp_fmat3x4;
 typedef mat<4, 2, f32, highp> highp_fmat4x2;
 typedef mat<4, 3, f32, highp> highp_fmat4x3;
 typedef mat<4, 4, f32, highp> highp_fmat4x4;

 typedef mat<2, 2, f32, defaultp> fmat2x2;
 typedef mat<3, 2, f32, defaultp> fmat3x2;
 typedef mat<4, 2, f32, defaultp> fmat4x2;
 typedef mat<2, 3, f32, defaultp> fmat2x3;
 typedef mat<3, 3, f32, defaultp> fmat3x3;
 typedef mat<4, 3, f32, defaultp> fmat4x3;
 typedef mat<2, 4, f32, defaultp> fmat2x4;
 typedef mat<3, 4, f32, defaultp> fmat3x4;
 typedef mat<4, 4, f32, defaultp> fmat4x4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;

 typedef mat<2, 2, f32, highp> highp_f32mat2x2;
 typedef mat<2, 3, f32, highp> highp_f32mat2x3;
 typedef mat<2, 4, f32, highp> highp_f32mat2x4;
 typedef mat<3, 2, f32, highp> highp_f32mat3x2;
 typedef mat<3, 3, f32, highp> highp_f32mat3x3;
 typedef mat<3, 4, f32, highp> highp_f32mat3x4;
 typedef mat<4, 2, f32, highp> highp_f32mat4x2;
 typedef mat<4, 3, f32, highp> highp_f32mat4x3;
 typedef mat<4, 4, f32, highp> highp_f32mat4x4;

 typedef mat<2, 2, f32, defaultp> f32mat2x2;
 typedef mat<3, 2, f32, defaultp> f32mat3x2;
 typedef mat<4, 2, f32, defaultp> f32mat4x2;
 typedef mat<2, 3, f32, defaultp> f32mat2x3;
 typedef mat<3, 3, f32, defaultp> f32mat3x3;
 typedef mat<4, 3, f32, defaultp> f32mat4x3;
 typedef mat<2, 4, f32, defaultp> f32mat2x4;
 typedef mat<3, 4, f32, defaultp> f32mat3x4;
 typedef mat<4, 4, f32, defaultp> f32mat4x4;

 typedef mat<2, 2, double, lowp> lowp_dmat2x2;
 typedef mat<2, 3, double, lowp> lowp_dmat2x3;
 typedef mat<2, 4, double, lowp> lowp_dmat2x4;
 typedef mat<3, 2, double, lowp> lowp_dmat3x2;
 typedef mat<3, 3, double, lowp> lowp_dmat3x3;
 typedef mat<3, 4, double, lowp> lowp_dmat3x4;
 typedef mat<4, 2, double, lowp> lowp_dmat4x2;
 typedef mat<4, 3, double, lowp> lowp_dmat4x3;
 typedef mat<4, 4, double, lowp> lowp_dmat4x4;

 typedef mat<2, 2, double, mediump> mediump_dmat2x2;
 typedef mat<2, 3, double, mediump> mediump_dmat2x3;
 typedef mat<2, 4, double, mediump> mediump_dmat2x4;
 typedef mat<3, 2, double, mediump> mediump_dmat3x2;
 typedef mat<3, 3, double, mediump> mediump_dmat3x3;
 typedef mat<3, 4, double, mediump> mediump_dmat3x4;
 typedef mat<4, 2, double, mediump> mediump_dmat4x2;
 typedef mat<4, 3, double, mediump> mediump_dmat4x3;
 typedef mat<4, 4, double, mediump> mediump_dmat4x4;

 typedef mat<2, 2, double, highp> highp_dmat2x2;
 typedef mat<2, 3, double, highp> highp_dmat2x3;
 typedef mat<2, 4, double, highp> highp_dmat2x4;
 typedef mat<3, 2, double, highp> highp_dmat3x2;
 typedef mat<3, 3, double, highp> highp_dmat3x3;
 typedef mat<3, 4, double, highp> highp_dmat3x4;
 typedef mat<4, 2, double, highp> highp_dmat4x2;
 typedef mat<4, 3, double, highp> highp_dmat4x3;
 typedef mat<4, 4, double, highp> highp_dmat4x4;

 typedef mat<2, 2, double, defaultp> dmat2x2;
 typedef mat<3, 2, double, defaultp> dmat3x2;
 typedef mat<4, 2, double, defaultp> dmat4x2;
 typedef mat<2, 3, double, defaultp> dmat2x3;
 typedef mat<3, 3, double, defaultp> dmat3x3;
 typedef mat<4, 3, double, defaultp> dmat4x3;
 typedef mat<2, 4, double, defaultp> dmat2x4;
 typedef mat<3, 4, double, defaultp> dmat3x4;
 typedef mat<4, 4, double, defaultp> dmat4x4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;
 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;
 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;
 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;
 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;
 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;
 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;
 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;
 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;
 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;
 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;
 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;
 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;

 typedef mat<2, 2, f64, highp> highp_f64mat2x2;
 typedef mat<2, 3, f64, highp> highp_f64mat2x3;
 typedef mat<2, 4, f64, highp> highp_f64mat2x4;
 typedef mat<3, 2, f64, highp> highp_f64mat3x2;
 typedef mat<3, 3, f64, highp> highp_f64mat3x3;
 typedef mat<3, 4, f64, highp> highp_f64mat3x4;
 typedef mat<4, 2, f64, highp> highp_f64mat4x2;
 typedef mat<4, 3, f64, highp> highp_f64mat4x3;
 typedef mat<4, 4, f64, highp> highp_f64mat4x4;

 typedef mat<2, 2, f64, defaultp> f64mat2x2;
 typedef mat<3, 2, f64, defaultp> f64mat3x2;
 typedef mat<4, 2, f64, defaultp> f64mat4x2;
 typedef mat<2, 3, f64, defaultp> f64mat2x3;
 typedef mat<3, 3, f64, defaultp> f64mat3x3;
 typedef mat<4, 3, f64, defaultp> f64mat4x3;
 typedef mat<2, 4, f64, defaultp> f64mat2x4;
 typedef mat<3, 4, f64, defaultp> f64mat3x4;
 typedef mat<4, 4, f64, defaultp> f64mat4x4;



 typedef mat<2, 2, int, lowp> lowp_imat2x2;
 typedef mat<2, 3, int, lowp> lowp_imat2x3;
 typedef mat<2, 4, int, lowp> lowp_imat2x4;
 typedef mat<3, 2, int, lowp> lowp_imat3x2;
 typedef mat<3, 3, int, lowp> lowp_imat3x3;
 typedef mat<3, 4, int, lowp> lowp_imat3x4;
 typedef mat<4, 2, int, lowp> lowp_imat4x2;
 typedef mat<4, 3, int, lowp> lowp_imat4x3;
 typedef mat<4, 4, int, lowp> lowp_imat4x4;

 typedef mat<2, 2, int, mediump> mediump_imat2x2;
 typedef mat<2, 3, int, mediump> mediump_imat2x3;
 typedef mat<2, 4, int, mediump> mediump_imat2x4;
 typedef mat<3, 2, int, mediump> mediump_imat3x2;
 typedef mat<3, 3, int, mediump> mediump_imat3x3;
 typedef mat<3, 4, int, mediump> mediump_imat3x4;
 typedef mat<4, 2, int, mediump> mediump_imat4x2;
 typedef mat<4, 3, int, mediump> mediump_imat4x3;
 typedef mat<4, 4, int, mediump> mediump_imat4x4;

 typedef mat<2, 2, int, highp> highp_imat2x2;
 typedef mat<2, 3, int, highp> highp_imat2x3;
 typedef mat<2, 4, int, highp> highp_imat2x4;
 typedef mat<3, 2, int, highp> highp_imat3x2;
 typedef mat<3, 3, int, highp> highp_imat3x3;
 typedef mat<3, 4, int, highp> highp_imat3x4;
 typedef mat<4, 2, int, highp> highp_imat4x2;
 typedef mat<4, 3, int, highp> highp_imat4x3;
 typedef mat<4, 4, int, highp> highp_imat4x4;

 typedef mat<2, 2, int, defaultp> imat2x2;
 typedef mat<3, 2, int, defaultp> imat3x2;
 typedef mat<4, 2, int, defaultp> imat4x2;
 typedef mat<2, 3, int, defaultp> imat2x3;
 typedef mat<3, 3, int, defaultp> imat3x3;
 typedef mat<4, 3, int, defaultp> imat4x3;
 typedef mat<2, 4, int, defaultp> imat2x4;
 typedef mat<3, 4, int, defaultp> imat3x4;
 typedef mat<4, 4, int, defaultp> imat4x4;


 typedef mat<2, 2, int8, lowp> lowp_i8mat2x2;
 typedef mat<2, 3, int8, lowp> lowp_i8mat2x3;
 typedef mat<2, 4, int8, lowp> lowp_i8mat2x4;
 typedef mat<3, 2, int8, lowp> lowp_i8mat3x2;
 typedef mat<3, 3, int8, lowp> lowp_i8mat3x3;
 typedef mat<3, 4, int8, lowp> lowp_i8mat3x4;
 typedef mat<4, 2, int8, lowp> lowp_i8mat4x2;
 typedef mat<4, 3, int8, lowp> lowp_i8mat4x3;
 typedef mat<4, 4, int8, lowp> lowp_i8mat4x4;

 typedef mat<2, 2, int8, mediump> mediump_i8mat2x2;
 typedef mat<2, 3, int8, mediump> mediump_i8mat2x3;
 typedef mat<2, 4, int8, mediump> mediump_i8mat2x4;
 typedef mat<3, 2, int8, mediump> mediump_i8mat3x2;
 typedef mat<3, 3, int8, mediump> mediump_i8mat3x3;
 typedef mat<3, 4, int8, mediump> mediump_i8mat3x4;
 typedef mat<4, 2, int8, mediump> mediump_i8mat4x2;
 typedef mat<4, 3, int8, mediump> mediump_i8mat4x3;
 typedef mat<4, 4, int8, mediump> mediump_i8mat4x4;

 typedef mat<2, 2, int8, highp> highp_i8mat2x2;
 typedef mat<2, 3, int8, highp> highp_i8mat2x3;
 typedef mat<2, 4, int8, highp> highp_i8mat2x4;
 typedef mat<3, 2, int8, highp> highp_i8mat3x2;
 typedef mat<3, 3, int8, highp> highp_i8mat3x3;
 typedef mat<3, 4, int8, highp> highp_i8mat3x4;
 typedef mat<4, 2, int8, highp> highp_i8mat4x2;
 typedef mat<4, 3, int8, highp> highp_i8mat4x3;
 typedef mat<4, 4, int8, highp> highp_i8mat4x4;

 typedef mat<2, 2, int8, defaultp> i8mat2x2;
 typedef mat<3, 2, int8, defaultp> i8mat3x2;
 typedef mat<4, 2, int8, defaultp> i8mat4x2;
 typedef mat<2, 3, int8, defaultp> i8mat2x3;
 typedef mat<3, 3, int8, defaultp> i8mat3x3;
 typedef mat<4, 3, int8, defaultp> i8mat4x3;
 typedef mat<2, 4, int8, defaultp> i8mat2x4;
 typedef mat<3, 4, int8, defaultp> i8mat3x4;
 typedef mat<4, 4, int8, defaultp> i8mat4x4;


 typedef mat<2, 2, int16, lowp> lowp_i16mat2x2;
 typedef mat<2, 3, int16, lowp> lowp_i16mat2x3;
 typedef mat<2, 4, int16, lowp> lowp_i16mat2x4;
 typedef mat<3, 2, int16, lowp> lowp_i16mat3x2;
 typedef mat<3, 3, int16, lowp> lowp_i16mat3x3;
 typedef mat<3, 4, int16, lowp> lowp_i16mat3x4;
 typedef mat<4, 2, int16, lowp> lowp_i16mat4x2;
 typedef mat<4, 3, int16, lowp> lowp_i16mat4x3;
 typedef mat<4, 4, int16, lowp> lowp_i16mat4x4;

 typedef mat<2, 2, int16, mediump> mediump_i16mat2x2;
 typedef mat<2, 3, int16, mediump> mediump_i16mat2x3;
 typedef mat<2, 4, int16, mediump> mediump_i16mat2x4;
 typedef mat<3, 2, int16, mediump> mediump_i16mat3x2;
 typedef mat<3, 3, int16, mediump> mediump_i16mat3x3;
 typedef mat<3, 4, int16, mediump> mediump_i16mat3x4;
 typedef mat<4, 2, int16, mediump> mediump_i16mat4x2;
 typedef mat<4, 3, int16, mediump> mediump_i16mat4x3;
 typedef mat<4, 4, int16, mediump> mediump_i16mat4x4;

 typedef mat<2, 2, int16, highp> highp_i16mat2x2;
 typedef mat<2, 3, int16, highp> highp_i16mat2x3;
 typedef mat<2, 4, int16, highp> highp_i16mat2x4;
 typedef mat<3, 2, int16, highp> highp_i16mat3x2;
 typedef mat<3, 3, int16, highp> highp_i16mat3x3;
 typedef mat<3, 4, int16, highp> highp_i16mat3x4;
 typedef mat<4, 2, int16, highp> highp_i16mat4x2;
 typedef mat<4, 3, int16, highp> highp_i16mat4x3;
 typedef mat<4, 4, int16, highp> highp_i16mat4x4;

 typedef mat<2, 2, int16, defaultp> i16mat2x2;
 typedef mat<3, 2, int16, defaultp> i16mat3x2;
 typedef mat<4, 2, int16, defaultp> i16mat4x2;
 typedef mat<2, 3, int16, defaultp> i16mat2x3;
 typedef mat<3, 3, int16, defaultp> i16mat3x3;
 typedef mat<4, 3, int16, defaultp> i16mat4x3;
 typedef mat<2, 4, int16, defaultp> i16mat2x4;
 typedef mat<3, 4, int16, defaultp> i16mat3x4;
 typedef mat<4, 4, int16, defaultp> i16mat4x4;


 typedef mat<2, 2, int32, lowp> lowp_i32mat2x2;
 typedef mat<2, 3, int32, lowp> lowp_i32mat2x3;
 typedef mat<2, 4, int32, lowp> lowp_i32mat2x4;
 typedef mat<3, 2, int32, lowp> lowp_i32mat3x2;
 typedef mat<3, 3, int32, lowp> lowp_i32mat3x3;
 typedef mat<3, 4, int32, lowp> lowp_i32mat3x4;
 typedef mat<4, 2, int32, lowp> lowp_i32mat4x2;
 typedef mat<4, 3, int32, lowp> lowp_i32mat4x3;
 typedef mat<4, 4, int32, lowp> lowp_i32mat4x4;

 typedef mat<2, 2, int32, mediump> mediump_i32mat2x2;
 typedef mat<2, 3, int32, mediump> mediump_i32mat2x3;
 typedef mat<2, 4, int32, mediump> mediump_i32mat2x4;
 typedef mat<3, 2, int32, mediump> mediump_i32mat3x2;
 typedef mat<3, 3, int32, mediump> mediump_i32mat3x3;
 typedef mat<3, 4, int32, mediump> mediump_i32mat3x4;
 typedef mat<4, 2, int32, mediump> mediump_i32mat4x2;
 typedef mat<4, 3, int32, mediump> mediump_i32mat4x3;
 typedef mat<4, 4, int32, mediump> mediump_i32mat4x4;

 typedef mat<2, 2, int32, highp> highp_i32mat2x2;
 typedef mat<2, 3, int32, highp> highp_i32mat2x3;
 typedef mat<2, 4, int32, highp> highp_i32mat2x4;
 typedef mat<3, 2, int32, highp> highp_i32mat3x2;
 typedef mat<3, 3, int32, highp> highp_i32mat3x3;
 typedef mat<3, 4, int32, highp> highp_i32mat3x4;
 typedef mat<4, 2, int32, highp> highp_i32mat4x2;
 typedef mat<4, 3, int32, highp> highp_i32mat4x3;
 typedef mat<4, 4, int32, highp> highp_i32mat4x4;

 typedef mat<2, 2, int32, defaultp> i32mat2x2;
 typedef mat<3, 2, int32, defaultp> i32mat3x2;
 typedef mat<4, 2, int32, defaultp> i32mat4x2;
 typedef mat<2, 3, int32, defaultp> i32mat2x3;
 typedef mat<3, 3, int32, defaultp> i32mat3x3;
 typedef mat<4, 3, int32, defaultp> i32mat4x3;
 typedef mat<2, 4, int32, defaultp> i32mat2x4;
 typedef mat<3, 4, int32, defaultp> i32mat3x4;
 typedef mat<4, 4, int32, defaultp> i32mat4x4;


 typedef mat<2, 2, int64, lowp> lowp_i64mat2x2;
 typedef mat<2, 3, int64, lowp> lowp_i64mat2x3;
 typedef mat<2, 4, int64, lowp> lowp_i64mat2x4;
 typedef mat<3, 2, int64, lowp> lowp_i64mat3x2;
 typedef mat<3, 3, int64, lowp> lowp_i64mat3x3;
 typedef mat<3, 4, int64, lowp> lowp_i64mat3x4;
 typedef mat<4, 2, int64, lowp> lowp_i64mat4x2;
 typedef mat<4, 3, int64, lowp> lowp_i64mat4x3;
 typedef mat<4, 4, int64, lowp> lowp_i64mat4x4;

 typedef mat<2, 2, int64, mediump> mediump_i64mat2x2;
 typedef mat<2, 3, int64, mediump> mediump_i64mat2x3;
 typedef mat<2, 4, int64, mediump> mediump_i64mat2x4;
 typedef mat<3, 2, int64, mediump> mediump_i64mat3x2;
 typedef mat<3, 3, int64, mediump> mediump_i64mat3x3;
 typedef mat<3, 4, int64, mediump> mediump_i64mat3x4;
 typedef mat<4, 2, int64, mediump> mediump_i64mat4x2;
 typedef mat<4, 3, int64, mediump> mediump_i64mat4x3;
 typedef mat<4, 4, int64, mediump> mediump_i64mat4x4;

 typedef mat<2, 2, int64, highp> highp_i64mat2x2;
 typedef mat<2, 3, int64, highp> highp_i64mat2x3;
 typedef mat<2, 4, int64, highp> highp_i64mat2x4;
 typedef mat<3, 2, int64, highp> highp_i64mat3x2;
 typedef mat<3, 3, int64, highp> highp_i64mat3x3;
 typedef mat<3, 4, int64, highp> highp_i64mat3x4;
 typedef mat<4, 2, int64, highp> highp_i64mat4x2;
 typedef mat<4, 3, int64, highp> highp_i64mat4x3;
 typedef mat<4, 4, int64, highp> highp_i64mat4x4;

 typedef mat<2, 2, int64, defaultp> i64mat2x2;
 typedef mat<3, 2, int64, defaultp> i64mat3x2;
 typedef mat<4, 2, int64, defaultp> i64mat4x2;
 typedef mat<2, 3, int64, defaultp> i64mat2x3;
 typedef mat<3, 3, int64, defaultp> i64mat3x3;
 typedef mat<4, 3, int64, defaultp> i64mat4x3;
 typedef mat<2, 4, int64, defaultp> i64mat2x4;
 typedef mat<3, 4, int64, defaultp> i64mat3x4;
 typedef mat<4, 4, int64, defaultp> i64mat4x4;




 typedef mat<2, 2, uint, lowp> lowp_umat2x2;
 typedef mat<2, 3, uint, lowp> lowp_umat2x3;
 typedef mat<2, 4, uint, lowp> lowp_umat2x4;
 typedef mat<3, 2, uint, lowp> lowp_umat3x2;
 typedef mat<3, 3, uint, lowp> lowp_umat3x3;
 typedef mat<3, 4, uint, lowp> lowp_umat3x4;
 typedef mat<4, 2, uint, lowp> lowp_umat4x2;
 typedef mat<4, 3, uint, lowp> lowp_umat4x3;
 typedef mat<4, 4, uint, lowp> lowp_umat4x4;

 typedef mat<2, 2, uint, mediump> mediump_umat2x2;
 typedef mat<2, 3, uint, mediump> mediump_umat2x3;
 typedef mat<2, 4, uint, mediump> mediump_umat2x4;
 typedef mat<3, 2, uint, mediump> mediump_umat3x2;
 typedef mat<3, 3, uint, mediump> mediump_umat3x3;
 typedef mat<3, 4, uint, mediump> mediump_umat3x4;
 typedef mat<4, 2, uint, mediump> mediump_umat4x2;
 typedef mat<4, 3, uint, mediump> mediump_umat4x3;
 typedef mat<4, 4, uint, mediump> mediump_umat4x4;

 typedef mat<2, 2, uint, highp> highp_umat2x2;
 typedef mat<2, 3, uint, highp> highp_umat2x3;
 typedef mat<2, 4, uint, highp> highp_umat2x4;
 typedef mat<3, 2, uint, highp> highp_umat3x2;
 typedef mat<3, 3, uint, highp> highp_umat3x3;
 typedef mat<3, 4, uint, highp> highp_umat3x4;
 typedef mat<4, 2, uint, highp> highp_umat4x2;
 typedef mat<4, 3, uint, highp> highp_umat4x3;
 typedef mat<4, 4, uint, highp> highp_umat4x4;

 typedef mat<2, 2, uint, defaultp> umat2x2;
 typedef mat<3, 2, uint, defaultp> umat3x2;
 typedef mat<4, 2, uint, defaultp> umat4x2;
 typedef mat<2, 3, uint, defaultp> umat2x3;
 typedef mat<3, 3, uint, defaultp> umat3x3;
 typedef mat<4, 3, uint, defaultp> umat4x3;
 typedef mat<2, 4, uint, defaultp> umat2x4;
 typedef mat<3, 4, uint, defaultp> umat3x4;
 typedef mat<4, 4, uint, defaultp> umat4x4;


 typedef mat<2, 2, uint8, lowp> lowp_u8mat2x2;
 typedef mat<2, 3, uint8, lowp> lowp_u8mat2x3;
 typedef mat<2, 4, uint8, lowp> lowp_u8mat2x4;
 typedef mat<3, 2, uint8, lowp> lowp_u8mat3x2;
 typedef mat<3, 3, uint8, lowp> lowp_u8mat3x3;
 typedef mat<3, 4, uint8, lowp> lowp_u8mat3x4;
 typedef mat<4, 2, uint8, lowp> lowp_u8mat4x2;
 typedef mat<4, 3, uint8, lowp> lowp_u8mat4x3;
 typedef mat<4, 4, uint8, lowp> lowp_u8mat4x4;

 typedef mat<2, 2, uint8, mediump> mediump_u8mat2x2;
 typedef mat<2, 3, uint8, mediump> mediump_u8mat2x3;
 typedef mat<2, 4, uint8, mediump> mediump_u8mat2x4;
 typedef mat<3, 2, uint8, mediump> mediump_u8mat3x2;
 typedef mat<3, 3, uint8, mediump> mediump_u8mat3x3;
 typedef mat<3, 4, uint8, mediump> mediump_u8mat3x4;
 typedef mat<4, 2, uint8, mediump> mediump_u8mat4x2;
 typedef mat<4, 3, uint8, mediump> mediump_u8mat4x3;
 typedef mat<4, 4, uint8, mediump> mediump_u8mat4x4;

 typedef mat<2, 2, uint8, highp> highp_u8mat2x2;
 typedef mat<2, 3, uint8, highp> highp_u8mat2x3;
 typedef mat<2, 4, uint8, highp> highp_u8mat2x4;
 typedef mat<3, 2, uint8, highp> highp_u8mat3x2;
 typedef mat<3, 3, uint8, highp> highp_u8mat3x3;
 typedef mat<3, 4, uint8, highp> highp_u8mat3x4;
 typedef mat<4, 2, uint8, highp> highp_u8mat4x2;
 typedef mat<4, 3, uint8, highp> highp_u8mat4x3;
 typedef mat<4, 4, uint8, highp> highp_u8mat4x4;

 typedef mat<2, 2, uint8, defaultp> u8mat2x2;
 typedef mat<3, 2, uint8, defaultp> u8mat3x2;
 typedef mat<4, 2, uint8, defaultp> u8mat4x2;
 typedef mat<2, 3, uint8, defaultp> u8mat2x3;
 typedef mat<3, 3, uint8, defaultp> u8mat3x3;
 typedef mat<4, 3, uint8, defaultp> u8mat4x3;
 typedef mat<2, 4, uint8, defaultp> u8mat2x4;
 typedef mat<3, 4, uint8, defaultp> u8mat3x4;
 typedef mat<4, 4, uint8, defaultp> u8mat4x4;


 typedef mat<2, 2, uint16, lowp> lowp_u16mat2x2;
 typedef mat<2, 3, uint16, lowp> lowp_u16mat2x3;
 typedef mat<2, 4, uint16, lowp> lowp_u16mat2x4;
 typedef mat<3, 2, uint16, lowp> lowp_u16mat3x2;
 typedef mat<3, 3, uint16, lowp> lowp_u16mat3x3;
 typedef mat<3, 4, uint16, lowp> lowp_u16mat3x4;
 typedef mat<4, 2, uint16, lowp> lowp_u16mat4x2;
 typedef mat<4, 3, uint16, lowp> lowp_u16mat4x3;
 typedef mat<4, 4, uint16, lowp> lowp_u16mat4x4;

 typedef mat<2, 2, uint16, mediump> mediump_u16mat2x2;
 typedef mat<2, 3, uint16, mediump> mediump_u16mat2x3;
 typedef mat<2, 4, uint16, mediump> mediump_u16mat2x4;
 typedef mat<3, 2, uint16, mediump> mediump_u16mat3x2;
 typedef mat<3, 3, uint16, mediump> mediump_u16mat3x3;
 typedef mat<3, 4, uint16, mediump> mediump_u16mat3x4;
 typedef mat<4, 2, uint16, mediump> mediump_u16mat4x2;
 typedef mat<4, 3, uint16, mediump> mediump_u16mat4x3;
 typedef mat<4, 4, uint16, mediump> mediump_u16mat4x4;

 typedef mat<2, 2, uint16, highp> highp_u16mat2x2;
 typedef mat<2, 3, uint16, highp> highp_u16mat2x3;
 typedef mat<2, 4, uint16, highp> highp_u16mat2x4;
 typedef mat<3, 2, uint16, highp> highp_u16mat3x2;
 typedef mat<3, 3, uint16, highp> highp_u16mat3x3;
 typedef mat<3, 4, uint16, highp> highp_u16mat3x4;
 typedef mat<4, 2, uint16, highp> highp_u16mat4x2;
 typedef mat<4, 3, uint16, highp> highp_u16mat4x3;
 typedef mat<4, 4, uint16, highp> highp_u16mat4x4;

 typedef mat<2, 2, uint16, defaultp> u16mat2x2;
 typedef mat<3, 2, uint16, defaultp> u16mat3x2;
 typedef mat<4, 2, uint16, defaultp> u16mat4x2;
 typedef mat<2, 3, uint16, defaultp> u16mat2x3;
 typedef mat<3, 3, uint16, defaultp> u16mat3x3;
 typedef mat<4, 3, uint16, defaultp> u16mat4x3;
 typedef mat<2, 4, uint16, defaultp> u16mat2x4;
 typedef mat<3, 4, uint16, defaultp> u16mat3x4;
 typedef mat<4, 4, uint16, defaultp> u16mat4x4;


 typedef mat<2, 2, uint32, lowp> lowp_u32mat2x2;
 typedef mat<2, 3, uint32, lowp> lowp_u32mat2x3;
 typedef mat<2, 4, uint32, lowp> lowp_u32mat2x4;
 typedef mat<3, 2, uint32, lowp> lowp_u32mat3x2;
 typedef mat<3, 3, uint32, lowp> lowp_u32mat3x3;
 typedef mat<3, 4, uint32, lowp> lowp_u32mat3x4;
 typedef mat<4, 2, uint32, lowp> lowp_u32mat4x2;
 typedef mat<4, 3, uint32, lowp> lowp_u32mat4x3;
 typedef mat<4, 4, uint32, lowp> lowp_u32mat4x4;

 typedef mat<2, 2, uint32, mediump> mediump_u32mat2x2;
 typedef mat<2, 3, uint32, mediump> mediump_u32mat2x3;
 typedef mat<2, 4, uint32, mediump> mediump_u32mat2x4;
 typedef mat<3, 2, uint32, mediump> mediump_u32mat3x2;
 typedef mat<3, 3, uint32, mediump> mediump_u32mat3x3;
 typedef mat<3, 4, uint32, mediump> mediump_u32mat3x4;
 typedef mat<4, 2, uint32, mediump> mediump_u32mat4x2;
 typedef mat<4, 3, uint32, mediump> mediump_u32mat4x3;
 typedef mat<4, 4, uint32, mediump> mediump_u32mat4x4;

 typedef mat<2, 2, uint32, highp> highp_u32mat2x2;
 typedef mat<2, 3, uint32, highp> highp_u32mat2x3;
 typedef mat<2, 4, uint32, highp> highp_u32mat2x4;
 typedef mat<3, 2, uint32, highp> highp_u32mat3x2;
 typedef mat<3, 3, uint32, highp> highp_u32mat3x3;
 typedef mat<3, 4, uint32, highp> highp_u32mat3x4;
 typedef mat<4, 2, uint32, highp> highp_u32mat4x2;
 typedef mat<4, 3, uint32, highp> highp_u32mat4x3;
 typedef mat<4, 4, uint32, highp> highp_u32mat4x4;

 typedef mat<2, 2, uint32, defaultp> u32mat2x2;
 typedef mat<3, 2, uint32, defaultp> u32mat3x2;
 typedef mat<4, 2, uint32, defaultp> u32mat4x2;
 typedef mat<2, 3, uint32, defaultp> u32mat2x3;
 typedef mat<3, 3, uint32, defaultp> u32mat3x3;
 typedef mat<4, 3, uint32, defaultp> u32mat4x3;
 typedef mat<2, 4, uint32, defaultp> u32mat2x4;
 typedef mat<3, 4, uint32, defaultp> u32mat3x4;
 typedef mat<4, 4, uint32, defaultp> u32mat4x4;


 typedef mat<2, 2, uint64, lowp> lowp_u64mat2x2;
 typedef mat<2, 3, uint64, lowp> lowp_u64mat2x3;
 typedef mat<2, 4, uint64, lowp> lowp_u64mat2x4;
 typedef mat<3, 2, uint64, lowp> lowp_u64mat3x2;
 typedef mat<3, 3, uint64, lowp> lowp_u64mat3x3;
 typedef mat<3, 4, uint64, lowp> lowp_u64mat3x4;
 typedef mat<4, 2, uint64, lowp> lowp_u64mat4x2;
 typedef mat<4, 3, uint64, lowp> lowp_u64mat4x3;
 typedef mat<4, 4, uint64, lowp> lowp_u64mat4x4;

 typedef mat<2, 2, uint64, mediump> mediump_u64mat2x2;
 typedef mat<2, 3, uint64, mediump> mediump_u64mat2x3;
 typedef mat<2, 4, uint64, mediump> mediump_u64mat2x4;
 typedef mat<3, 2, uint64, mediump> mediump_u64mat3x2;
 typedef mat<3, 3, uint64, mediump> mediump_u64mat3x3;
 typedef mat<3, 4, uint64, mediump> mediump_u64mat3x4;
 typedef mat<4, 2, uint64, mediump> mediump_u64mat4x2;
 typedef mat<4, 3, uint64, mediump> mediump_u64mat4x3;
 typedef mat<4, 4, uint64, mediump> mediump_u64mat4x4;

 typedef mat<2, 2, uint64, highp> highp_u64mat2x2;
 typedef mat<2, 3, uint64, highp> highp_u64mat2x3;
 typedef mat<2, 4, uint64, highp> highp_u64mat2x4;
 typedef mat<3, 2, uint64, highp> highp_u64mat3x2;
 typedef mat<3, 3, uint64, highp> highp_u64mat3x3;
 typedef mat<3, 4, uint64, highp> highp_u64mat3x4;
 typedef mat<4, 2, uint64, highp> highp_u64mat4x2;
 typedef mat<4, 3, uint64, highp> highp_u64mat4x3;
 typedef mat<4, 4, uint64, highp> highp_u64mat4x4;

 typedef mat<2, 2, uint64, defaultp> u64mat2x2;
 typedef mat<3, 2, uint64, defaultp> u64mat3x2;
 typedef mat<4, 2, uint64, defaultp> u64mat4x2;
 typedef mat<2, 3, uint64, defaultp> u64mat2x3;
 typedef mat<3, 3, uint64, defaultp> u64mat3x3;
 typedef mat<4, 3, uint64, defaultp> u64mat4x3;
 typedef mat<2, 4, uint64, defaultp> u64mat2x4;
 typedef mat<3, 4, uint64, defaultp> u64mat3x4;
 typedef mat<4, 4, uint64, defaultp> u64mat4x4;



 typedef qua<float, lowp> lowp_quat;
 typedef qua<float, mediump> mediump_quat;
 typedef qua<float, highp> highp_quat;
 typedef qua<float, defaultp> quat;

 typedef qua<float, lowp> lowp_fquat;
 typedef qua<float, mediump> mediump_fquat;
 typedef qua<float, highp> highp_fquat;
 typedef qua<float, defaultp> fquat;

 typedef qua<f32, lowp> lowp_f32quat;
 typedef qua<f32, mediump> mediump_f32quat;
 typedef qua<f32, highp> highp_f32quat;
 typedef qua<f32, defaultp> f32quat;

 typedef qua<double, lowp> lowp_dquat;
 typedef qua<double, mediump> mediump_dquat;
 typedef qua<double, highp> highp_dquat;
 typedef qua<double, defaultp> dquat;

 typedef qua<f64, lowp> lowp_f64quat;
 typedef qua<f64, mediump> mediump_f64quat;
 typedef qua<f64, highp> highp_f64quat;
 typedef qua<f64, defaultp> f64quat;
}
# 115 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.hpp" 1



       
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<2, T, Q>
 {


  typedef T value_type;
  typedef vec<2, T, Q> type;
  typedef vec<2, bool, Q> bool_type;
# 68 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.hpp"
   union {T x, r, s;};
   union {T y, g, t;};
# 89 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.hpp"
  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length(){return 2;}

  __attribute__((device)) __attribute__((host)) constexpr T& operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr T const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr vec() = default;
  __attribute__((device)) __attribute__((host)) constexpr vec(vec const& v) = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, T, P> const& v);



  __attribute__((device)) __attribute__((host)) constexpr explicit vec(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr vec(T x, T y);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr explicit vec(vec<1, U, P> const& v);


  template<typename A, typename B>
  __attribute__((device)) __attribute__((host)) constexpr vec(A x, B y);
  template<typename A, typename B>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, Q> const& x, B y);
  template<typename A, typename B>
  __attribute__((device)) __attribute__((host)) constexpr vec(A x, vec<1, B, Q> const& y);
  template<typename A, typename B>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);




  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, U, P> const& v);
# 146 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.hpp"
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator+=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator-=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator*=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator/=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);



  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator--(int);



  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator%=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator&=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator|=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator^=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator<<=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator>>=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 1


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/./compute_vector_relational.hpp" 1
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/./setup.hpp" 1
# 5 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/./compute_vector_relational.hpp" 2


namespace glm{
namespace detail
{
 template <typename T, bool isFloat>
 struct compute_equal
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static bool call(T a, T b)
  {
   return a == b;
  }
 };
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/./compute_vector_relational.hpp"
}
}
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 2

namespace glm
{
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
  : x(v.x), y(v.y)
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(T scalar)
  : x(scalar), y(scalar)
 {}

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(T _x, T _y)
  : x(_x), y(_y)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(A _x, B _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
 {
  
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 3 4
 ((
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
 i >= 0 && i < this->length()
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
 "i >= 0 && i < this->length()"
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl", 106, __PRETTY_FUNCTION__))
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
                                     ;
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
 {
  
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 3 4
 ((
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
 i >= 0 && i < this->length()
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
 "i >= 0 && i < this->length()"
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl", 120, __PRETTY_FUNCTION__))
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
                                     ;
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }
# 143 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.inl"
 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> vec<2, T, Q>::operator++(int)
 {
  vec<2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> vec<2, T, Q>::operator--(int)
 {
  vec<2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   -v.x,
   -v.y);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x + scalar,
   v.y + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar + v.x,
   scalar + v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x - scalar,
   v.y - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar - v.x,
   scalar - v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x * scalar,
   v.y * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar * v.x,
   scalar * v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x / scalar,
   v.y / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar / v.x,
   scalar / v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x % scalar,
   v.y % scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar % v.x,
   scalar % v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x & scalar,
   v.y & scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar & v.x,
   scalar & v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x | scalar,
   v.y | scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar | v.x,
   scalar | v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x << scalar,
   v.y << scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar << v.x,
   scalar << v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   ~v.x,
   ~v.y);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 402 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec2.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool2.hpp" 2

namespace glm
{






 typedef vec<2, bool, defaultp> bvec2;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool2_precision.hpp" 1



       


namespace glm
{







 typedef vec<2, bool, highp> highp_bvec2;





 typedef vec<2, bool, mediump> mediump_bvec2;





 typedef vec<2, bool, lowp> lowp_bvec2;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_float2.hpp" 1



       


namespace glm
{






 typedef vec<2, float, defaultp> vec2;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_float2_precision.hpp" 1



       


namespace glm
{







 typedef vec<2, float, highp> highp_vec2;





 typedef vec<2, float, mediump> mediump_vec2;





 typedef vec<2, float, lowp> lowp_vec2;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double2.hpp" 1



       


namespace glm
{






 typedef vec<2, double, defaultp> dvec2;


}
# 10 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double2_precision.hpp" 1



       


namespace glm
{







 typedef vec<2, double, highp> highp_dvec2;





 typedef vec<2, double, mediump> mediump_dvec2;





 typedef vec<2, double, lowp> lowp_dvec2;


}
# 11 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int2.hpp" 1



       


namespace glm
{






 typedef vec<2, int, defaultp> ivec2;


}
# 12 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int2_sized.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int2_sized.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/scalar_int_sized.hpp" 1
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/scalar_int_sized.hpp"
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/../detail/setup.hpp" 1
# 16 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/scalar_int_sized.hpp" 2





namespace glm{
namespace detail
{

  typedef std::int8_t int8;
  typedef std::int16_t int16;
  typedef std::int32_t int32;






 template<>
 struct is_int<int8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::int8 int8;


 typedef detail::int16 int16;


 typedef detail::int32 int32;


 typedef detail::int64 int64;


}
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int2_sized.hpp" 2





namespace glm
{






 typedef vec<2, int8, defaultp> i8vec2;




 typedef vec<2, int16, defaultp> i16vec2;




 typedef vec<2, int32, defaultp> i32vec2;




 typedef vec<2, int64, defaultp> i64vec2;


}
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint2.hpp" 1



       


namespace glm
{






 typedef vec<2, unsigned int, defaultp> uvec2;


}
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint2_sized.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint2_sized.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/scalar_uint_sized.hpp" 1
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/scalar_uint_sized.hpp"
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/../detail/setup.hpp" 1
# 16 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../ext/scalar_uint_sized.hpp" 2





namespace glm{
namespace detail
{

  typedef std::uint8_t uint8;
  typedef std::uint16_t uint16;
  typedef std::uint32_t uint32;






 template<>
 struct is_int<uint8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::uint8 uint8;


 typedef detail::uint16 uint16;


 typedef detail::uint32 uint32;


 typedef detail::uint64 uint64;


}
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint2_sized.hpp" 2





namespace glm
{






 typedef vec<2, uint8, defaultp> u8vec2;




 typedef vec<2, uint16, defaultp> u16vec2;




 typedef vec<2, uint32, defaultp> u32vec2;




 typedef vec<2, uint64, defaultp> u64vec2;


}
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec2.hpp" 2
# 117 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.hpp" 1



       
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<3, T, Q>
 {


  typedef T value_type;
  typedef vec<3, T, Q> type;
  typedef vec<3, bool, Q> bool_type;
# 71 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 93 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.hpp"
  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length(){return 3;}

  __attribute__((device)) __attribute__((host)) constexpr T & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr T const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr vec() = default;
  __attribute__((device)) __attribute__((host)) constexpr vec(vec const& v) = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<3, T, P> const& v);



  __attribute__((device)) __attribute__((host)) constexpr explicit vec(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr vec(T a, T b, T c);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(X x, Y y, Z z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);




  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, B _z);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(A _x, vec<2, B, P> const& _yz);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);

  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<3, U, P> const& v);
# 179 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.hpp"
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q>& operator=(vec<3, T, Q> const& v) = default;

  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator+=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator-=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator*=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator/=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);



  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator--(int);



  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator%=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator&=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator|=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator^=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator<<=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator>>=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 1




namespace glm
{
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
  : x(_x), y(_y), z(_z)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
 {
  
# 170 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 3 4
 ((
# 170 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
 i >= 0 && i < this->length()
# 170 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 170 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
 "i >= 0 && i < this->length()"
# 170 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl", 170, __PRETTY_FUNCTION__))
# 170 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
                                     ;
  switch(i)
  {
  default:
   case 0:
  return x;
   case 1:
  return y;
   case 2:
  return z;
  }
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
 {
  
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 3 4
 ((
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
 i >= 0 && i < this->length()
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
 "i >= 0 && i < this->length()"
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl", 186, __PRETTY_FUNCTION__))
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
                                     ;
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  }
 }
# 212 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.inl"
 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> vec<3, T, Q>::operator++(int)
 {
  vec<3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> vec<3, T, Q>::operator--(int)
 {
  vec<3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   -v.x,
   -v.y,
   -v.z);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 435 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec3.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool3.hpp" 2

namespace glm
{






 typedef vec<3, bool, defaultp> bvec3;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool3_precision.hpp" 1



       


namespace glm
{







 typedef vec<3, bool, highp> highp_bvec3;





 typedef vec<3, bool, mediump> mediump_bvec3;





 typedef vec<3, bool, lowp> lowp_bvec3;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_float3.hpp" 1



       


namespace glm
{






 typedef vec<3, float, defaultp> vec3;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_float3_precision.hpp" 1



       


namespace glm
{







 typedef vec<3, float, highp> highp_vec3;





 typedef vec<3, float, mediump> mediump_vec3;





 typedef vec<3, float, lowp> lowp_vec3;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double3.hpp" 1



       


namespace glm
{






 typedef vec<3, double, defaultp> dvec3;


}
# 10 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double3_precision.hpp" 1



       


namespace glm
{
# 17 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double3_precision.hpp"
 typedef vec<3, double, highp> highp_dvec3;






 typedef vec<3, double, mediump> mediump_dvec3;






 typedef vec<3, double, lowp> lowp_dvec3;


}
# 11 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int3.hpp" 1



       


namespace glm
{






 typedef vec<3, int, defaultp> ivec3;


}
# 12 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int3_sized.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int3_sized.hpp"
       
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int3_sized.hpp"
namespace glm
{






 typedef vec<3, int8, defaultp> i8vec3;




 typedef vec<3, int16, defaultp> i16vec3;




 typedef vec<3, int32, defaultp> i32vec3;




 typedef vec<3, int64, defaultp> i64vec3;


}
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint3.hpp" 1



       


namespace glm
{






 typedef vec<3, unsigned int, defaultp> uvec3;


}
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint3_sized.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint3_sized.hpp"
       
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint3_sized.hpp"
namespace glm
{






 typedef vec<3, uint8, defaultp> u8vec3;




 typedef vec<3, uint16, defaultp> u16vec3;




 typedef vec<3, uint32, defaultp> u32vec3;




 typedef vec<3, uint64, defaultp> u64vec3;


}
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec3.hpp" 2
# 118 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.hpp" 1



       
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<4, T, Q>
 {


  typedef T value_type;
  typedef vec<4, T, Q> type;
  typedef vec<4, bool, Q> bool_type;
# 68 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 90 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.hpp"
  typedef length_t length_type;


  __attribute__((device)) __attribute__((host)) static constexpr length_type length(){return 4;}

  __attribute__((device)) __attribute__((host)) constexpr T & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr T const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr vec() = default;
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<4, T, Q> const& v) = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<4, T, P> const& v);



  __attribute__((device)) __attribute__((host)) constexpr explicit vec(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr vec(T x, T y, T z, T w);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _Y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);




  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<3, A, P> const& _xyz, B _w);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(A _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);


  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<4, U, P> const& v);
# 252 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.hpp"
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;

  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator+=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator-=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator*=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator/=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);



  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator--(int);



  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator%=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator&=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator|=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator^=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator<<=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator>>=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T const & scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 1




namespace glm{
namespace detail
{
 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_add
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_sub
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mul
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_div
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mod
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}
# 146 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<4, T, P> const& v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
  : x(_x), y(_y), z(_z), w(_w)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
  , w(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
  , w(static_cast<T>(v.w))
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
 {
  
# 479 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 3 4
 ((
# 479 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
 i >= 0 && i < this->length()
# 479 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 479 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
 "i >= 0 && i < this->length()"
# 479 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl", 479, __PRETTY_FUNCTION__))
# 479 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
                                     ;
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
 {
  
# 497 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 3 4
 ((
# 497 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
 i >= 0 && i < this->length()
# 497 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 497 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
 "i >= 0 && i < this->length()"
# 497 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl", 497, __PRETTY_FUNCTION__))
# 497 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
                                     ;
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }
# 526 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.inl"
 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> vec<4, T, Q>::operator++(int)
 {
  vec<4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> vec<4, T, Q>::operator--(int)
 {
  vec<4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(0) -= v;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) += v1;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) -= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) -= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) -= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) *= v1;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T const & scalar)
 {
  return vec<4, T, Q>(v) /= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) /= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) /= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) %= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2.x;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) %= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar.x) %= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) &= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) &= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) &= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) |= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2.x;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) |= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) |= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) ^= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2.x;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) ^= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) ^= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) <<= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2.x;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) <<= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) <<= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) >>= scalar;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2.x;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) >>= v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) >>= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v)
 {
  return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 508 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_vec4.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool4.hpp" 2

namespace glm
{






 typedef vec<4, bool, defaultp> bvec4;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_bool4_precision.hpp" 1



       


namespace glm
{







 typedef vec<4, bool, highp> highp_bvec4;





 typedef vec<4, bool, mediump> mediump_bvec4;





 typedef vec<4, bool, lowp> lowp_bvec4;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_float4.hpp" 1



       


namespace glm
{






 typedef vec<4, float, defaultp> vec4;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_float4_precision.hpp" 1



       


namespace glm
{







 typedef vec<4, float, highp> highp_vec4;





 typedef vec<4, float, mediump> mediump_vec4;





 typedef vec<4, float, lowp> lowp_vec4;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double4.hpp" 1



       


namespace glm
{






 typedef vec<4, double, defaultp> dvec4;


}
# 10 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double4_precision.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/setup.hpp" 1
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double4_precision.hpp" 2


namespace glm
{
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_double4_precision.hpp"
 typedef vec<4, double, highp> highp_dvec4;






 typedef vec<4, double, mediump> mediump_dvec4;






 typedef vec<4, double, lowp> lowp_dvec4;


}
# 11 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int4.hpp" 1



       


namespace glm
{






 typedef vec<4, int, defaultp> ivec4;


}
# 12 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int4_sized.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int4_sized.hpp"
       
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_int4_sized.hpp"
namespace glm
{






 typedef vec<4, int8, defaultp> i8vec4;




 typedef vec<4, int16, defaultp> i16vec4;




 typedef vec<4, int32, defaultp> i32vec4;




 typedef vec<4, int64, defaultp> i64vec4;


}
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint4.hpp" 1



       


namespace glm
{






 typedef vec<4, unsigned int, defaultp> uvec4;


}
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint4_sized.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint4_sized.hpp"
       
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/vector_uint4_sized.hpp"
namespace glm
{






 typedef vec<4, uint8, defaultp> u8vec4;




 typedef vec<4, uint16, defaultp> u16vec4;




 typedef vec<4, uint32, defaultp> u32vec4;




 typedef vec<4, uint64, defaultp> u64vec4;


}
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/vec4.hpp" 2
# 119 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/mat2x2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/matrix_double2x2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.hpp" 1



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 2, T, Q> type;
  typedef mat<2, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 2; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T const& x1, T const& y1,
   T const& x2, T const& y2);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v1,
   col_type const& v2);



  template<typename U, typename V, typename M, typename N>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   U const& x1, V const& y1,
   M const& x2, N const& y2);

  template<typename U, typename V>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<2, U, Q> const& v1,
   vec<2, V, Q> const& v2);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator/=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);



  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator++ ();
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> & operator-- ();
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 1
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 1
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp"
       



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/setup.hpp" 1
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2




# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double2x3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 3, T, Q> type;
  typedef mat<3, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 2; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template<typename U, typename V>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<3, U, Q> const& v1,
   vec<3, V, Q> const& v2);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator/=(U s);



  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator++ ();
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> & operator-- ();
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 1
namespace glm
{
# 19 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)

   : value{m.value[0], m.value[1]}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

  : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i)
 {
  
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 3 4
 ((
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
 i < this->length()
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
 "i < this->length()"
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl", 222, __PRETTY_FUNCTION__))
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const
 {
  
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 3 4
 ((
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
 i < this->length()
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
 "i < this->length()"
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl", 229, __PRETTY_FUNCTION__))
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
 {
  mat<2, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
 {
  mat<2, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 3, T, Q>::col_type operator*
 (
  mat<2, 3, T, Q> const& m,
  typename mat<2, 3, T, Q>::row_type const& v)
 {
  return typename mat<2, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 3, T, Q>::row_type operator*
 (
  typename mat<2, 3, T, Q>::col_type const& v,
  mat<2, 3, T, Q> const& m)
 {
  return typename mat<2, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 159 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x3.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double2x3.hpp" 2

namespace glm
{






 typedef mat<2, 3, double, defaultp> dmat2x3;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double2x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 3, double, lowp> lowp_dmat2x3;





 typedef mat<2, 3, double, mediump> mediump_dmat2x3;





 typedef mat<2, 3, double, highp> highp_dmat2x3;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float2x3.hpp" 1



       


namespace glm
{






 typedef mat<2, 3, float, defaultp> mat2x3;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float2x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 3, float, lowp> lowp_mat2x3;





 typedef mat<2, 3, float, mediump> mediump_mat2x3;





 typedef mat<2, 3, float, highp> highp_mat2x3;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x3.hpp" 2
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double2x4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 4, T, Q> type;
  typedef mat<4, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 2; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template<typename U, typename V>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<4, U, Q> const& v1,
   vec<4, V, Q> const& v2);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator/=(U s);



  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator++ ();
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> & operator-- ();
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 1
namespace glm
{
# 19 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)

   : value{m[0], m[1]}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )

   : value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i)
 {
  
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 3 4
 ((
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
 i < this->length()
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
 "i < this->length()"
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl", 224, __PRETTY_FUNCTION__))
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const
 {
  
# 231 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 3 4
 ((
# 231 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
 i < this->length()
# 231 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 231 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
 "i < this->length()"
# 231 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl", 231, __PRETTY_FUNCTION__))
# 231 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
 {
  mat<2, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
 {
  mat<2, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
 {
  return typename mat<2, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
 {
  return typename mat<2, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 161 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat2x4.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double2x4.hpp" 2

namespace glm
{






 typedef mat<2, 4, double, defaultp> dmat2x4;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double2x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 4, double, lowp> lowp_dmat2x4;





 typedef mat<2, 4, double, mediump> mediump_dmat2x4;





 typedef mat<2, 4, double, highp> highp_dmat2x4;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float2x4.hpp" 1



       


namespace glm
{






 typedef mat<2, 4, float, defaultp> mat2x4;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float2x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 4, float, lowp> lowp_mat2x4;





 typedef mat<2, 4, float, mediump> mediump_mat2x4;





 typedef mat<2, 4, float, highp> highp_mat2x4;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat2x4.hpp" 2
# 24 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 2, T, Q> type;
  typedef mat<2, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 3; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator/=(U s);



  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator++ ();
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> & operator-- ();
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 1
namespace glm
{
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i)
 {
  
# 241 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 3 4
 ((
# 241 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
 i < this->length()
# 241 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 241 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
 "i < this->length()"
# 241 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl", 241, __PRETTY_FUNCTION__))
# 241 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const
 {
  
# 248 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 3 4
 ((
# 248 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
 i < this->length()
# 248 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 248 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
 "i < this->length()"
# 248 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl", 248, __PRETTY_FUNCTION__))
# 248 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
 {
  mat<3, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
 {
  mat<3, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
 {
  return typename mat<3, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
 {
  return typename mat<3, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 167 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x2.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x2.hpp" 2

namespace glm
{






 typedef mat<3, 2, double, defaultp> dmat3x2;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 2, double, lowp> lowp_dmat3x2;





 typedef mat<3, 2, double, mediump> mediump_dmat3x2;





 typedef mat<3, 2, double, highp> highp_dmat3x2;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float3x2.hpp" 1



       


namespace glm
{






 typedef mat<3, 2, float, defaultp> mat3x2;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float3x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 2, float, lowp> lowp_mat3x2;





 typedef mat<3, 2, float, mediump> mediump_mat3x2;





 typedef mat<3, 2, float, highp> highp_mat3x2;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x2.hpp" 2
# 25 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.hpp" 1



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 3, T, Q> type;
  typedef mat<3, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 3; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template<typename V1, typename V2, typename V3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator/=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);



  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 1


namespace glm
{
# 22 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)

   : value{col_type(v1), col_type(v2), col_type(v3)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i)
 {
  
# 243 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 3 4
 ((
# 243 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
 i < this->length()
# 243 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 243 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
 "i < this->length()"
# 243 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl", 243, __PRETTY_FUNCTION__))
# 243 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const
 {
  
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 3 4
 ((
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
 i < this->length()
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
 "i < this->length()"
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl", 250, __PRETTY_FUNCTION__))
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
 {
  mat<3, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
 {
  mat<3, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return typename mat<3, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return typename mat<3, 3, T, Q>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  mat<3, 3, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 184 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x3.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x3.hpp" 2

namespace glm
{






 typedef mat<3, 3, double, defaultp> dmat3x3;




 typedef mat<3, 3, double, defaultp> dmat3;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 3, double, lowp> lowp_dmat3;





 typedef mat<3, 3, double, mediump> mediump_dmat3;





 typedef mat<3, 3, double, highp> highp_dmat3;





 typedef mat<3, 3, double, lowp> lowp_dmat3x3;





 typedef mat<3, 3, double, mediump> mediump_dmat3x3;





 typedef mat<3, 3, double, highp> highp_dmat3x3;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float3x3.hpp" 1



       


namespace glm
{






 typedef mat<3, 3, float, defaultp> mat3x3;




 typedef mat<3, 3, float, defaultp> mat3;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float3x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 3, float, lowp> lowp_mat3;





 typedef mat<3, 3, float, mediump> mediump_mat3;





 typedef mat<3, 3, float, highp> highp_mat3;





 typedef mat<3, 3, float, lowp> lowp_mat3x3;





 typedef mat<3, 3, float, mediump> mediump_mat3x3;





 typedef mat<3, 3, float, highp> highp_mat3x3;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x3.hpp" 2
# 26 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 4, T, Q> type;
  typedef mat<4, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 3; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template<typename V1, typename V2, typename V3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator/=(U s);



  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 1
namespace glm
{
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0, typename W0,
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat
 (
  X0 x0, Y0 y0, Z0 z0, W0 w0,
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i)
 {
  
# 247 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 3 4
 ((
# 247 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
 i < this->length()
# 247 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 247 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
 "i < this->length()"
# 247 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl", 247, __PRETTY_FUNCTION__))
# 247 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const
 {
  
# 254 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 3 4
 ((
# 254 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
 i < this->length()
# 254 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 254 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
 "i < this->length()"
# 254 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl", 254, __PRETTY_FUNCTION__))
# 254 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
 {
  mat<3, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
 {
  mat<3, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 4, T, Q>::col_type operator*
 (
  mat<3, 4, T, Q> const& m,
  typename mat<3, 4, T, Q>::row_type const& v
 )
 {
  return typename mat<3, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<3, 4, T, Q>::row_type operator*
 (
  typename mat<3, 4, T, Q>::col_type const& v,
  mat<3, 4, T, Q> const& m
 )
 {
  return typename mat<3, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 166 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat3x4.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x4.hpp" 2

namespace glm
{






 typedef mat<3, 4, double, defaultp> dmat3x4;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double3x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 4, double, lowp> lowp_dmat3x4;





 typedef mat<3, 4, double, mediump> mediump_dmat3x4;





 typedef mat<3, 4, double, highp> highp_dmat3x4;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float3x4.hpp" 1



       


namespace glm
{






 typedef mat<3, 4, float, defaultp> mat3x4;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float3x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<3, 4, float, lowp> lowp_mat3x4;





 typedef mat<3, 4, float, mediump> mediump_mat3x4;





 typedef mat<3, 4, float, highp> highp_mat3x4;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat3x4.hpp" 2
# 27 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x2.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 2, T, Q> type;
  typedef mat<2, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 4; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T scalar);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X0, typename Y0,
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X0 x0, Y0 y0,
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3, typename V4>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3,
   vec<2, V4, Q> const& v4);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator/=(U s);



  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator++ ();
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> & operator-- ();
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 1
namespace glm
{
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2, typename V3>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i)
 {
  
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 3 4
 ((
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
 i < this->length()
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
 "i < this->length()"
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl", 260, __PRETTY_FUNCTION__))
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const
 {
  
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 3 4
 ((
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
 i < this->length()
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
 "i < this->length()"
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl", 267, __PRETTY_FUNCTION__))
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
 {
  mat<4, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
 {
  mat<4, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
 {
  return typename mat<4, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
 {
  return typename mat<4, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x2.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x2.hpp" 2

namespace glm
{






 typedef mat<4, 2, double, defaultp> dmat4x2;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 2, double, lowp> lowp_dmat4x2;





 typedef mat<4, 2, double, mediump> mediump_dmat4x2;





 typedef mat<4, 2, double, highp> highp_dmat4x2;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float4x2.hpp" 1



       


namespace glm
{






 typedef mat<4, 2, float, defaultp> mat4x2;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float4x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 2, float, lowp> lowp_mat4x2;





 typedef mat<4, 2, float, mediump> mediump_mat4x2;





 typedef mat<4, 2, float, highp> highp_mat4x2;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x2.hpp" 2
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x3.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.hpp" 1



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 3, T, Q> type;
  typedef mat<3, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length() { return 4; }

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T const& x0, T const& y0, T const& z0,
   T const& x1, T const& y1, T const& z1,
   T const& x2, T const& y2, T const& z2,
   T const& x3, T const& y3, T const& z3);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1,
   X2 const& x2, Y2 const& y2, Z2 const& z2,
   X3 const& x3, Y3 const& y3, Z3 const& z3,
   X4 const& x4, Y4 const& y4, Z4 const& z4);

  template<typename V1, typename V2, typename V3, typename V4>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3,
   vec<3, V4, Q> const& v4);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> & operator/=(U s);



  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q>& operator++();
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q>& operator--();
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator*(T const& s, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 3, T, Q> operator/(T const& s, mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 1
namespace glm
{
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(T const& s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0,
  T const& x1, T const& y1, T const& z1,
  T const& x2, T const& y2, T const& z2,
  T const& x3, T const& y3, T const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0,
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat
 (
  X0 const& x0, Y0 const& y0, Z0 const& z0,
  X1 const& x1, Y1 const& y1, Z1 const& z1,
  X2 const& x2, Y2 const& y2, Z2 const& z2,
  X3 const& x3, Y3 const& y3, Z3 const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i)
 {
  
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 3 4
 ((
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
 i < this->length()
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
 "i < this->length()"
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl", 260, __PRETTY_FUNCTION__))
# 260 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const
 {
  
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 3 4
 ((
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
 i < this->length()
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
 "i < this->length()"
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl", 267, __PRETTY_FUNCTION__))
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
 {
  mat<4, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
 {
  mat<4, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T const& s)
 {
  return mat<4, 3, T, Q>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T const& s)
 {
  return mat<4, 3, T, Q>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T const& s)
 {
  return mat<4, 3, T, Q>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator*(T const& s, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 3, T, Q>::col_type operator*
 (
  mat<4, 3, T, Q> const& m,
  typename mat<4, 3, T, Q>::row_type const& v)
 {
  return typename mat<4, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 3, T, Q>::row_type operator*
 (
  typename mat<4, 3, T, Q>::col_type const& v,
  mat<4, 3, T, Q> const& m)
 {
  return typename mat<4, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T const& s)
 {
  return mat<4, 3, T, Q>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 3, T, Q> operator/(T const& s, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x3.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x3.hpp" 2

namespace glm
{






 typedef mat<4, 3, double, defaultp> dmat4x3;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 3, double, lowp> lowp_dmat4x3;





 typedef mat<4, 3, double, mediump> mediump_dmat4x3;





 typedef mat<4, 3, double, highp> highp_dmat4x3;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float4x3.hpp" 1



       


namespace glm
{






 typedef mat<4, 3, float, defaultp> mat4x3;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x3.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float4x3_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 3, float, lowp> lowp_mat4x3;





 typedef mat<4, 3, float, mediump> mediump_mat4x3;





 typedef mat<4, 3, float, highp> highp_mat4x3;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x3.hpp" 2
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x4.hpp" 1



       
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.hpp" 1



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 4, T, Q> type;
  typedef mat<4, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length(){return 4;}

  __attribute__((device)) __attribute__((host)) col_type & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr col_type const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr mat() = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, T, P> const& m);

  __attribute__((device)) __attribute__((host)) explicit constexpr mat(T const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   T const& x0, T const& y0, T const& z0, T const& w0,
   T const& x1, T const& y1, T const& z1, T const& w1,
   T const& x2, T const& y2, T const& z2, T const& w2,
   T const& x3, T const& y3, T const& z3, T const& w3);
  __attribute__((device)) __attribute__((host)) constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
   X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
   X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
   X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

  template<typename V1, typename V2, typename V3, typename V4>
  __attribute__((device)) __attribute__((host)) constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3,
   vec<4, V4, Q> const& v4);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 4, U, P> const& m);

  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 3, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<2, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 2, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<3, 4, T, Q> const& x);
  __attribute__((device)) __attribute__((host)) constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator+=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator-=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator/=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);



  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator+(T const& s, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator-(T const& s, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator*(T const& s, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator/(T const& s, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 1


namespace glm
{
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(T const& s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0, T const& w0,
  T const& x1, T const& y1, T const& z1, T const& w1,
  T const& x2, T const& y2, T const& z2, T const& w2,
  T const& x3, T const& y3, T const& z3, T const& w3
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2),
    col_type(x3, y3, z3, w3)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
  X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
  X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
  X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
 )

   : value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}

 {
  static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
  static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
  static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
  static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

  static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
  static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
  static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
  static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

  static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
  static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
  static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
  static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");







 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {
  static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");







 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}

 {






 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i)
 {
  
# 291 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 3 4
 ((
# 291 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 i < this->length()
# 291 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 291 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 "i < this->length()"
# 291 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl", 291, __PRETTY_FUNCTION__))
# 291 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const
 {
  
# 298 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 3 4
 ((
# 298 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 i < this->length()
# 298 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 298 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 "i < this->length()"
# 298 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl", 298, __PRETTY_FUNCTION__))
# 298 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
 {
  mat<4, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
 {
  mat<4, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T const& s)
 {
  return mat<4, 4, T, Q>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator+(T const& s, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T const& s)
 {
  return mat<4, 4, T, Q>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator-(T const& s, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   s - m[0],
   s - m[1],
   s - m[2],
   s - m[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T const & s)
 {
  return mat<4, 4, T, Q>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator*(T const& s, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 4, T, Q>::col_type operator*
 (
  mat<4, 4, T, Q> const& m,
  typename mat<4, 4, T, Q>::row_type const& v
 )
 {
# 561 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
  typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
  typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
  typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
  typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
  typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
  typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
  typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
  typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
  typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
  typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
  typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 581 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 4, T, Q>::row_type operator*
 (
  typename mat<4, 4, T, Q>::col_type const& v,
  mat<4, 4, T, Q> const& m
 )
 {
  return typename mat<4, 4, T, Q>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
  typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
  typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
  typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

  typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
  typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
  typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
  typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

  mat<4, 4, T, Q> Result;
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T const& s)
 {
  return mat<4, 4, T, Q>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator/(T const& s, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  mat<4, 4, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 189 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/../detail/type_mat4x4.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x4.hpp" 2

namespace glm
{






 typedef mat<4, 4, double, defaultp> dmat4x4;




 typedef mat<4, 4, double, defaultp> dmat4;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_double4x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 4, double, lowp> lowp_dmat4;





 typedef mat<4, 4, double, mediump> mediump_dmat4;





 typedef mat<4, 4, double, highp> highp_dmat4;





 typedef mat<4, 4, double, lowp> lowp_dmat4x4;





 typedef mat<4, 4, double, mediump> mediump_dmat4x4;





 typedef mat<4, 4, double, highp> highp_dmat4x4;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float4x4.hpp" 1



       


namespace glm
{






 typedef mat<4, 4, float, defaultp> mat4x4;




 typedef mat<4, 4, float, defaultp> mat4;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x4.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/.././ext/matrix_float4x4_precision.hpp" 1



       


namespace glm
{







 typedef mat<4, 4, float, lowp> lowp_mat4;





 typedef mat<4, 4, float, mediump> mediump_mat4;





 typedef mat<4, 4, float, highp> highp_mat4;





 typedef mat<4, 4, float, lowp> lowp_mat4x4;





 typedef mat<4, 4, float, mediump> mediump_mat4x4;





 typedef mat<4, 4, float, highp> highp_mat4x4;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../mat4x4.hpp" 2
# 30 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2

namespace glm {
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q>
 struct outerProduct_trait{};

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 2, T, Q>
 {
  typedef mat<2, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 3, T, Q>
 {
  typedef mat<3, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 4, T, Q>
 {
  typedef mat<4, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 2, T, Q>
 {
  typedef mat<2, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 3, T, Q>
 {
  typedef mat<3, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 4, T, Q>
 {
  typedef mat<4, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 2, T, Q>
 {
  typedef mat<2, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 3, T, Q>
 {
  typedef mat<3, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 4, T, Q>
 {
  typedef mat<4, 4, T, Q> type;
 };
}
# 105 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 119 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);
# 131 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);
# 143 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T determinant(mat<C, R, T, Q> const& m);
# 155 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/func_matrix.inl" 1
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp" 1
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
       



namespace glm
{
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T length(vec<L, T, Q> const& x);
# 39 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);
# 49 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);
# 69 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> normalize(vec<L, T, Q> const& x);
# 79 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> faceforward(
  vec<L, T, Q> const& N,
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& Nref);
# 93 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> reflect(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N);
# 107 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> refract(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N,
  T eta);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/func_geometric.inl" 1
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp" 1



       
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<1, T, Q>
 {


  typedef T value_type;
  typedef vec<1, T, Q> type;
  typedef vec<1, bool, Q> bool_type;
# 66 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
   union {T x, r, s;};
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
  typedef length_t length_type;
  __attribute__((device)) __attribute__((host)) static constexpr length_type length(){return 1;}

  __attribute__((device)) __attribute__((host)) constexpr T & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr T const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr vec() = default;
  __attribute__((device)) __attribute__((host)) constexpr vec(vec const& v) = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, T, P> const& v);



  __attribute__((device)) __attribute__((host)) constexpr explicit vec(T scalar);




  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<2, U, P> const& v);

  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr vec(vec<1, U, P> const& v);
# 132 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator+=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator-=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator*=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator/=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);



  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator++();
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator--();
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator++(int);
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator--(int);



  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator%=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator&=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator|=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator^=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator<<=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator>>=(U scalar);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.inl" 1




namespace glm
{
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
  : x(v.x)
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q>::vec(T scalar)
  : x(scalar)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
 {
  return x;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
 {
  return x;
 }
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.inl"
 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator++()
 {
  ++this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator--()
 {
  --this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> vec<1, T, Q>::operator++(int)
 {
  vec<1, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> vec<1, T, Q>::operator--(int)
 {
  vec<1, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= U(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   -v.x);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar + v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x + v2.x);
 }


 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar - v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x - v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar * v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x * v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar / v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x / v2.x);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x % scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar % v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x % v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x & scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar & v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x & v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x | scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar | v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x | v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x ^ scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar ^ v.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x ^ v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x << scalar));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar << v.x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x << v2.x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x >> scalar));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar >> v.x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x >> v2.x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   ~v.x);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x && v2.x);
 }

 template<qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x || v2.x);
 }
}
# 308 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp" 2
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 2



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 22 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 2

namespace glm
{
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);
# 46 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> exp(vec<L, T, Q> const& v);
# 59 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> log(vec<L, T, Q> const& v);
# 70 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> exp2(vec<L, T, Q> const& v);
# 82 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> log2(vec<L, T, Q> const& v);
# 93 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> sqrt(vec<L, T, Q> const& v);
# 104 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 1



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../detail/setup.hpp" 1
# 24 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp" 2

namespace glm
{
# 37 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 47 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 57 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 67 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 77 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool any(vec<L, bool, Q> const& v);







 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool all(vec<L, bool, Q> const& v);
# 115 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../detail/func_vector_relational.inl" 1
namespace glm
{
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool any(vec<L, bool, Q> const& v)
 {
  bool Result = false;
  for(length_t i = 0; i < L; ++i)
   Result = Result || v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool all(vec<L, bool, Q> const& v)
 {
  bool Result = true;
  for(length_t i = 0; i < L; ++i)
   Result = Result && v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 122 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp" 2
# 5 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/_vectorize.hpp" 1
       

namespace glm{
namespace detail
{
 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
 struct functor1{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 1, R, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
  {
   return vec<1, R, Q>(Func(v.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 2, R, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
  {
   return vec<2, R, Q>(Func(v.x), Func(v.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 3, R, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
  {
   return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 4, R, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
  {
   return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 1, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return vec<1, T, Q>(Func(a.x, b.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 2, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 3, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 4, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2_vec_sca{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 1, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
  {
   return vec<1, T, Q>(Func(a.x, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 2, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
  {
   return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 3, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
  {
   return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 4, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
  {
   return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct functor2_vec_int {};

 template<typename T, qualifier Q>
 struct functor2_vec_int<1, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
  {
   return vec<1, int, Q>(Func(a.x, b.x));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<2, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
  {
   return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<3, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
  {
   return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<4, T, Q>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
  {
   return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };
}
}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 1 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3
       
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4

# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 2 3
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2


# 10 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl"
namespace glm{
namespace detail
{

  using std::log2;
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl"
 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_log2
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");

   return detail::functor1<vec, L, T, T, Q>::call(log2, v);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sqrt
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_inversesqrt
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template<length_t L, bool Aligned>
 struct compute_inversesqrt<L, float, lowp, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
  {
   vec<L, float, lowp> tmp(x);
   vec<L, float, lowp> xhalf(tmp * 0.5f);
   vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
   vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
   vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
 {
  return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
 }


 using std::exp;
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp, x);
 }


 using std::log;
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> log(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(log, x);
 }


    using std::exp2;
# 106 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType log2(genType x)
 {
  return log2(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
 {
  return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using std::sqrt;
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'sqrt' only accept floating-point inputs");
  return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
  return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
}
# 111 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 2
# 2 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/func_geometric.inl" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/_fixes.hpp" 1
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 2 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/_fixes.hpp" 2
# 19 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp" 2

namespace glm
{
# 31 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType abs(genType x);
# 42 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x);
# 53 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> sign(vec<L, T, Q> const& x);
# 64 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> floor(vec<L, T, Q> const& x);
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> trunc(vec<L, T, Q> const& x);
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> round(vec<L, T, Q> const& x);
# 105 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> roundEven(vec<L, T, Q> const& x);
# 117 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> ceil(vec<L, T, Q> const& x);







 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType fract(genType x);
# 137 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> fract(vec<L, T, Q> const& x);

 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType mod(genType x, genType y);

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);
# 155 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 167 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType modf(genType x, genType& i);







 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType min(genType x, genType y);
# 187 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, T y);
# 198 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType max(genType x, genType y);
# 218 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, T y);
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 239 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType clamp(genType x, genType minVal, genType maxVal);
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);
# 263 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
# 308 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genTypeT, typename genTypeU>
 __attribute__((device)) __attribute__((host)) genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

 template<length_t L, typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

 template<length_t L, typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);





 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType step(genType edge, genType x);
# 332 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);
# 343 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);
# 360 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType smoothstep(genType edge0, genType edge1, genType x);

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);
# 383 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, bool, Q> isnan(vec<L, T, Q> const& x);
# 398 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, bool, Q> isinf(vec<L, T, Q> const& x);







 __attribute__((device)) __attribute__((host)) int floatBitsToInt(float const& v);
# 418 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);







 __attribute__((device)) __attribute__((host)) uint floatBitsToUint(float const& v);
# 438 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);
# 449 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 __attribute__((device)) __attribute__((host)) float intBitsToFloat(int const& v);
# 462 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);
# 473 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 __attribute__((device)) __attribute__((host)) float uintBitsToFloat(uint const& v);
# 486 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);







 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType fma(genType const& a, genType const& b, genType const& c);
# 512 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType frexp(genType x, int& exp);

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);
# 529 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType ldexp(genType const& x, int const& exp);

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl" 1




# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/compute_common.hpp" 1
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/setup.hpp" 1
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/compute_common.hpp" 2


namespace glm{
namespace detail
{
 template<typename genFIType, bool >
 struct compute_abs
 {};

 template<typename genFIType>
 struct compute_abs<genFIType, true>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static genFIType call(genFIType x)
  {
   static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };


 template<>
 struct compute_abs<float, true>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static float call(float x)
  {
   return fabsf(x);
  }
 };


 template<typename genFIType>
 struct compute_abs<genFIType, false>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static genFIType call(genFIType x)
  {
   static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x;
  }
 };
}
}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl" 2







namespace glm
{

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType min(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");
  return (y < x) ? y : x;
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType max(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

  return (x < y) ? y : x;
 }


 template<>
 __attribute__((device)) __attribute__((host)) inline constexpr int abs(int x)
 {
  int const y = x >> (sizeof(int) * 8 - 1);
  return (x ^ y) - y;
 }



  using ::std::round;
# 55 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
  using ::std::trunc;
# 66 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
}

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_abs_vector
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(abs, x);
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_vector
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_vector<L, T, bool, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
  {
   vec<L, T, Q> Result;
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_scalar
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_scalar<L, T, bool, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<typename T, typename U>
 struct compute_mix
 {
  __attribute__((device)) __attribute__((host)) inline static T call(T const& x, T const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
  }
 };

 template<typename T>
 struct compute_mix<T, bool>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(T const& x, T const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_sign
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sign<L, T, Q, false, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
   vec<L, T, Q> const y(vec<L, typename detail::make_unsigned<T>::type, Q>(-x) >> typename detail::make_unsigned<T>::type(Shift));

   return (x >> Shift) | y;
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_floor
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_ceil
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_fract
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return x - floor(x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_trunc
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_round
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(round, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mod
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
   return a - b * floor(a / b);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_min_vector
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(min, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_max_vector
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(max, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_clamp_vector
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_step_vector
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
  {
   return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_smoothstep_vector
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'smoothstep' only accept floating-point inputs");
   vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template<typename genFIType>
 __attribute__((device)) __attribute__((host)) inline constexpr genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x)
 {
  return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }



 template<typename genFIType>
 __attribute__((device)) __attribute__((host)) inline genFIType sign(genFIType x)
 {
  static_assert(std::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> sign(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using ::std::floor;
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'floor' only accept floating-point inputs.");
  return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'trunc' only accept floating-point inputs");
  return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> round(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'round' only accept floating-point inputs");
  return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
# 339 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType roundEven(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs");

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'roundEven' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
 }


 using ::std::ceil;
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ceil' only accept floating-point inputs");
  return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType fract(genType x)
 {
  return fract(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'fract' only accept floating-point inputs");
  return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType mod(genType x, genType y)
 {


   vec<1, genType, defaultp> Result(mod(vec<1, genType, defaultp>(x), y));
   return Result.x;



 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType modf(genType x, genType & i)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs");
  return std::modf(x, &i);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
 {
  return vec<1, T, Q>(
   modf(x.x, i.x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
 {
  return vec<2, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
 {
  return vec<3, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
 {
  return vec<4, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 476 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType clamp(genType x, genType minVal, genType maxVal)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return min(max(x, minVal), maxVal);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
 }

 template<typename genTypeT, typename genTypeU>
 __attribute__((device)) __attribute__((host)) inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
 {
  return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
 {
  return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType smoothstep(genType edge0, genType edge1, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'smoothstep' only accept floating-point inputs");

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
 }


  using std::isnan;
# 612 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

  vec<L, bool, Q> Result;
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isnan(v[l]);
  return Result;
 }


  using std::isinf;
# 654 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs");

  vec<L, bool, Q> Result;
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isinf(v[l]);
  return Result;
 }

 __attribute__((device)) __attribute__((host)) inline int floatBitsToInt(float const& v)
 {
  union
  {
   float in;
   int out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
 {
  return reinterpret_cast<vec<L, int, Q>&>(const_cast<vec<L, float, Q>&>(v));
 }

 __attribute__((device)) __attribute__((host)) inline uint floatBitsToUint(float const& v)
 {
  union
  {
   float in;
   uint out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
 {
  return reinterpret_cast<vec<L, uint, Q>&>(const_cast<vec<L, float, Q>&>(v));
 }

 __attribute__((device)) __attribute__((host)) inline float intBitsToFloat(int const& v)
 {
  union
  {
   int in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
 {
  return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, int, Q>&>(v));
 }

 __attribute__((device)) __attribute__((host)) inline float uintBitsToFloat(uint const& v)
 {
  union
  {
   uint in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
 {
  return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
 }


  using std::fma;
# 751 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType frexp(genType x, int& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'frexp' only accept floating-point inputs");

  return std::frexp(x, &exp);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

  vec<L, T, Q> Result;
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::frexp(v[l], &exp[l]);
  return Result;
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType ldexp(genType const& x, int const& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'ldexp' only accept floating-point inputs");

  return std::ldexp(x, exp);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

  vec<L, T, Q> Result;
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::ldexp(v[l], exp[l]);
  return Result;
 }
}
# 539 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/../common.hpp" 2
# 3 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/func_geometric.inl" 2

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_length
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<L, T, Q> const& v)
  {
   return sqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_distance
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
  {
   return length(p1 - p0);
  }
 };

 template<typename V, typename T, bool Aligned>
 struct compute_dot{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<1, T, Q>, T, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return a.x * b.x;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<2, T, Q>, T, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   vec<2, T, Q> tmp(a * b);
   return tmp.x + tmp.y;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<3, T, Q>, T, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   vec<3, T, Q> tmp(a * b);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<4, T, Q>, T, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> tmp(a * b);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_cross
 {
  __attribute__((device)) __attribute__((host)) inline static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

   return vec<3, T, Q>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_normalize
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return v * inversesqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_faceforward
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_reflect
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_refract
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
   return Result;
  }
 };
}


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType length(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

  return abs(x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T length(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

  return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType distance(genType const& p0, genType const& p1)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

  return length(p1 - p0);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
 {
  return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
 }


 template<typename T>
 __attribute__((device)) __attribute__((host)) inline T dot(T x, T y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return x * y;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
 {
  return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }
# 189 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../detail/func_geometric.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

  return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
 {
  return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType reflect(genType const& I, genType const& N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
 {
  return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType refract(genType const& I, genType const& N, genType eta)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
  return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
 }
}
# 117 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/../geometric.hpp" 2
# 2 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../detail/func_matrix.inl" 2


namespace glm{
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_matrixCompMult
 {
  __attribute__((device)) __attribute__((host)) inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   mat<C, R, T, Q> Result;
   for(length_t i = 0; i < Result.length(); ++i)
    Result[i] = x[i] * y[i];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_transpose{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 2, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   mat<2, 2, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 3, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
  {
   mat<3,2, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 4, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
  {
   mat<4, 2, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 2, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
  {
   mat<2, 3, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 3, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   mat<3, 3, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 4, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
  {
   mat<4, 3, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 2, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
  {
   mat<2, 4, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 3, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
  {
   mat<3, 4, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 4, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   mat<4, 4, T, Q> Result;
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];

   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   Result[3][3] = m[3][3];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_determinant{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<2, 2, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(mat<2, 2, T, Q> const& m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<3, 3, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(mat<3, 3, T, Q> const& m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<4, 4, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static T call(mat<4, 4, T, Q> const& m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   vec<4, T, Q> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_inverse{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<2, 2, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   mat<2, 2, T, Q> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<3, 3, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   mat<3, 3, T, Q> Inverse;
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<4, 4, T, Q, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
   vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
   vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
   vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
   vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
   vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

   vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   vec<4, T, Q> SignA(+1, -1, +1, -1);
   vec<4, T, Q> SignB(-1, +1, -1, +1);
   mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   vec<4, T, Q> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs");
  return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<length_t DA, length_t DB, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs");

  typename detail::outerProduct_trait<DA, DB, T, Q>::type m;
  for(length_t i = 0; i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs");
  return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T determinant(mat<C, R, T, Q> const& m)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs");
  return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
  return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }
}
# 162 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/../matrix.hpp" 2
# 2 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 2

namespace glm
{
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)

   : value{m[0], m[1]}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0), col_type(0, scalar)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat
 (
  T const& x0, T const& y0,
  T const& x1, T const& y1
 )

   : value{col_type(x0, y0), col_type(x1, y1)}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{v0, v1}

 {




 }



 template<typename T, qualifier Q>
 template<typename X1, typename Y1, typename X2, typename Y2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1,
  X2 const& x2, Y2 const& y2
 )

   : value{col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i)
 {
  
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 3 4
 ((
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
 i < this->length()
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
 "i < this->length()"
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl", 222, __PRETTY_FUNCTION__))
# 222 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
                           ;
  return this->value[i];
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const
 {
  
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 3 4
 ((
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
 i < this->length()
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
 "i < this->length()"
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl", 229, __PRETTY_FUNCTION__))
# 229 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.inl"
                           ;
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
 {
  mat<2, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
 {
  mat<2, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar - m[0],
   scalar - m[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 2, T, Q>::col_type operator*
 (
  mat<2, 2, T, Q> const& m,
  typename mat<2, 2, T, Q>::row_type const& v
 )
 {
  return vec<2, T, Q>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 2, T, Q>::row_type operator*
 (
  typename mat<2, 2, T, Q>::col_type const& v,
  mat<2, 2, T, Q> const& m
 )
 {
  return vec<2, T, Q>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  mat<2, 2, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 177 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/../detail/type_mat2x2.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/matrix_double2x2.hpp" 2

namespace glm
{






 typedef mat<2, 2, double, defaultp> dmat2x2;




 typedef mat<2, 2, double, defaultp> dmat2;


}
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/mat2x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/matrix_double2x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 2, double, lowp> lowp_dmat2;





 typedef mat<2, 2, double, mediump> mediump_dmat2;





 typedef mat<2, 2, double, highp> highp_dmat2;





 typedef mat<2, 2, double, lowp> lowp_dmat2x2;





 typedef mat<2, 2, double, mediump> mediump_dmat2x2;





 typedef mat<2, 2, double, highp> highp_dmat2x2;


}
# 7 "/beegfs/teran_parrales/NVISII/externals/glm/glm/mat2x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/matrix_float2x2.hpp" 1



       


namespace glm
{






 typedef mat<2, 2, float, defaultp> mat2x2;




 typedef mat<2, 2, float, defaultp> mat2;


}
# 8 "/beegfs/teran_parrales/NVISII/externals/glm/glm/mat2x2.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/./ext/matrix_float2x2_precision.hpp" 1



       


namespace glm
{







 typedef mat<2, 2, float, lowp> lowp_mat2;





 typedef mat<2, 2, float, mediump> mediump_mat2;





 typedef mat<2, 2, float, highp> highp_mat2;





 typedef mat<2, 2, float, lowp> lowp_mat2x2;





 typedef mat<2, 2, float, mediump> mediump_mat2x2;





 typedef mat<2, 2, float, highp> highp_mat2x2;


}
# 9 "/beegfs/teran_parrales/NVISII/externals/glm/glm/mat2x2.hpp" 2
# 120 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 129 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp"
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp" 1
# 19 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp" 1
# 22 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp" 2


namespace glm
{
# 37 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);
# 48 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);
# 60 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> sin(vec<L, T, Q> const& angle);
# 72 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> cos(vec<L, T, Q> const& angle);
# 83 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> tan(vec<L, T, Q> const& angle);
# 96 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> asin(vec<L, T, Q> const& x);
# 109 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> acos(vec<L, T, Q> const& x);
# 124 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);
# 136 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);
# 147 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> sinh(vec<L, T, Q> const& angle);
# 158 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> cosh(vec<L, T, Q> const& angle);
# 169 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> tanh(vec<L, T, Q> const& angle);
# 180 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> asinh(vec<L, T, Q> const& x);
# 192 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> acosh(vec<L, T, Q> const& x);
# 204 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> atanh(vec<L, T, Q> const& x);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_trigonometric.inl" 1

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 3 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_trigonometric.inl" 2


namespace glm
{

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType radians(genType degrees)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'radians' only accept floating-point input");

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(radians, v);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType degrees(genType radians)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'degrees' only accept floating-point input");

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
 }


 using ::std::sin;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sin, v);
 }


 using std::cos;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cos, v);
 }


 using std::tan;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tan, v);
 }


 using std::asin;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asin, v);
 }


 using std::acos;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acos, v);
 }


 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType atan(genType y, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");

  return ::std::atan2(y, x);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> atan(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::functor2<vec, L, T, Q>::call(::std::atan2, a, b);
 }

 using std::atan;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atan, v);
 }


 using std::sinh;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
 }


 using std::cosh;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
 }


 using std::tanh;

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
 }



  using std::asinh;
# 145 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
 }



  using std::acosh;
# 166 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
 }



  using std::atanh;
# 187 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
 }
}
# 211 "/beegfs/teran_parrales/NVISII/externals/glm/glm/trigonometric.hpp" 2
# 130 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp" 1
# 16 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
       





namespace glm
{
# 38 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) uint packUnorm2x16(vec2 const& v);
# 51 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) uint packSnorm2x16(vec2 const& v);
# 64 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) uint packUnorm4x8(vec4 const& v);
# 77 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) uint packSnorm4x8(vec4 const& v);
# 90 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) vec2 unpackUnorm2x16(uint p);
# 103 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) vec2 unpackSnorm2x16(uint p);
# 116 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) vec4 unpackUnorm4x8(uint p);
# 129 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) vec4 unpackSnorm4x8(uint p);
# 139 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) double packDouble2x32(uvec2 const& v);
# 148 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) uvec2 unpackDouble2x32(double v);
# 158 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) uint packHalf2x16(vec2 const& v);
# 168 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp"
 __attribute__((device)) __attribute__((host)) vec2 unpackHalf2x16(uint v);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_packing.inl" 1




# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.hpp" 1
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/setup.hpp" 1
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.hpp" 2

namespace glm{
namespace detail
{
 typedef short hdata;

 __attribute__((device)) __attribute__((host)) float toFloat32(hdata value);
 __attribute__((device)) __attribute__((host)) hdata toFloat16(float const& value);

}
}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl" 1
namespace glm{
namespace detail
{
 __attribute__((device)) __attribute__((host)) inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f = f * f;
  return f;
 }

 union uif32
 {
  __attribute__((device)) __attribute__((host)) inline uif32() :
   i(0)
  {}

  __attribute__((device)) __attribute__((host)) inline uif32(float f_) :
   f(f_)
  {}

  __attribute__((device)) __attribute__((host)) inline uif32(unsigned int i_) :
   i(i_)
  {}

  float f;
  unsigned int i;
 };

 __attribute__((device)) __attribute__((host)) inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = static_cast<unsigned int>(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
  return Result.f;
 }

 __attribute__((device)) __attribute__((host)) inline hdata toFloat16(float const& f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = static_cast<int>(Entry.i);
# 121 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl"
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 141 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl"
    return hdata(s);
   }
# 151 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl"
   m = (m | 0x00800000) >> (1 - e);
# 162 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl"
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 193 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl"
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 209 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.inl"
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 17 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/type_half.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_packing.inl" 2

namespace glm
{
 __attribute__((device)) __attribute__((host)) inline uint packUnorm2x16(vec2 const& v)
 {
  union
  {
   unsigned short in[2];
   uint out;
  } u;

  vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 __attribute__((device)) __attribute__((host)) inline vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   unsigned short out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 }

 __attribute__((device)) __attribute__((host)) inline uint packSnorm2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 __attribute__((device)) __attribute__((host)) inline vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 }

 __attribute__((device)) __attribute__((host)) inline uint packUnorm4x8(vec4 const& v)
 {
  union
  {
   unsigned char in[4];
   uint out;
  } u;

  vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 __attribute__((device)) __attribute__((host)) inline vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   unsigned char out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 }

 __attribute__((device)) __attribute__((host)) inline uint packSnorm4x8(vec4 const& v)
 {
  union
  {
   signed char in[4];
   uint out;
  } u;

  vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 __attribute__((device)) __attribute__((host)) inline glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   signed char out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 }

 __attribute__((device)) __attribute__((host)) inline double packDouble2x32(uvec2 const& v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 }

 __attribute__((device)) __attribute__((host)) inline uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 }

 __attribute__((device)) __attribute__((host)) inline uint packHalf2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 }

 __attribute__((device)) __attribute__((host)) inline vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 174 "/beegfs/teran_parrales/NVISII/externals/glm/glm/packing.hpp" 2
# 133 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
       





namespace glm
{
# 36 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, uint, Q> uaddCarry(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & carry);
# 50 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, uint, Q> usubBorrow(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & borrow);
# 64 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) void umulExtended(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & msb,
  vec<L, uint, Q> & lsb);
# 79 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) void imulExtended(
  vec<L, int, Q> const& x,
  vec<L, int, Q> const& y,
  vec<L, int, Q> & msb,
  vec<L, int, Q> & lsb);
# 102 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> bitfieldExtract(
  vec<L, T, Q> const& Value,
  int Offset,
  int Bits);
# 123 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> bitfieldInsert(
  vec<L, T, Q> const& Base,
  vec<L, T, Q> const& Insert,
  int Offset,
  int Bits);
# 139 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);







 template<typename genType>
 __attribute__((device)) __attribute__((host)) int bitCount(genType v);
# 158 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, int, Q> bitCount(vec<L, T, Q> const& v);
# 169 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) int findLSB(genIUType x);
# 181 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, int, Q> findLSB(vec<L, T, Q> const& v);
# 193 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) int findMSB(genIUType x);
# 206 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, int, Q> findMSB(vec<L, T, Q> const& v);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_integer.inl" 1
# 19 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_integer.inl"
namespace glm{
namespace detail
{
 template<typename T>
 __attribute__((device)) __attribute__((host)) inline T mask(T Bits)
 {
  return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template<typename genIUType, size_t Bits>
 struct compute_findLSB
 {
  __attribute__((device)) __attribute__((host)) inline static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 102 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_integer.inl"
 template<length_t L, typename T, qualifier Q, bool EXEC = true>
 struct compute_findMSB_step_vec
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_findMSB_step_vec<L, T, Q, false>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
  {
   return x;
  }
 };

 template<length_t L, typename T, qualifier Q, int>
 struct compute_findMSB_vec
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
  {
   vec<L, T, Q> x(v);
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 173 "/beegfs/teran_parrales/NVISII/externals/glm/glm/detail/func_integer.inl"
}


 __attribute__((device)) __attribute__((host)) inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
 {
  detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
  detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
  vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
  return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }


 __attribute__((device)) __attribute__((host)) inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
 {
  Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
 {
  Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
  vec<L, uint, Q> const YgeX(y - x);
  vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 }


 __attribute__((device)) __attribute__((host)) inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
 {
  detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
  msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
  lsb = vec<L, uint, Q>(Value64);
 }


 __attribute__((device)) __attribute__((host)) inline void imulExtended(int x, int y, int& msb, int& lsb)
 {
  detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template<length_t L, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
 {
  vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
  lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
  msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
 }


 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values");

  return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

  T const Mask = static_cast<T>(detail::mask(Bits) << Offset);
  return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
 }


 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) inline genIUType bitfieldReverse(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values");

  return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldReverse' only accept integer values");

  vec<L, T, Q> x(v);
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }


 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) inline int bitCount(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values");

  return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitCount' only accept integer values");






  vec<L, typename detail::make_unsigned<T>::type, Q> x(*reinterpret_cast<vec<L, typename detail::make_unsigned<T>::type, Q> const *>(&v));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vec<L, int, Q>(x);




 }


 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) inline int findLSB(genIUType Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

  return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
 }


 template<typename genIUType>
 __attribute__((device)) __attribute__((host)) inline int findMSB(genIUType v)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

  return findMSB(vec<1, genIUType>(v)).x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

  return detail::compute_findMSB_vec<L, T, Q, sizeof(T) * 8>::call(v);
 }
}
# 213 "/beegfs/teran_parrales/NVISII/externals/glm/glm/integer.hpp" 2
# 137 "/beegfs/teran_parrales/NVISII/externals/glm/glm/glm.hpp" 2
# 6 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.hpp" 1
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.hpp"
       






# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/constants.hpp" 1
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/constants.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/../ext/scalar_constants.hpp" 1
# 11 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/../ext/scalar_constants.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/../ext/../detail/setup.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/../ext/scalar_constants.hpp" 2





namespace glm
{




 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType epsilon();


 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType pi();


 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType cos_one_over_two();


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/../ext/scalar_constants.inl" 1


namespace glm
{
 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType epsilon()
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'epsilon' only accepts floating-point inputs");
  return std::numeric_limits<genType>::epsilon();
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType pi()
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'pi' only accepts floating-point inputs");
  return static_cast<genType>(3.14159265358979323846264338327950288);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType cos_one_over_two()
 {
  return genType(0.877582561890372716130286068203503191);
 }
}
# 41 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/../ext/scalar_constants.hpp" 2
# 17 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/constants.hpp" 2





namespace glm
{





 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType zero();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType one();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType two_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType half_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType three_over_two_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType quarter_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType one_over_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType one_over_two_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType two_over_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType four_over_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType two_over_root_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType one_over_root_two();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_half_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_two_pi();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_ln_four();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType e();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType euler();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_two();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_three();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType root_five();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType ln_two();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType ln_ten();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType ln_ln_two();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType third();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType two_thirds();



 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType golden_ratio();


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/constants.inl" 1


namespace glm
{
 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType zero()
 {
  return genType(0);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType one()
 {
  return genType(1);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType e()
 {
  return genType(2.71828182845904523536);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }

}
# 166 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/../gtc/constants.hpp" 2
# 24 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp" 2
# 32 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
namespace glm
{
# 49 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> projectZO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 65 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> projectNO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 81 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> project(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 97 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> unProjectZO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 113 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> unProjectNO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 129 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> unProject(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 142 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp"
 template<typename T, qualifier Q, typename U>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> pickMatrix(
  vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl" 1
namespace glm
{
 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> projectZO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);

  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> projectNO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> project(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return projectNO(obj, model, proj, viewport);

 }

 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> unProjectZO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);
  tmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> unProjectNO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> unProject(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return unProjectNO(win, model, proj, viewport);

 }

 template<typename T, qualifier Q, typename U>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> pickMatrix(vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport)
 {
  
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl" 3 4
 ((
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl"
 delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl"
 "delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)"
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl", 91, __PRETTY_FUNCTION__))
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.inl"
                                                                   ;
  mat<4, 4, T, Q> Result(static_cast<T>(1));

  if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
   return Result;

  vec<3, T, Q> Temp(
   (static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
   (static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
   static_cast<T>(0));


  Result = translate(Result, Temp);
  return scale(Result, vec<3, T, Q>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
 }
}
# 150 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_projection.hpp" 2
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
       
# 31 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
namespace glm
{
# 42 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top);







 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoLH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoLH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoRH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoRH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoNO(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 113 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoLH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 124 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> orthoRH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 135 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top, T zNear, T zFar);





 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumLH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumLH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumRH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumRH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumNO(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumLH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustumRH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> frustum(
  T left, T right, T bottom, T top, T near, T far);
# 224 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveRH_ZO(
  T fovy, T aspect, T near, T far);
# 237 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveRH_NO(
  T fovy, T aspect, T near, T far);
# 250 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveLH_ZO(
  T fovy, T aspect, T near, T far);
# 263 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveLH_NO(
  T fovy, T aspect, T near, T far);
# 276 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveZO(
  T fovy, T aspect, T near, T far);
# 289 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveNO(
  T fovy, T aspect, T near, T far);
# 303 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveRH(
  T fovy, T aspect, T near, T far);
# 317 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveLH(
  T fovy, T aspect, T near, T far);
# 331 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspective(
  T fovy, T aspect, T near, T far);
# 345 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovRH_ZO(
  T fov, T width, T height, T near, T far);
# 359 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovRH_NO(
  T fov, T width, T height, T near, T far);
# 373 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovLH_ZO(
  T fov, T width, T height, T near, T far);
# 387 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovLH_NO(
  T fov, T width, T height, T near, T far);
# 401 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovZO(
  T fov, T width, T height, T near, T far);
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovNO(
  T fov, T width, T height, T near, T far);
# 430 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovRH(
  T fov, T width, T height, T near, T far);
# 445 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFovLH(
  T fov, T width, T height, T near, T far);
# 459 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> perspectiveFov(
  T fov, T width, T height, T near, T far);
# 470 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> infinitePerspectiveLH(
  T fovy, T aspect, T near);
# 481 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> infinitePerspectiveRH(
  T fovy, T aspect, T near);
# 492 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 503 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 515 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp"
 template<typename T>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 1
namespace glm
{
 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top)
 {
  mat<4, 4, T, defaultp> Result(static_cast<T>(1));
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoLH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoLH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoRH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoRH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_ZO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoNO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoLH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoLH_NO(left, right, bottom, top, zNear, zFar);


 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> orthoRH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top, T zNear, T zFar)
 {







   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumLH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = farVal / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumLH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumRH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = farVal / (nearVal - farVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumRH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_ZO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumNO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumLH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumLH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustumRH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> frustum(T left, T right, T bottom, T top, T nearVal, T farVal)
 {







   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveRH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 235 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 235 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)
# 235 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 235 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)"
# 235 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 235, __PRETTY_FUNCTION__))
# 235 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveRH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)"
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 251, __PRETTY_FUNCTION__))
# 251 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveLH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)"
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 267, __PRETTY_FUNCTION__))
# 267 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveLH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  
# 283 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 283 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)
# 283 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 283 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)"
# 283 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 283, __PRETTY_FUNCTION__))
# 283 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                                                            ;

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveZO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_ZO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveNO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveLH_NO(fovy, aspect, zNear, zFar);


 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
 {







   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovRH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 354 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 354 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 width > static_cast<T>(0)
# 354 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 354 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "width > static_cast<T>(0)"
# 354 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 354, __PRETTY_FUNCTION__))
# 354 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                  ;
  
# 355 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 355 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 height > static_cast<T>(0)
# 355 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 355 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "height > static_cast<T>(0)"
# 355 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 355, __PRETTY_FUNCTION__))
# 355 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                   ;
  
# 356 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 356 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 fov > static_cast<T>(0)
# 356 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 356 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "fov > static_cast<T>(0)"
# 356 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 356, __PRETTY_FUNCTION__))
# 356 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovRH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 374 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 374 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 width > static_cast<T>(0)
# 374 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 374 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "width > static_cast<T>(0)"
# 374 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 374, __PRETTY_FUNCTION__))
# 374 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                  ;
  
# 375 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 375 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 height > static_cast<T>(0)
# 375 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 375 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "height > static_cast<T>(0)"
# 375 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 375, __PRETTY_FUNCTION__))
# 375 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                   ;
  
# 376 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 376 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 fov > static_cast<T>(0)
# 376 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 376 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "fov > static_cast<T>(0)"
# 376 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 376, __PRETTY_FUNCTION__))
# 376 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovLH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 394 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 394 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 width > static_cast<T>(0)
# 394 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 394 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "width > static_cast<T>(0)"
# 394 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 394, __PRETTY_FUNCTION__))
# 394 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                  ;
  
# 395 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 395 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 height > static_cast<T>(0)
# 395 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 395 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "height > static_cast<T>(0)"
# 395 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 395, __PRETTY_FUNCTION__))
# 395 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                   ;
  
# 396 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 396 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 fov > static_cast<T>(0)
# 396 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 396 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "fov > static_cast<T>(0)"
# 396 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 396, __PRETTY_FUNCTION__))
# 396 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovLH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  
# 414 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 414 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 width > static_cast<T>(0)
# 414 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 414 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "width > static_cast<T>(0)"
# 414 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 414, __PRETTY_FUNCTION__))
# 414 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                  ;
  
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 height > static_cast<T>(0)
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "height > static_cast<T>(0)"
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 415, __PRETTY_FUNCTION__))
# 415 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                   ;
  
# 416 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ((
# 416 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 fov > static_cast<T>(0)
# 416 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 416 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
 "fov > static_cast<T>(0)"
# 416 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl", 416, __PRETTY_FUNCTION__))
# 416 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.inl"
                                ;

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovZO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovNO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovLH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
 {







   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> infinitePerspectiveRH(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> infinitePerspectiveLH(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
 {



   return infinitePerspectiveRH(fovy, aspect, zNear);

 }


 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }
}
# 523 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_clip_space.hpp" 2
# 30 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
       
# 32 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
namespace glm
{




 template<typename genType>
 __attribute__((device)) __attribute__((host)) constexpr genType identity();
# 63 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> translate(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 79 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> rotate(
  mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& axis);
# 94 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> scale(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 108 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> lookAtRH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 122 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> lookAtLH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 137 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> lookAt(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.inl" 1
namespace glm
{
 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline constexpr genType identity()
 {
  return detail::init_gentype<genType, detail::genTypeTrait<genType>::GENTYPE>::identity();
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> translate(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> rotate(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  vec<3, T, Q> axis(normalize(v));
  vec<3, T, Q> temp((T(1) - c) * axis);

  mat<4, 4, T, Q> Rotate;
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> rotate_slow(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  mat<4, 4, T, Q> Result;

  vec<3, T, Q> axis = normalize(v);

  Result[0][0] = c + (static_cast<T>(1) - c) * axis.x * axis.x;
  Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = static_cast<T>(0);

  Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
  Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = static_cast<T>(0);

  Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
  Result[2][3] = static_cast<T>(0);

  Result[3] = vec<4, T, Q>(0, 0, 0, 1);
  return m * Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> scale(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> scale_slow(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> lookAtRH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(f, up)));
  vec<3, T, Q> const u(cross(s, f));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> lookAtLH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(up, f)));
  vec<3, T, Q> const u(cross(f, s));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] = f.x;
  Result[1][2] = f.y;
  Result[2][2] = f.z;
  Result[3][0] = -dot(s, eye);
  Result[3][1] = -dot(u, eye);
  Result[3][2] = -dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> lookAt(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {



            return lookAtRH(eye, center, up);

 }
}
# 145 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../ext/matrix_transform.hpp" 2
# 31 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.hpp" 2





# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.inl" 1
# 37 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_transform.hpp" 2
# 7 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.hpp" 1
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/../detail/setup.hpp" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.hpp" 2





namespace glm
{





 template<typename genType>
 __attribute__((device)) __attribute__((host)) typename genType::row_type row(
  genType const& m,
  length_t index);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType row(
  genType const& m,
  length_t index,
  typename genType::row_type const& x);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) typename genType::col_type column(
  genType const& m,
  length_t index);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) genType column(
  genType const& m,
  length_t index,
  typename genType::col_type const& x);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 1


namespace glm
{
 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType row
 (
  genType const& m,
  length_t index,
  typename genType::row_type const& x
 )
 {
  
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ((
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 index >= 0 && index < m[0].length()
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 "index >= 0 && index < m[0].length()"
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl", 13, __PRETTY_FUNCTION__))
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
                                            ;

  genType Result = m;
  for(length_t i = 0; i < m.length(); ++i)
   Result[i][index] = x[i];
  return Result;
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline typename genType::row_type row
 (
  genType const& m,
  length_t index
 )
 {
  
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ((
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 index >= 0 && index < m[0].length()
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 "index >= 0 && index < m[0].length()"
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl", 28, __PRETTY_FUNCTION__))
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
                                            ;

  typename genType::row_type Result(0);
  for(length_t i = 0; i < m.length(); ++i)
   Result[i] = m[i][index];
  return Result;
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType column
 (
  genType const& m,
  length_t index,
  typename genType::col_type const& x
 )
 {
  
# 44 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ((
# 44 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 index >= 0 && index < m.length()
# 44 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 44 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 "index >= 0 && index < m.length()"
# 44 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl", 44, __PRETTY_FUNCTION__))
# 44 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
                                         ;

  genType Result = m;
  Result[index] = x;
  return Result;
 }

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline typename genType::col_type column
 (
  genType const& m,
  length_t index
 )
 {
  
# 58 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ((
# 58 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 index >= 0 && index < m.length()
# 58 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 58 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
 "index >= 0 && index < m.length()"
# 58 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl", 58, __PRETTY_FUNCTION__))
# 58 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.inl"
                                         ;

  return m[index];
 }
}
# 61 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtc/matrix_access.hpp" 2
# 8 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.hpp"
       



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp"
       




# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp"
       




# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.hpp" 1
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.hpp"
       
# 27 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.hpp"
namespace glm
{
# 38 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.inl" 1



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_float.hpp" 1
       

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/setup.hpp" 1
# 4 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_float.hpp" 2






namespace glm{
namespace detail
{
 template <typename T>
 union float_t
 {};


 template <>
 union float_t<float>
 {
  typedef int int_type;
  typedef float float_type;

  constexpr float_t(float_type Num = 0.0f) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((1 << 23) - 1); }
  constexpr int_type exponent() const { return (i >> 23) & ((1 << 8) - 1); }

  int_type i;
  float_type f;
 };

 template <>
 union float_t<double>
 {
  typedef detail::int64 int_type;
  typedef double float_type;

  constexpr float_t(float_type Num = static_cast<float_type>(0)) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((int_type(1) << 52) - 1); }
  constexpr int_type exponent() const { return (i >> 52) & ((int_type(1) << 11) - 1); }

  int_type i;
  float_type f;
 };
}
}
# 5 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.inl" 2

namespace glm
{
 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return equal(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return lessThanEqual(abs(x - y), Epsilon);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return notEqual(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return greaterThan(abs(x - y), Epsilon);
 }


 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return equal(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  vec<L, bool, Q> Result(false);
  for(length_t i = 0; i < L; ++i)
  {
   detail::float_t<T> const a(x[i]);
   detail::float_t<T> const b(y[i]);


   if(a.negative() != b.negative())
   {

    Result[i] = a.mantissa() == b.mantissa() && a.exponent() == b.exponent();
   }
   else
   {

    typename detail::float_t<T>::int_type const DiffULPs = abs(a.i - b.i);
    Result[i] = DiffULPs <= MaxULPs[i];
   }
  }
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return notEqual(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  return not_(equal(x, y, MaxULPs));
 }
}
# 108 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/vector_relational.hpp" 2
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp" 1
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
       



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../ext/quaternion_geometric.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../ext/quaternion_geometric.hpp"
       
# 26 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../ext/quaternion_geometric.hpp"
namespace glm
{
# 37 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../ext/quaternion_geometric.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T length(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> normalize(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T dot(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../ext/quaternion_geometric.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T dot(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<qua<T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T length(qua<T, Q> const& q)
 {
  return glm::sqrt(dot(q, q));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> normalize(qua<T, Q> const& q)
 {
  T len = length(q);
  if(len <= static_cast<T>(0))
   return qua<T, Q>(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
  T oneOverLen = static_cast<T>(1) / len;
  return qua<T, Q>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return qua<T, Q>(
   q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
   q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
   q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
   q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
 }
}
# 71 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../ext/quaternion_geometric.hpp" 2
# 26 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp" 2
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
namespace glm
{
# 52 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 64 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 91 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
    template<typename T, typename S, qualifier Q>
    __attribute__((device)) __attribute__((host)) qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> conjugate(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> inverse(qua<T, Q> const& q);
# 118 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> isnan(qua<T, Q> const& x);
# 129 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> isinf(qua<T, Q> const& x);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs");

  T const cosTheta = dot(x, y);


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>(
    mix(x.w, y.w, a),
    mix(x.x, y.x, a),
    mix(x.y, y.y, a),
    mix(x.z, y.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
  }
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'lerp' only accept floating-point inputs");


  
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 3 4
 ((
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl"
 a >= static_cast<T>(0)
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl"
 "a >= static_cast<T>(0)"
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl", 34, __PRETTY_FUNCTION__))
# 34 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl"
                               ;
  
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 3 4
 ((
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl"
 a <= static_cast<T>(1)
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl"
 "a <= static_cast<T>(1)"
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl", 35, __PRETTY_FUNCTION__))
# 35 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.inl"
                               ;

  return x * (static_cast<T>(1) - a) + (y * a);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'slerp' only accept floating-point inputs");

  qua<T, Q> z = y;

  T cosTheta = dot(x, y);



  if(cosTheta < static_cast<T>(0))
  {
   z = -y;
   cosTheta = -cosTheta;
  }


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>(
    mix(x.w, z.w, a),
    mix(x.x, z.x, a),
    mix(x.y, z.y, a),
    mix(x.z, z.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
  }
 }

    template<typename T, typename S, qualifier Q>
    __attribute__((device)) __attribute__((host)) inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k)
    {
        static_assert(std::numeric_limits<T>::is_iec559, "'slerp' only accept floating-point inputs");
        static_assert(std::numeric_limits<S>::is_integer, "'slerp' only accept integer for spin count");

        qua<T, Q> z = y;

        T cosTheta = dot(x, y);



        if (cosTheta < static_cast<T>(0))
        {
            z = -y;
            cosTheta = -cosTheta;
        }


        if (cosTheta > static_cast<T>(1) - epsilon<T>())
        {

            return qua<T, Q>(
                mix(x.w, z.w, a),
                mix(x.x, z.x, a),
                mix(x.y, z.y, a),
                mix(x.z, z.z, a));
        }
        else
        {

            T angle = acos(cosTheta);
            T phi = angle + k * glm::pi<T>();
            return (sin(angle - a * phi)* x + sin(a * phi) * z) / sin(angle);
        }
    }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> conjugate(qua<T, Q> const& q)
 {
  return qua<T, Q>(q.w, -q.x, -q.y, -q.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> inverse(qua<T, Q> const& q)
 {
  return conjugate(q) / dot(q, q);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> isnan(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

  return vec<4, bool, Q>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> isinf(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs");

  return vec<4, bool, Q>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
 }
}
# 136 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_common.hpp" 2
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_float.hpp" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_float.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.hpp" 1



       







# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/../ext/quaternion_relational.hpp" 1
# 17 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/../ext/quaternion_relational.hpp"
       
# 26 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/../ext/quaternion_relational.hpp"
namespace glm
{







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/../ext/quaternion_relational.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 63 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/../ext/quaternion_relational.hpp" 2
# 13 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.hpp" 2



namespace glm
{
 template<typename T, qualifier Q>
 struct qua
 {


  typedef qua<T, Q> type;
  typedef T value_type;
# 57 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.hpp"
    T x, y, z, w;
# 73 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.hpp"
  typedef length_t length_type;


  __attribute__((device)) __attribute__((host)) static constexpr length_type length(){return 4;}

  __attribute__((device)) __attribute__((host)) constexpr T & operator[](length_type i);
  __attribute__((device)) __attribute__((host)) constexpr T const& operator[](length_type i) const;



  __attribute__((device)) __attribute__((host)) constexpr qua() = default;
  __attribute__((device)) __attribute__((host)) constexpr qua(qua<T, Q> const& q) = default;
  template<qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr qua(qua<T, P> const& q);



  __attribute__((device)) __attribute__((host)) constexpr qua(T s, vec<3, T, Q> const& v);
  __attribute__((device)) __attribute__((host)) constexpr qua(T w, T x, T y, T z);



  template<typename U, qualifier P>
  __attribute__((device)) __attribute__((host)) constexpr qua(qua<U, P> const& q);



   __attribute__((device)) __attribute__((host)) explicit operator mat<3, 3, T, Q>() const;
   __attribute__((device)) __attribute__((host)) explicit operator mat<4, 4, T, Q>() const;
# 110 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.hpp"
  __attribute__((device)) __attribute__((host)) qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v);


  __attribute__((device)) __attribute__((host)) constexpr qua(vec<3, T, Q> const& eulerAngles);
  __attribute__((device)) __attribute__((host)) qua(mat<3, 3, T, Q> const& q);
  __attribute__((device)) __attribute__((host)) qua(mat<4, 4, T, Q> const& q);



  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator=(qua<T, Q> const& q) = default;

  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator=(qua<U, Q> const& q);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator+=(qua<U, Q> const& q);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator-=(qua<U, Q> const& q);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator*=(qua<U, Q> const& q);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator*=(U s);
  template<typename U>
  __attribute__((device)) __attribute__((host)) constexpr qua<T, Q>& operator/=(U s);
 };



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator+(qua<T, Q> const& q);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator-(qua<T, Q> const& q);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2);

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2);
}


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 1





namespace glm{
namespace detail
{
 template <typename T>
 struct genTypeTrait<qua<T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_QUAT;
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<qua<T, Q>, T, Aligned>
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static T call(qua<T, Q> const& a, qua<T, Q> const& b)
  {
   vec<4, T, Q> tmp(a.w * b.w, a.x * b.x, a.y * b.y, a.z * b.z);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_add
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_sub
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_scalar
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>(q.w * s, q.x * s, q.y * s, q.z * s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_div_scalar
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>(q.w / s, q.x / s, q.y / s, q.z / s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_vec4
 {
  __attribute__((device)) __attribute__((host)) inline constexpr static vec<4, T, Q> call(qua<T, Q> const& q, vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(q * vec<3, T, Q>(v), v.w);
  }
 };
}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T & qua<T, Q>::operator[](typename qua<T, Q>::length_type i)
 {
  
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 3 4
 ((
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 i >= 0 && i < this->length()
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 "i >= 0 && i < this->length()"
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl", 76, __PRETTY_FUNCTION__))
# 76 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
                                     ;



   return (&x)[i];

 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T const& qua<T, Q>::operator[](typename qua<T, Q>::length_type i) const
 {
  
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 3 4
 ((
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 i >= 0 && i < this->length()
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 3 4
 ) ? static_cast<void> (0) : __assert_fail (
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 "i >= 0 && i < this->length()"
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl" 3 4
 , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl", 87, __PRETTY_FUNCTION__))
# 87 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
                                     ;



   return (&x)[i];

 }
# 119 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 template<typename T, qualifier Q>
 template<qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q>::qua(qua<T, P> const& q)



   : x(q.x), y(q.y), z(q.z), w(q.w)

 {}



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q>::qua(T s, vec<3, T, Q> const& v)



   : x(v.x), y(v.y), z(v.z), w(s)

 {}

 template <typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q>::qua(T _w, T _x, T _y, T _z)



   : x(_x), y(_y), z(_z), w(_w)

 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q>::qua(qua<U, P> const& q)



   : x(static_cast<T>(q.x)), y(static_cast<T>(q.y)), z(static_cast<T>(q.z)), w(static_cast<T>(q.w))

 {}
# 179 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q>::qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v)
 {
  T norm_u_norm_v = sqrt(dot(u, u) * dot(v, v));
  T real_part = norm_u_norm_v + dot(u, v);
  vec<3, T, Q> t;

  if(real_part < static_cast<T>(1.e-6f) * norm_u_norm_v)
  {



   real_part = static_cast<T>(0);
   t = abs(u.x) > abs(u.z) ? vec<3, T, Q>(-u.y, u.x, static_cast<T>(0)) : vec<3, T, Q>(static_cast<T>(0), -u.z, u.y);
  }
  else
  {

   t = cross(u, v);
  }

  *this = normalize(qua<T, Q>(real_part, t.x, t.y, t.z));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q>::qua(vec<3, T, Q> const& eulerAngle)
 {
  vec<3, T, Q> c = glm::cos(eulerAngle * T(0.5));
  vec<3, T, Q> s = glm::sin(eulerAngle * T(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q>::qua(mat<3, 3, T, Q> const& m)
 {
  *this = quat_cast(m);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q>::qua(mat<4, 4, T, Q> const& m)
 {
  *this = quat_cast(m);
 }


 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q>::operator mat<3, 3, T, Q>() const
 {
  return mat3_cast(*this);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q>::operator mat<4, 4, T, Q>() const
 {
  return mat4_cast(*this);
 }
# 255 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.inl"
 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> & qua<T, Q>::operator=(qua<U, Q> const& q)
 {
  this->w = static_cast<T>(q.w);
  this->x = static_cast<T>(q.x);
  this->y = static_cast<T>(q.y);
  this->z = static_cast<T>(q.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> & qua<T, Q>::operator+=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_add<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> & qua<T, Q>::operator-=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> & qua<T, Q>::operator*=(qua<U, Q> const& r)
 {
  qua<T, Q> const p(*this);
  qua<T, Q> const q(r);

  this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
  this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
  this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
  this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> & qua<T, Q>::operator*=(U s)
 {
  return (*this = detail::compute_quat_mul_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> & qua<T, Q>::operator/=(U s)
 {
  return (*this = detail::compute_quat_div_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator+(qua<T, Q> const& q)
 {
  return q;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator-(qua<T, Q> const& q)
 {
  return qua<T, Q>(-q.w, -q.x, -q.y, -q.z);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) += p;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) -= p;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) *= p;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> const QuatVector(q.x, q.y, q.z);
  vec<3, T, Q> const uv(glm::cross(QuatVector, v));
  vec<3, T, Q> const uuv(glm::cross(QuatVector, uv));

  return v + ((uv * q.w) + uuv) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v)
 {
  return detail::compute_quat_mul_vec4<T, Q, detail::is_aligned<Q>::value>::call(q, v);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q)
 {
  return q * s;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x != q2.x || q1.y != q2.y || q1.z != q2.z || q1.w != q2.w;
 }
}
# 186 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/../detail/type_quat.hpp" 2
# 24 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_float.hpp" 2





namespace glm
{




 typedef qua<float, defaultp> quat;


}
# 22 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_float_precision.hpp" 1
# 11 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_float_precision.hpp"
       
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_float_precision.hpp"
namespace glm
{




 typedef qua<float, lowp> lowp_quat;


 typedef qua<float, mediump> mediump_quat;


 typedef qua<float, highp> highp_quat;


}
# 23 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_double.hpp" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_double.hpp"
       
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_double.hpp"
namespace glm
{




 typedef qua<double, defaultp> dquat;


}
# 24 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_double_precision.hpp" 1
# 11 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_double_precision.hpp"
       
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_double_precision.hpp"
namespace glm
{






 typedef qua<double, lowp> lowp_dquat;




 typedef qua<double, mediump> mediump_dquat;




 typedef qua<double, highp> highp_dquat;


}
# 25 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_trigonometric.hpp" 1
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_trigonometric.hpp"
       
# 31 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_trigonometric.hpp"
namespace glm
{







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T angle(qua<T, Q> const& x);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> axis(qua<T, Q> const& x);
# 57 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_trigonometric.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& axis);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_trigonometric.inl" 1


namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T angle(qua<T, Q> const& x)
 {
  if (abs(x.w) > cos_one_over_two<T>())
  {
   return asin(sqrt(x.x * x.x + x.y * x.y + x.z * x.z)) * static_cast<T>(2);
  }

  return acos(x.w) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> axis(qua<T, Q> const& x)
 {
  T const tmp1 = static_cast<T>(1) - x.w * x.w;
  if(tmp1 <= static_cast<T>(0))
   return vec<3, T, Q>(0, 0, 1);
  T const tmp2 = static_cast<T>(1) / sqrt(tmp1);
  return vec<3, T, Q>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& v)
 {
  T const a(angle);
  T const s = glm::sin(a * static_cast<T>(0.5));

  return qua<T, Q>(glm::cos(a * static_cast<T>(0.5)), v * s);
 }
}
# 64 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_trigonometric.hpp" 2
# 28 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_transform.hpp" 1
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_transform.hpp"
       
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_transform.hpp"
namespace glm
{
# 42 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_transform.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& axis);

}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_transform.inl" 1
namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> Tmp = v;


  T len = glm::length(Tmp);
  if(abs(len - static_cast<T>(1)) > static_cast<T>(0.001))
  {
   T oneOverLen = static_cast<T>(1) / len;
   Tmp.x *= oneOverLen;
   Tmp.y *= oneOverLen;
   Tmp.z *= oneOverLen;
  }

  T const AngleRad(angle);
  T const Sin = sin(AngleRad * static_cast<T>(0.5));

  return q * qua<T, Q>(cos(AngleRad * static_cast<T>(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
 }
}
# 48 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../ext/quaternion_transform.hpp" 2
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 38 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp"
namespace glm
{
# 49 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> eulerAngles(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T roll(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T pitch(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T yaw(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> quat_cast(mat<3, 3, T, Q> const& x);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> quat_cast(mat<4, 4, T, Q> const& x);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> quatLookAt(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> quatLookAtRH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> quatLookAtLH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);

}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl" 1



# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/epsilon.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/epsilon.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/../detail/setup.hpp" 1
# 18 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/epsilon.hpp" 2






namespace glm
{







 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 __attribute__((device)) __attribute__((host)) bool epsilonEqual(genType const& x, genType const& y, genType const& epsilon);





 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 __attribute__((device)) __attribute__((host)) bool epsilonNotEqual(genType const& x, genType const& y, genType const& epsilon);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/epsilon.inl" 1






namespace glm
{
 template<>
 __attribute__((device)) __attribute__((host)) inline bool epsilonEqual
 (
  float const& x,
  float const& y,
  float const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<>
 __attribute__((device)) __attribute__((host)) inline bool epsilonEqual
 (
  double const& x,
  double const& y,
  double const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<>
 __attribute__((device)) __attribute__((host)) inline bool epsilonNotEqual(float const& x, float const& y, float const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<>
 __attribute__((device)) __attribute__((host)) inline bool epsilonNotEqual(double const& x, double const& y, double const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> epsilonEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> epsilonNotEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 61 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/epsilon.hpp" 2
# 5 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl" 2


namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> eulerAngles(qua<T, Q> const& x)
 {
  return vec<3, T, Q>(pitch(x), yaw(x), roll(x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T roll(qua<T, Q> const& q)
 {
  return static_cast<T>(atan(static_cast<T>(2) * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T pitch(qua<T, Q> const& q)
 {

  T const y = static_cast<T>(2) * (q.y * q.z + q.w * q.x);
  T const x = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(static_cast<T>(2) * atan(q.x, q.w));

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T yaw(qua<T, Q> const& q)
 {
  return asin(clamp(static_cast<T>(-2) * (q.x * q.z - q.w * q.y), static_cast<T>(-1), static_cast<T>(1)));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& q)
 {
  mat<3, 3, T, Q> Result(T(1));
  T qxx(q.x * q.x);
  T qyy(q.y * q.y);
  T qzz(q.z * q.z);
  T qxz(q.x * q.z);
  T qxy(q.x * q.y);
  T qyz(q.y * q.z);
  T qwx(q.w * q.x);
  T qwy(q.w * q.y);
  T qwz(q.w * q.z);

  Result[0][0] = T(1) - T(2) * (qyy + qzz);
  Result[0][1] = T(2) * (qxy + qwz);
  Result[0][2] = T(2) * (qxz - qwy);

  Result[1][0] = T(2) * (qxy - qwz);
  Result[1][1] = T(1) - T(2) * (qxx + qzz);
  Result[1][2] = T(2) * (qyz + qwx);

  Result[2][0] = T(2) * (qxz + qwy);
  Result[2][1] = T(2) * (qyz - qwx);
  Result[2][2] = T(1) - T(2) * (qxx + qyy);
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& q)
 {
  return mat<4, 4, T, Q>(mat3_cast(q));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> quat_cast(mat<3, 3, T, Q> const& m)
 {
  T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
  T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
  T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
  T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

  int biggestIndex = 0;
  T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
  if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourXSquaredMinus1;
   biggestIndex = 1;
  }
  if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourYSquaredMinus1;
   biggestIndex = 2;
  }
  if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourZSquaredMinus1;
   biggestIndex = 3;
  }

  T biggestVal = sqrt(fourBiggestSquaredMinus1 + static_cast<T>(1)) * static_cast<T>(0.5);
  T mult = static_cast<T>(0.25) / biggestVal;

  switch(biggestIndex)
  {
  case 0:
   return qua<T, Q>(biggestVal, (m[1][2] - m[2][1]) * mult, (m[2][0] - m[0][2]) * mult, (m[0][1] - m[1][0]) * mult);
  case 1:
   return qua<T, Q>((m[1][2] - m[2][1]) * mult, biggestVal, (m[0][1] + m[1][0]) * mult, (m[2][0] + m[0][2]) * mult);
  case 2:
   return qua<T, Q>((m[2][0] - m[0][2]) * mult, (m[0][1] + m[1][0]) * mult, biggestVal, (m[1][2] + m[2][1]) * mult);
  case 3:
   return qua<T, Q>((m[0][1] - m[1][0]) * mult, (m[2][0] + m[0][2]) * mult, (m[1][2] + m[2][1]) * mult, biggestVal);
  default:
   
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl" 3 4
  ((
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl"
  false
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl" 3 4
  ) ? static_cast<void> (0) : __assert_fail (
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl"
  "false"
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl" 3 4
  , "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl", 114, __PRETTY_FUNCTION__))
# 114 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.inl"
               ;
   return qua<T, Q>(1, 0, 0, 0);
  }
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> quat_cast(mat<4, 4, T, Q> const& m4)
 {
  return quat_cast(mat<3, 3, T, Q>(m4));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }


 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> quatLookAt(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {



   return quatLookAtRH(direction, up);

 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> quatLookAtRH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = -direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> quatLookAtLH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }
}
# 174 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../gtc/quaternion.hpp" 2
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../ext/quaternion_exponential.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../ext/quaternion_exponential.hpp"
       
# 27 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../ext/quaternion_exponential.hpp"
namespace glm
{







 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> exp(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> log(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> pow(qua<T, Q> const& q, T y);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> sqrt(qua<T, Q> const& q);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../ext/quaternion_exponential.inl" 1


namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> exp(qua<T, Q> const& q)
 {
  vec<3, T, Q> u(q.x, q.y, q.z);
  T const Angle = glm::length(u);
  if (Angle < epsilon<T>())
   return qua<T, Q>();

  vec<3, T, Q> const v(u / Angle);
  return qua<T, Q>(cos(Angle), sin(Angle) * v);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> log(qua<T, Q> const& q)
 {
  vec<3, T, Q> u(q.x, q.y, q.z);
  T Vec3Len = length(u);

  if (Vec3Len < epsilon<T>())
  {
   if(q.w > static_cast<T>(0))
    return qua<T, Q>(log(q.w), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
   else if(q.w < static_cast<T>(0))
    return qua<T, Q>(log(-q.w), pi<T>(), static_cast<T>(0), static_cast<T>(0));
   else
    return qua<T, Q>(std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity(), std::numeric_limits<T>::infinity());
  }
  else
  {
   T t = atan(Vec3Len, T(q.w)) / Vec3Len;
   T QuatLen2 = Vec3Len * Vec3Len + q.w * q.w;
   return qua<T, Q>(static_cast<T>(0.5) * log(QuatLen2), t * q.x, t * q.y, t * q.z);
  }
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> pow(qua<T, Q> const& x, T y)
 {


  if(y > -epsilon<T>() && y < epsilon<T>())
   return qua<T, Q>(1,0,0,0);


  T magnitude = sqrt(x.x * x.x + x.y * x.y + x.z * x.z + x.w *x.w);

  T Angle;
  if(abs(x.w / magnitude) > cos_one_over_two<T>())
  {




   T VectorMagnitude = x.x * x.x + x.y * x.y + x.z * x.z;




   if (VectorMagnitude < std::numeric_limits<T>::min()) {

    return qua<T, Q>(pow(x.w, y), 0, 0, 0);
   }

   Angle = asin(sqrt(VectorMagnitude) / magnitude);
  }
  else
  {

   Angle = acos(x.w / magnitude);
  }

  T NewAngle = Angle * y;
  T Div = sin(NewAngle) / sin(Angle);
  T Mag = pow(magnitude, y - static_cast<T>(1));
  return qua<T, Q>(cos(NewAngle) * magnitude * Mag, x.x * Div * Mag, x.y * Div * Mag, x.z * Div * Mag);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> sqrt(qua<T, Q> const& x)
 {
  return pow(x, static_cast<T>(0.5));
 }
}
# 64 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../ext/quaternion_exponential.hpp" 2
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp" 2
# 31 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp"
namespace glm
{






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr qua<T, Q> quat_identity();




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> cross(
  qua<T, Q> const& q,
  vec<3, T, Q> const& v);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> cross(
  vec<3, T, Q> const& v,
  qua<T, Q> const& q);





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> squad(
  qua<T, Q> const& q1,
  qua<T, Q> const& q2,
  qua<T, Q> const& s1,
  qua<T, Q> const& s2,
  T const& h);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> intermediate(
  qua<T, Q> const& prev,
  qua<T, Q> const& curr,
  qua<T, Q> const& next);
# 89 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp"
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<3, T, Q> rotate(
  qua<T, Q> const& q,
  vec<3, T, Q> const& v);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<4, T, Q> rotate(
  qua<T, Q> const& q,
  vec<4, T, Q> const& v);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T extractRealComponent(
  qua<T, Q> const& q);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<3, 3, T, Q> toMat3(
  qua<T, Q> const& x){return mat3_cast(x);}




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> toMat4(
  qua<T, Q> const& x){return mat4_cast(x);}




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> toQuat(
  mat<3, 3, T, Q> const& x){return quat_cast(x);}




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> toQuat(
  mat<4, 4, T, Q> const& x){return quat_cast(x);}




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> shortMix(
  qua<T, Q> const& x,
  qua<T, Q> const& y,
  T const& a);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> fastMix(
  qua<T, Q> const& x,
  qua<T, Q> const& y,
  T const& a);






 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) qua<T, Q> rotation(
  vec<3, T, Q> const& orig,
  vec<3, T, Q> const& dest);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) constexpr T length2(qua<T, Q> const& q);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.inl" 1





namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr qua<T, Q> quat_identity()
 {
  return qua<T, Q>(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> cross(vec<3, T, Q> const& v, qua<T, Q> const& q)
 {
  return inverse(q) * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> cross(qua<T, Q> const& q, vec<3, T, Q> const& v)
 {
  return q * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> squad
 (
  qua<T, Q> const& q1,
  qua<T, Q> const& q2,
  qua<T, Q> const& s1,
  qua<T, Q> const& s2,
  T const& h)
 {
  return mix(mix(q1, q2, h), mix(s1, s2, h), static_cast<T>(2) * (static_cast<T>(1) - h) * h);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> intermediate
 (
  qua<T, Q> const& prev,
  qua<T, Q> const& curr,
  qua<T, Q> const& next
 )
 {
  qua<T, Q> invQuat = inverse(curr);
  return exp((log(next * invQuat) + log(prev * invQuat)) / static_cast<T>(-4)) * curr;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<3, T, Q> rotate(qua<T, Q> const& q, vec<3, T, Q> const& v)
 {
  return q * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<4, T, Q> rotate(qua<T, Q> const& q, vec<4, T, Q> const& v)
 {
  return q * v;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T extractRealComponent(qua<T, Q> const& q)
 {
  T w = static_cast<T>(1) - q.x * q.x - q.y * q.y - q.z * q.z;
  if(w < T(0))
   return T(0);
  else
   return -sqrt(w);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline constexpr T length2(qua<T, Q> const& q)
 {
  return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> shortMix(qua<T, Q> const& x, qua<T, Q> const& y, T const& a)
 {
  if(a <= static_cast<T>(0)) return x;
  if(a >= static_cast<T>(1)) return y;

  T fCos = dot(x, y);
  qua<T, Q> y2(y);
  if(fCos < static_cast<T>(0))
  {
   y2 = -y;
   fCos = -fCos;
  }


  T k0, k1;
  if(fCos > (static_cast<T>(1) - epsilon<T>()))
  {
   k0 = static_cast<T>(1) - a;
   k1 = static_cast<T>(0) + a;
  }
  else
  {
   T fSin = sqrt(T(1) - fCos * fCos);
   T fAngle = atan(fSin, fCos);
   T fOneOverSin = static_cast<T>(1) / fSin;
   k0 = sin((static_cast<T>(1) - a) * fAngle) * fOneOverSin;
   k1 = sin((static_cast<T>(0) + a) * fAngle) * fOneOverSin;
  }

  return qua<T, Q>(
   k0 * x.w + k1 * y2.w,
   k0 * x.x + k1 * y2.x,
   k0 * x.y + k1 * y2.y,
   k0 * x.z + k1 * y2.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> fastMix(qua<T, Q> const& x, qua<T, Q> const& y, T const& a)
 {
  return glm::normalize(x * (static_cast<T>(1) - a) + (y * a));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline qua<T, Q> rotation(vec<3, T, Q> const& orig, vec<3, T, Q> const& dest)
 {
  T cosTheta = dot(orig, dest);
  vec<3, T, Q> rotationAxis;

  if(cosTheta >= static_cast<T>(1) - epsilon<T>()) {

   return quat_identity<T,Q>();
  }

  if(cosTheta < static_cast<T>(-1) + epsilon<T>())
  {





   rotationAxis = cross(vec<3, T, Q>(0, 0, 1), orig);
   if(length2(rotationAxis) < epsilon<T>())
    rotationAxis = cross(vec<3, T, Q>(1, 0, 0), orig);

   rotationAxis = normalize(rotationAxis);
   return angleAxis(pi<T>(), rotationAxis);
  }


  rotationAxis = cross(orig, dest);

  T s = sqrt((T(1) + cosTheta) * static_cast<T>(2));
  T invs = static_cast<T>(1) / s;

  return qua<T, Q>(
   s * static_cast<T>(0.5f),
   rotationAxis.x * invs,
   rotationAxis.y * invs,
   rotationAxis.z * invs);
 }
}
# 175 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/quaternion.hpp" 2
# 20 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.hpp" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/component_wise.hpp" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/component_wise.hpp"
       


# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/../detail/setup.hpp" 1
# 19 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/component_wise.hpp" 2
# 29 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/component_wise.hpp"
namespace glm
{






 template<typename floatType, length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, floatType, Q> compNormalize(vec<L, T, Q> const& v);




 template<length_t L, typename T, typename floatType, qualifier Q>
 __attribute__((device)) __attribute__((host)) vec<L, T, Q> compScale(vec<L, floatType, Q> const& v);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) typename genType::value_type compAdd(genType const& v);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) typename genType::value_type compMul(genType const& v);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) typename genType::value_type compMin(genType const& v);



 template<typename genType>
 __attribute__((device)) __attribute__((host)) typename genType::value_type compMax(genType const& v);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/component_wise.inl" 1




namespace glm{
namespace detail
{
 template<length_t L, typename T, typename floatType, qualifier Q, bool isInteger, bool signedType>
 struct compute_compNormalize
 {};

 template<length_t L, typename T, typename floatType, qualifier Q>
 struct compute_compNormalize<L, T, floatType, Q, true, true>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, floatType, Q> call(vec<L, T, Q> const& v)
  {
   floatType const Min = static_cast<floatType>(std::numeric_limits<T>::min());
   floatType const Max = static_cast<floatType>(std::numeric_limits<T>::max());
   return (vec<L, floatType, Q>(v) - Min) / (Max - Min) * static_cast<floatType>(2) - static_cast<floatType>(1);
  }
 };

 template<length_t L, typename T, typename floatType, qualifier Q>
 struct compute_compNormalize<L, T, floatType, Q, true, false>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, floatType, Q> call(vec<L, T, Q> const& v)
  {
   return vec<L, floatType, Q>(v) / static_cast<floatType>(std::numeric_limits<T>::max());
  }
 };

 template<length_t L, typename T, typename floatType, qualifier Q>
 struct compute_compNormalize<L, T, floatType, Q, false, true>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, floatType, Q> call(vec<L, T, Q> const& v)
  {
   return v;
  }
 };

 template<length_t L, typename T, typename floatType, qualifier Q, bool isInteger, bool signedType>
 struct compute_compScale
 {};

 template<length_t L, typename T, typename floatType, qualifier Q>
 struct compute_compScale<L, T, floatType, Q, true, true>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, floatType, Q> const& v)
  {
   floatType const Max = static_cast<floatType>(std::numeric_limits<T>::max()) + static_cast<floatType>(0.5);
   vec<L, floatType, Q> const Scaled(v * Max);
   vec<L, T, Q> const Result(Scaled - static_cast<floatType>(0.5));
   return Result;
  }
 };

 template<length_t L, typename T, typename floatType, qualifier Q>
 struct compute_compScale<L, T, floatType, Q, true, false>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, floatType, Q> const& v)
  {
   return vec<L, T, Q>(vec<L, floatType, Q>(v) * static_cast<floatType>(std::numeric_limits<T>::max()));
  }
 };

 template<length_t L, typename T, typename floatType, qualifier Q>
 struct compute_compScale<L, T, floatType, Q, false, true>
 {
  __attribute__((device)) __attribute__((host)) inline static vec<L, T, Q> call(vec<L, floatType, Q> const& v)
  {
   return v;
  }
 };
}

 template<typename floatType, length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, floatType, Q> compNormalize(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<floatType>::is_iec559, "'compNormalize' accepts only floating-point types for 'floatType' template parameter");

  return detail::compute_compNormalize<L, T, floatType, Q, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
 }

 template<typename T, length_t L, typename floatType, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline vec<L, T, Q> compScale(vec<L, floatType, Q> const& v)
 {
  static_assert(std::numeric_limits<floatType>::is_iec559, "'compScale' accepts only floating-point types for 'floatType' template parameter");

  return detail::compute_compScale<L, T, floatType, Q, std::numeric_limits<T>::is_integer, std::numeric_limits<T>::is_signed>::call(v);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T compAdd(vec<L, T, Q> const& v)
 {
  T Result(0);
  for(length_t i = 0, n = v.length(); i < n; ++i)
   Result += v[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T compMul(vec<L, T, Q> const& v)
 {
  T Result(1);
  for(length_t i = 0, n = v.length(); i < n; ++i)
   Result *= v[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T compMin(vec<L, T, Q> const& v)
 {
  T Result(v[0]);
  for(length_t i = 1, n = v.length(); i < n; ++i)
   Result = min(Result, v[i]);
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T compMax(vec<L, T, Q> const& v)
 {
  T Result(v[0]);
  for(length_t i = 1, n = v.length(); i < n; ++i)
   Result = max(Result, v[i]);
  return Result;
 }
}
# 70 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/../gtx/component_wise.hpp" 2
# 21 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.hpp" 2
# 30 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.hpp"
namespace glm
{





 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T length2(vec<L, T, Q> const& x);



 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T distance2(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T l1Norm(vec<3, T, Q> const& x, vec<3, T, Q> const& y);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T l1Norm(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T l2Norm(vec<3, T, Q> const& x, vec<3, T, Q> const& y);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T l2Norm(vec<3, T, Q> const& x);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T lxNorm(vec<3, T, Q> const& x, vec<3, T, Q> const& y, unsigned int Depth);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T lxNorm(vec<3, T, Q> const& x, unsigned int Depth);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T lMaxNorm(vec<3, T, Q> const& x, vec<3, T, Q> const& y);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) T lMaxNorm(vec<3, T, Q> const& x);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.inl" 1




namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_length2
 {
  __attribute__((device)) __attribute__((host)) inline static T call(vec<L, T, Q> const& v)
  {
   return dot(v, v);
  }
 };
}

 template<typename genType>
 __attribute__((device)) __attribute__((host)) inline genType length2(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length2' accepts only floating-point inputs");
  return x * x;
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T length2(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length2' accepts only floating-point inputs");
  return detail::compute_length2<L, T, Q, detail::is_aligned<Q>::value>::call(v);
 }

 template<typename T>
 __attribute__((device)) __attribute__((host)) inline T distance2(T p0, T p1)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'distance2' accepts only floating-point inputs");
  return length2(p1 - p0);
 }

 template<length_t L, typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T distance2(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'distance2' accepts only floating-point inputs");
  return length2(p1 - p0);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T l1Norm(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
 {
  return abs(b.x - a.x) + abs(b.y - a.y) + abs(b.z - a.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T l1Norm(vec<3, T, Q> const& v)
 {
  return abs(v.x) + abs(v.y) + abs(v.z);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T l2Norm(vec<3, T, Q> const& a, vec<3, T, Q> const& b
 )
 {
  return length(b - a);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T l2Norm(vec<3, T, Q> const& v)
 {
  return length(v);
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T lxNorm(vec<3, T, Q> const& x, vec<3, T, Q> const& y, unsigned int Depth)
 {
  return pow(pow(abs(y.x - x.x), T(Depth)) + pow(abs(y.y - x.y), T(Depth)) + pow(abs(y.z - x.z), T(Depth)), T(1) / T(Depth));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T lxNorm(vec<3, T, Q> const& v, unsigned int Depth)
 {
  return pow(pow(abs(v.x), T(Depth)) + pow(abs(v.y), T(Depth)) + pow(abs(v.z), T(Depth)), T(1) / T(Depth));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T lMaxNorm(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
 {
  return compMax(abs(b - a));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline T lMaxNorm(vec<3, T, Q> const& v)
 {
  return compMax(abs(v));
 }

}
# 89 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/norm.hpp" 2
# 9 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2

# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/entity_struct.h" 1

       
# 17 "/beegfs/teran_parrales/NVISII/include/nvisii/entity_struct.h"
struct EntityStruct {
 int32_t initialized = 0;
 int32_t transform_id = -1;
 int32_t camera_id = -1;
 int32_t material_id = -1;
 int32_t light_id = -1;
 int32_t mesh_id = -1;
 int32_t volume_id = -1;
 uint32_t flags = (uint32_t)-1;
 glm::vec4 bbmin = glm::vec4(0.f);
 glm::vec4 bbmax = glm::vec4(0.f);
};
# 11 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/transform_struct.h" 1

       


using namespace glm;


struct TransformStruct
{

    mat4 localToWorld;
    mat4 localToWorldPrev;
# 26 "/beegfs/teran_parrales/NVISII/include/nvisii/transform_struct.h"
};
# 12 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/material_struct.h" 1

       




using namespace glm;


struct MaterialStruct {
    int32_t transmission_roughness_texture_id = -1;
    int32_t base_color_texture_id = -1;
    int32_t roughness_texture_id = -1;
    int32_t alpha_texture_id = -1;
    int32_t normal_map_texture_id = -1;
    int32_t subsurface_color_texture_id = -1;
    int32_t subsurface_radius_texture_id = -1;
    int32_t subsurface_texture_id = -1;
    int32_t metallic_texture_id = -1;
    int32_t specular_texture_id = -1;
    int32_t specular_tint_texture_id = -1;
    int32_t anisotropic_texture_id = -1;
    int32_t anisotropic_rotation_texture_id = -1;
    int32_t sheen_texture_id = -1;
    int32_t sheen_tint_texture_id = -1;
    int32_t clearcoat_texture_id = -1;
    int32_t clearcoat_roughness_texture_id = -1;
    int32_t ior_texture_id = -1;
    int32_t transmission_texture_id = -1;

    int8_t transmission_roughness_texture_channel = 0;
    int8_t roughness_texture_channel = 0;
    int8_t alpha_texture_channel = 0;
    int8_t normal_map_texture_channel = 0;
    int8_t subsurface_texture_channel = 0;
    int8_t metallic_texture_channel = 01;
    int8_t specular_texture_channel = 0;
    int8_t specular_tint_texture_channel = 0;
    int8_t anisotropic_texture_channel = 0;
    int8_t anisotropic_rotation_texture_channel = 0;
    int8_t sheen_texture_channel = 0;
    int8_t sheen_tint_texture_channel = 0;
    int8_t clearcoat_texture_channel = 0;
    int8_t clearcoat_roughness_texture_channel = 0;
    int8_t ior_texture_channel = 0;
    int8_t transmission_texture_channel = 0;
};
# 13 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/camera_struct.h" 1

       






using namespace glm;


struct CameraStruct
{
    mat4 view;
    mat4 proj;
    mat4 viewinv;
    mat4 projinv;
    mat4 viewproj;

    float fov;
    float focalDistance;
    float apertureDiameter;
    int tex_id;
};
# 14 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/mesh_struct.h" 1

       


using namespace glm;


struct MeshStruct {

    vec4 center;


    vec4 bbmin;
    vec4 bbmax;


    float bounding_sphere_radius;
    int32_t show_bounding_box;
    int32_t numTris;
    int32_t numVerts;
};
# 15 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/light_struct.h" 1

       



using namespace glm;

struct LightStruct {
    float r = 0.f;
    float g = 0.f;
    float b = 0.f;
    float intensity = 1.f;
    float exposure = 0.f;
    float falloff = 2.f;
    int32_t color_texture_id = -1;
    bool use_surface_area = false;
};
# 16 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/texture_struct.h" 1

       







using namespace glm;

struct TextureStruct
{
    int32_t width = -1;
    int32_t height = -1;
    vec2 scale = vec2(1.f, 1.f);
    bool rightHanded = true;
};
# 17 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2
# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/volume_struct.h" 1

       







# 1 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 1
# 130 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/stdlib.h" 1 3
# 131 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/lib/gcc/x86_64-pc-linux-gnu/11.3.0/include/stddef.h" 1 3 4
# 133 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 1 3
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3
       
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 65 "/usr/include/assert.h" 3 4

# 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cassert" 2 3
# 134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
# 135 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cmath" 3
# 136 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 2
# 165 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"

# 165 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
namespace nanovdb {




template<typename T1, typename T2>
struct is_same
{
    static const bool value = false;
};

template<typename T>
struct is_same<T, T>
{
    static const bool value = true;
};




template <bool, typename T = void>
struct enable_if
{
};

template <typename T>
struct enable_if<true, T>
{
    using type = T;
};




template<typename T>
struct is_floating_point
{
    static const bool value = is_same<T, float>::value || is_same<T, double>::value;
};
# 212 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
template<typename AnyType, template<typename...> class TemplateType>
struct is_specialization
{
    static const bool value = false;
};
template<typename... Args, template<typename...> class TemplateType>
struct is_specialization<TemplateType<Args...>, TemplateType>
{
    static const bool value = true;
};




class ValueMask
{
};


class Half
{
};




struct PackedRGBA8
{
    union {
        uint32_t packed;
        uint8_t c[4];
        struct {uint8_t r, g, b, a;};
    };
    static const int SIZE = 4;
    using ValueType = uint8_t;

    PackedRGBA8(const PackedRGBA8&) = default;
    PackedRGBA8(PackedRGBA8&&) = default;
    PackedRGBA8& operator=(PackedRGBA8&&) = default;
    PackedRGBA8& operator=(const PackedRGBA8&) = default;
    __attribute__((host)) __attribute__((device)) PackedRGBA8() : packed(0) {static_assert(sizeof(uint32_t) == sizeof(PackedRGBA8),"Unexpected sizeof");}
    __attribute__((host)) __attribute__((device)) PackedRGBA8(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a = 255u) : c{_r, _g, _b, _a} {}
    explicit __attribute__((host)) __attribute__((device)) PackedRGBA8(uint8_t v) : PackedRGBA8(v,v,v,v) {}
    __attribute__((host)) __attribute__((device)) PackedRGBA8(float _r, float _g, float _b, float _a = 1.0f)
        : c{(uint8_t(_r * 255.0f)), (uint8_t(_g * 255.0f)), (uint8_t(_b * 255.0f)), (uint8_t(_a * 255.0f))} {}
    __attribute__((host)) __attribute__((device)) bool operator<(const PackedRGBA8& rhs) const { return packed < rhs.packed; }
    __attribute__((host)) __attribute__((device)) bool operator==(const PackedRGBA8& rhs) const { return packed == rhs.packed; }
    __attribute__((host)) __attribute__((device)) uint8_t lengthSqr() const { return (c[0]*c[0] + c[1]*c[1] + c[2]*c[2]) / (256 * 256 *256); }
    __attribute__((host)) __attribute__((device)) uint8_t length() const { return sqrtf(lengthSqr()); }
    __attribute__((host)) __attribute__((device)) const uint8_t& operator[](int n) const { return c[n]; }
    __attribute__((host)) __attribute__((device)) uint8_t& operator[](int n) { return c[n]; }
};
# 275 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
enum class GridType : uint32_t { Unknown = 0,
                                 Float = 1,
                                 Double = 2,
                                 Int16 = 3,
                                 Int32 = 4,
                                 Int64 = 5,
                                 Vec3f = 6,
                                 Vec3d = 7,
                                 Mask = 8,
                                 FP16 = 9,
                                 UInt32 = 10,
                                 Boolean = 11,
                                 PackedRGBA8 = 12,
                                 End = 13 };



inline const char* toStr(GridType gridType)
{
    static const char * LUT[] = { "?", "float", "double" , "int16", "int32",
                                 "int64", "Vec3f", "Vec3d", "Mask", "Half",
                                 "uint32", "bool", "RGBA8", "END" };
    static_assert( sizeof(LUT)/sizeof(char*) - 1 == int(GridType::End), "Unexpected size of LUT" );
    return LUT[static_cast<int>(gridType)];
}





enum class GridClass : uint32_t { Unknown = 0,
                                  LevelSet = 1,
                                  FogVolume = 2,
                                  Staggered = 3,
                                  PointIndex = 4,
                                  PointData = 5,
                                  Topology = 6,
                                  VoxelVolume = 7,
                                  End = 8 };



inline const char* toStr(GridClass gridClass)
{
    static const char * LUT[] = { "?", "SDF", "FOG" , "MAC", "PNTIDX",
                                 "PNTDAT", "TOPO", "VOX", "END" };
    static_assert( sizeof(LUT)/sizeof(char*) - 1 == int(GridClass::End), "Unexpected size of LUT" );
    return LUT[static_cast<int>(gridClass)];
}





inline __attribute__((host)) __attribute__((device)) bool isValid(GridType gridType, GridClass gridClass)
{
    if (gridClass == GridClass::LevelSet || gridClass == GridClass::FogVolume) {
        return gridType == GridType::Float || gridType == GridType::Double;
    } else if (gridClass == GridClass::Staggered) {
        return gridType == GridType::Vec3f || gridType == GridType::Vec3d;
    } else if (gridClass == GridClass::PointIndex || gridClass == GridClass::PointData) {
        return gridType == GridType::UInt32;
    } else if (gridClass == GridClass::VoxelVolume) {
        return gridType == GridType::PackedRGBA8 || gridType == GridType::Float || gridType == GridType::Double || gridType == GridType::Vec3f || gridType == GridType::Vec3d || gridType == GridType::UInt32;
    }
    return gridClass < GridClass::End && gridType < GridType::End;
}




enum class GridFlags : uint32_t {
    HasLongGridName = 1 << 0,
    HasBBox = 1 << 1,
    HasMinMax = 1 << 2,
    HasAverage = 1 << 3,
    HasStdDeviation = 1 << 4,
    End = 1 << 5,
};



inline const char* toStr(GridFlags gridFlags)
{
    static const char * LUT[] = { "has long grid name", "has bbox", "has min/max" ,
                                  "has average", "has standard deviation", "END" };
    static_assert( 1 << (sizeof(LUT)/sizeof(char*) - 1) == int(GridFlags::End), "Unexpected size of LUT" );
    return LUT[static_cast<int>(gridFlags)];
}





enum class GridBlindDataClass : uint32_t { Unknown = 0,
                                           IndexArray = 1,
                                           AttributeArray = 2,
                                           GridName = 3,
                                           End = 4 };


enum class GridBlindDataSemantic : uint32_t { Unknown = 0,
                                              PointPosition = 1,
                                              PointColor = 2,
                                              PointNormal = 3,
                                              PointRadius = 4,
                                              PointVelocity = 5,
                                              PointId = 6,
                                              End = 7 };






class Version
{
    uint32_t mData;
public:
    __attribute__((host)) __attribute__((device)) Version() : mData( uint32_t(29) << 21 |
                                   uint32_t(3) << 10 |
                                   uint32_t(0) )
    {
    }
    __attribute__((host)) __attribute__((device)) Version(uint32_t major, uint32_t minor, uint32_t patch)
        : mData( major << 21 | minor << 10 | patch )
    {
        
# 402 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 402 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       major < (1u << 11)
# 402 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 402 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "major < (1u << 11)"
# 402 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 402, __PRETTY_FUNCTION__))
# 402 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                         ;
        
# 403 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 403 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       minor < (1u << 11)
# 403 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 403 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "minor < (1u << 11)"
# 403 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 403, __PRETTY_FUNCTION__))
# 403 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                         ;
        
# 404 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 404 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       patch < (1u << 10)
# 404 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 404 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "patch < (1u << 10)"
# 404 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 404, __PRETTY_FUNCTION__))
# 404 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                         ;
    }
    __attribute__((host)) __attribute__((device)) bool operator==(const Version &rhs) const {return mData == rhs.mData;}
    __attribute__((host)) __attribute__((device)) bool operator< (const Version &rhs) const {return mData < rhs.mData;}
    __attribute__((host)) __attribute__((device)) bool operator<=(const Version &rhs) const {return mData <= rhs.mData;}
    __attribute__((host)) __attribute__((device)) bool operator> (const Version &rhs) const {return mData > rhs.mData;}
    __attribute__((host)) __attribute__((device)) bool operator>=(const Version &rhs) const {return mData >= rhs.mData;}
    __attribute__((host)) __attribute__((device)) uint32_t id() const { return mData; }
    __attribute__((host)) __attribute__((device)) uint32_t getMajor() const { return (mData >> 21) & ((1u << 11) - 1);}
    __attribute__((host)) __attribute__((device)) uint32_t getMinor() const { return (mData >> 10) & ((1u << 11) - 1);}
    __attribute__((host)) __attribute__((device)) uint32_t getPatch() const { return mData & ((1u << 10) - 1);}


    const char* c_str() const
    {
        char *buffer = (char*)malloc(4 + 1 + 4 + 1 + 4 + 1);
        sprintf(buffer, "%d.%d.%d", this->getMajor(), this->getMinor(), this->getPatch());
        return buffer;
    }

};





template<typename T>
struct Tolerance;
template<>
struct Tolerance<float>
{
    __attribute__((host)) __attribute__((device)) static float value() { return 1e-8f; }
};
template<>
struct Tolerance<double>
{
    __attribute__((host)) __attribute__((device)) static double value() { return 1e-15; }
};




template<typename T>
struct Delta;
template<>
struct Delta<float>
{
    __attribute__((host)) __attribute__((device)) static float value() { return 1e-5f; }
};
template<>
struct Delta<double>
{
    __attribute__((host)) __attribute__((device)) static double value() { return 1e-9; }
};




template<typename T>
struct Maximum;

template<>
struct Maximum<int>
{
    __attribute__((host)) __attribute__((device)) static int value() { return 2147483647; }
};
template<>
struct Maximum<uint32_t>
{
    __attribute__((host)) __attribute__((device)) static uint32_t value() { return 4294967295; }
};
template<>
struct Maximum<float>
{
    __attribute__((host)) __attribute__((device)) static float value() { return 1e+38f; }
};
template<>
struct Maximum<double>
{
    __attribute__((host)) __attribute__((device)) static double value() { return 1e+308; }
};
# 494 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
template<typename Type>
__attribute__((host)) __attribute__((device)) inline bool isApproxZero(const Type& x)
{
    return !(x > Tolerance<Type>::value()) && !(x < -Tolerance<Type>::value());
}

template<typename Type>
__attribute__((host)) __attribute__((device)) inline Type Min(Type a, Type b)
{
    return (a < b) ? a : b;
}
__attribute__((host)) __attribute__((device)) inline int32_t Min(int32_t a, int32_t b)
{
    return int32_t(fminf(float(a), float(b)));
}
__attribute__((host)) __attribute__((device)) inline uint32_t Min(uint32_t a, uint32_t b)
{
    return uint32_t(fminf(float(a), float(b)));
}
__attribute__((host)) __attribute__((device)) inline float Min(float a, float b)
{
    return fminf(a, b);
}
__attribute__((host)) __attribute__((device)) inline double Min(double a, double b)
{
    return fmin(a, b);
}
template<typename Type>
__attribute__((host)) __attribute__((device)) inline Type Max(Type a, Type b)
{
    return (a > b) ? a : b;
}

__attribute__((host)) __attribute__((device)) inline int32_t Max(int32_t a, int32_t b)
{
    return int32_t(fmaxf(float(a), float(b)));
}
__attribute__((host)) __attribute__((device)) inline uint32_t Max(uint32_t a, uint32_t b)
{
    return uint32_t(fmaxf(float(a), float(b)));
}
__attribute__((host)) __attribute__((device)) inline float Max(float a, float b)
{
    return fmaxf(a, b);
}
__attribute__((host)) __attribute__((device)) inline double Max(double a, double b)
{
    return fmax(a, b);
}
__attribute__((host)) __attribute__((device)) inline float Clamp(float x, float a, float b)
{
    return Max(Min(x, b), a);
}
__attribute__((host)) __attribute__((device)) inline double Clamp(double x, double a, double b)
{
    return Max(Min(x, b), a);
}

__attribute__((host)) __attribute__((device)) inline float Fract(float x)
{
    return x - floorf(x);
}
__attribute__((host)) __attribute__((device)) inline double Fract(double x)
{
    return x - floor(x);
}

__attribute__((host)) __attribute__((device)) inline int32_t Floor(float x)
{
    return int32_t(floorf(x));
}
__attribute__((host)) __attribute__((device)) inline int32_t Floor(double x)
{
    return int32_t(floor(x));
}

__attribute__((host)) __attribute__((device)) inline int32_t Ceil(float x)
{
    return int32_t(ceilf(x));
}
__attribute__((host)) __attribute__((device)) inline int32_t Ceil(double x)
{
    return int32_t(ceil(x));
}

template<typename T>
__attribute__((host)) __attribute__((device)) inline T Pow2(T x)
{
    return x * x;
}

template<typename T>
__attribute__((host)) __attribute__((device)) inline T Abs(T x)
{
    return x < 0 ? -x : x;
}

template<>
__attribute__((host)) __attribute__((device)) inline float Abs(float x)
{
    return fabs(x);
}

template<>
__attribute__((host)) __attribute__((device)) inline double Abs(double x)
{
    return fabs(x);
}

template<>
__attribute__((host)) __attribute__((device)) inline int Abs(int x)
{
    return abs(x);
}

template<typename CoordT, typename RealT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT Round(const Vec3T<RealT>& xyz);

template<typename CoordT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT Round(const Vec3T<float>& xyz)
{
    return CoordT(int32_t(rintf(xyz[0])), int32_t(rintf(xyz[1])), int32_t(rintf(xyz[2])));


}

template<typename CoordT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT Round(const Vec3T<double>& xyz)
{
    return CoordT(int32_t(floor(xyz[0] + 0.5)), int32_t(floor(xyz[1] + 0.5)), int32_t(floor(xyz[2] + 0.5)));
}

template<typename CoordT, typename RealT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT RoundDown(const Vec3T<RealT>& xyz)
{
    return CoordT(Floor(xyz[0]), Floor(xyz[1]), Floor(xyz[2]));
}



inline __attribute__((host)) __attribute__((device)) float Sqrt(float x)
{
    return sqrtf(x);
}
inline __attribute__((host)) __attribute__((device)) double Sqrt(double x)
{
    return sqrt(x);
}



template <typename T>
inline __attribute__((host)) __attribute__((device)) T Sign(const T &x) { return ((T(0) < x)?T(1):T(0)) - ((x < T(0))?T(1):T(0)); }

template<typename Vec3T>
__attribute__((host)) __attribute__((device)) inline int MinIndex(const Vec3T& v)
{





    if (v[0] < v[1] && v[0] < v[2])
        return 0;
    if (v[1] < v[2])
        return 1;
    else
        return 2;

}

template<typename Vec3T>
__attribute__((host)) __attribute__((device)) inline int MaxIndex(const Vec3T& v)
{





    if (v[0] > v[1] && v[0] > v[2])
        return 0;
    if (v[1] > v[2])
        return 1;
    else
        return 2;

}


template<uint64_t wordSize>
__attribute__((host)) __attribute__((device)) inline uint64_t AlignUp(uint64_t byteCount)
{
    const uint64_t r = byteCount % wordSize;
    return r ? byteCount - r + wordSize : byteCount;
}




template<typename> class Vec3;


class Coord
{
    int32_t mVec[3];
public:
    using ValueType = int32_t;
    using IndexType = uint32_t;


    __attribute__((host)) __attribute__((device)) Coord()
        : mVec{0, 0, 0}
    {
    }


    __attribute__((host)) __attribute__((device)) explicit Coord(ValueType n)
        : mVec{n, n, n}
    {
    }


    __attribute__((host)) __attribute__((device)) Coord(ValueType i, ValueType j, ValueType k)
        : mVec{i, j, k}
    {
    }

    __attribute__((host)) __attribute__((device)) Coord(ValueType *ptr)
        : mVec{ptr[0], ptr[1], ptr[2]}
    {
    }

    __attribute__((host)) __attribute__((device)) int32_t x() const { return mVec[0]; }
    __attribute__((host)) __attribute__((device)) int32_t y() const { return mVec[1]; }
    __attribute__((host)) __attribute__((device)) int32_t z() const { return mVec[2]; }

    __attribute__((host)) __attribute__((device)) int32_t& x() { return mVec[0]; }
    __attribute__((host)) __attribute__((device)) int32_t& y() { return mVec[1]; }
    __attribute__((host)) __attribute__((device)) int32_t& z() { return mVec[2]; }

    __attribute__((host)) __attribute__((device)) static Coord max() { return Coord(int32_t((1u << 31) - 1)); }

    __attribute__((host)) __attribute__((device)) static Coord min() { return Coord(-int32_t((1u << 31) - 1) - 1); }

    __attribute__((host)) __attribute__((device)) static size_t memUsage() { return sizeof(Coord); }



    __attribute__((host)) __attribute__((device)) const ValueType& operator[](IndexType i) const { return mVec[i]; }



    __attribute__((host)) __attribute__((device)) ValueType& operator[](IndexType i) { return mVec[i]; }


   template <typename CoordT>
    __attribute__((host)) __attribute__((device)) Coord& operator=(const CoordT &other)
    {
        static_assert(sizeof(Coord) == sizeof(CoordT), "Mis-matched sizeof");
        mVec[0] = other[0];
        mVec[1] = other[1];
        mVec[2] = other[2];
        return *this;
    }


    __attribute__((host)) __attribute__((device)) Coord operator&(IndexType n) const { return Coord(mVec[0] & n, mVec[1] & n, mVec[2] & n); }


    __attribute__((host)) __attribute__((device)) Coord operator<<(IndexType n) const { return Coord(mVec[0] << n, mVec[1] << n, mVec[2] << n); }


    __attribute__((host)) __attribute__((device)) Coord operator>>(IndexType n) const { return Coord(mVec[0] >> n, mVec[1] >> n, mVec[2] >> n); }


    __attribute__((host)) __attribute__((device)) bool operator<(const Coord& rhs) const
    {
        return mVec[0] < rhs[0] ? true : mVec[0] > rhs[0] ? false : mVec[1] < rhs[1] ? true : mVec[1] > rhs[1] ? false : mVec[2] < rhs[2] ? true : false;
    }


    __attribute__((host)) __attribute__((device)) bool operator==(const Coord& rhs) const { return mVec[0] == rhs[0] && mVec[1] == rhs[1] && mVec[2] == rhs[2]; }
    __attribute__((host)) __attribute__((device)) bool operator!=(const Coord& rhs) const { return mVec[0] != rhs[0] || mVec[1] != rhs[1] || mVec[2] != rhs[2]; }
    __attribute__((host)) __attribute__((device)) Coord& operator&=(int n)
    {
        mVec[0] &= n;
        mVec[1] &= n;
        mVec[2] &= n;
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Coord& operator<<=(uint32_t n)
    {
        mVec[0] <<= n;
        mVec[1] <<= n;
        mVec[2] <<= n;
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Coord& operator+=(int n)
    {
        mVec[0] += n;
        mVec[1] += n;
        mVec[2] += n;
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Coord operator+(const Coord& rhs) const { return Coord(mVec[0] + rhs[0], mVec[1] + rhs[1], mVec[2] + rhs[2]); }
    __attribute__((host)) __attribute__((device)) Coord operator-(const Coord& rhs) const { return Coord(mVec[0] - rhs[0], mVec[1] - rhs[1], mVec[2] - rhs[2]); }
    __attribute__((host)) __attribute__((device)) Coord& operator+=(const Coord& rhs)
    {
        mVec[0] += rhs[0];
        mVec[1] += rhs[1];
        mVec[2] += rhs[2];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Coord& operator-=(const Coord& rhs)
    {
        mVec[0] -= rhs[0];
        mVec[1] -= rhs[1];
        mVec[2] -= rhs[2];
        return *this;
    }


    __attribute__((host)) __attribute__((device)) Coord& minComponent(const Coord& other)
    {
        if (other[0] < mVec[0])
            mVec[0] = other[0];
        if (other[1] < mVec[1])
            mVec[1] = other[1];
        if (other[2] < mVec[2])
            mVec[2] = other[2];
        return *this;
    }


    __attribute__((host)) __attribute__((device)) Coord& maxComponent(const Coord& other)
    {
        if (other[0] > mVec[0])
            mVec[0] = other[0];
        if (other[1] > mVec[1])
            mVec[1] = other[1];
        if (other[2] > mVec[2])
            mVec[2] = other[2];
        return *this;
    }



    __attribute__((host)) __attribute__((device)) static inline bool lessThan(const Coord& a, const Coord& b)
    {
        return (a[0] < b[0] || a[1] < b[1] || a[2] < b[2]);
    }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) static Coord Floor(const Vec3T& xyz) { return Coord(nanovdb::Floor(xyz[0]), nanovdb::Floor(xyz[1]), nanovdb::Floor(xyz[2])); }



    template<int Log2N = 3 + 4 + 5>
    __attribute__((host)) __attribute__((device)) uint32_t hash() const { return ((1 << Log2N) - 1) & (mVec[0] * 73856093 ^ mVec[1] * 19349663 ^ mVec[2] * 83492791); }



    __attribute__((host)) __attribute__((device)) uint8_t octant() const { return (uint8_t(bool(mVec[0] & (1u << 31)))) |
                                                (uint8_t(bool(mVec[1] & (1u << 31))) << 1) |
                                                (uint8_t(bool(mVec[2] & (1u << 31))) << 2); }


    inline __attribute__((host)) __attribute__((device)) Vec3<float> asVec3s() const;


    inline __attribute__((host)) __attribute__((device)) Vec3<double> asVec3d() const;
};




template<typename T>
class Vec3
{
    T mVec[3];

public:
    static const int SIZE = 3;
    using ValueType = T;
    Vec3() = default;
    __attribute__((host)) __attribute__((device)) explicit Vec3(T x)
        : mVec{x, x, x}
    {
    }
    __attribute__((host)) __attribute__((device)) Vec3(T x, T y, T z)
        : mVec{x, y, z}
    {
    }
    template<typename T2>
    __attribute__((host)) __attribute__((device)) explicit Vec3(const Vec3<T2>& v)
        : mVec{T(v[0]), T(v[1]), T(v[2])}
    {
    }
    __attribute__((host)) __attribute__((device)) explicit Vec3(const Coord& ijk)
        : mVec{T(ijk[0]), T(ijk[1]), T(ijk[2])}
    {
    }
    __attribute__((host)) __attribute__((device)) bool operator==(const Vec3& rhs) const { return mVec[0] == rhs[0] && mVec[1] == rhs[1] && mVec[2] == rhs[2]; }
    __attribute__((host)) __attribute__((device)) bool operator!=(const Vec3& rhs) const { return mVec[0] != rhs[0] || mVec[1] != rhs[1] || mVec[2] != rhs[2]; }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3& operator=(const Vec3T& rhs)
    {
        mVec[0] = rhs[0];
        mVec[1] = rhs[1];
        mVec[2] = rhs[2];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) const T& operator[](int i) const { return mVec[i]; }
    __attribute__((host)) __attribute__((device)) T& operator[](int i) { return mVec[i]; }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) T dot(const Vec3T& v) const { return mVec[0] * v[0] + mVec[1] * v[1] + mVec[2] * v[2]; }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3 cross(const Vec3T& v) const
    {
        return Vec3(mVec[1] * v[2] - mVec[2] * v[1],
                    mVec[2] * v[0] - mVec[0] * v[2],
                    mVec[0] * v[1] - mVec[1] * v[0]);
    }
    __attribute__((host)) __attribute__((device)) T lengthSqr() const
    {
        return mVec[0] * mVec[0] + mVec[1] * mVec[1] + mVec[2] * mVec[2];
    }
    __attribute__((host)) __attribute__((device)) T length() const { return Sqrt(this->lengthSqr()); }
    __attribute__((host)) __attribute__((device)) Vec3 operator-() const { return Vec3(-mVec[0], -mVec[1], -mVec[2]); }
    __attribute__((host)) __attribute__((device)) Vec3 operator*(const Vec3& v) const { return Vec3(mVec[0] * v[0], mVec[1] * v[1], mVec[2] * v[2]); }
    __attribute__((host)) __attribute__((device)) Vec3 operator/(const Vec3& v) const { return Vec3(mVec[0] / v[0], mVec[1] / v[1], mVec[2] / v[2]); }
    __attribute__((host)) __attribute__((device)) Vec3 operator+(const Vec3& v) const { return Vec3(mVec[0] + v[0], mVec[1] + v[1], mVec[2] + v[2]); }
    __attribute__((host)) __attribute__((device)) Vec3 operator-(const Vec3& v) const { return Vec3(mVec[0] - v[0], mVec[1] - v[1], mVec[2] - v[2]); }
    __attribute__((host)) __attribute__((device)) Vec3 operator*(const T& s) const { return Vec3(s * mVec[0], s * mVec[1], s * mVec[2]); }
    __attribute__((host)) __attribute__((device)) Vec3 operator/(const T& s) const { return (T(1) / s) * (*this); }
    __attribute__((host)) __attribute__((device)) Vec3& operator+=(const Vec3& v)
    {
        mVec[0] += v[0];
        mVec[1] += v[1];
        mVec[2] += v[2];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Vec3& operator-=(const Vec3& v)
    {
        mVec[0] -= v[0];
        mVec[1] -= v[1];
        mVec[2] -= v[2];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Vec3& operator*=(const T& s)
    {
        mVec[0] *= s;
        mVec[1] *= s;
        mVec[2] *= s;
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Vec3& operator/=(const T& s) { return (*this) *= T(1) / s; }
    __attribute__((host)) __attribute__((device)) Vec3& normalize() { return (*this) /= this->length(); }

    __attribute__((host)) __attribute__((device)) Vec3& minComponent(const Vec3& other)
    {
        if (other[0] < mVec[0])
            mVec[0] = other[0];
        if (other[1] < mVec[1])
            mVec[1] = other[1];
        if (other[2] < mVec[2])
            mVec[2] = other[2];
        return *this;
    }


    __attribute__((host)) __attribute__((device)) Vec3& maxComponent(const Vec3& other)
    {
        if (other[0] > mVec[0])
            mVec[0] = other[0];
        if (other[1] > mVec[1])
            mVec[1] = other[1];
        if (other[2] > mVec[2])
            mVec[2] = other[2];
        return *this;
    }

    __attribute__((host)) __attribute__((device)) ValueType min() const
    {
        return mVec[0] < mVec[1] ? (mVec[0] < mVec[2] ? mVec[0] : mVec[2]) : (mVec[1] < mVec[2] ? mVec[1] : mVec[2]);
    }

    __attribute__((host)) __attribute__((device)) ValueType max() const
    {
        return mVec[0] > mVec[1] ? (mVec[0] > mVec[2] ? mVec[0] : mVec[2]) : (mVec[1] > mVec[2] ? mVec[1] : mVec[2]);
    }
    __attribute__((host)) __attribute__((device)) Coord floor() const { return Coord(Floor(mVec[0]), Floor(mVec[1]), Floor(mVec[2])); }
    __attribute__((host)) __attribute__((device)) Coord ceil() const { return Coord(Ceil(mVec[0]), Ceil(mVec[1]), Ceil(mVec[2])); }
    __attribute__((host)) __attribute__((device)) Coord round() const { return Coord(Floor(mVec[0] + 0.5), Floor(mVec[1] + 0.5), Floor(mVec[2] + 0.5)); }
};

template<typename T1, typename T2>
inline __attribute__((host)) __attribute__((device)) Vec3<T2> operator*(T1 scalar, const Vec3<T2>& vec)
{
    return Vec3<T2>(scalar * vec[0], scalar * vec[1], scalar * vec[2]);
}
template<typename T1, typename T2>
inline __attribute__((host)) __attribute__((device)) Vec3<T2> operator/(T1 scalar, const Vec3<T2>& vec)
{
    return Vec3<T2>(scalar / vec[0], scalar / vec[1], scalar / vec[2]);
}

using Vec3R = Vec3<double>;
using Vec3d = Vec3<double>;
using Vec3f = Vec3<float>;
using Vec3i = Vec3<int>;


Vec3f Coord::asVec3s() const { return Vec3f(float(mVec[0]), float(mVec[1]), float(mVec[2])); }


Vec3d Coord::asVec3d() const { return Vec3d(double(mVec[0]), double(mVec[1]), double(mVec[2])); }




template<typename T>
class Vec4
{
    T mVec[4];

public:
    static const int SIZE = 4;
    using ValueType = T;
    Vec4() = default;
    __attribute__((host)) __attribute__((device)) explicit Vec4(T x)
        : mVec{x, x, x, x}
    {
    }
    __attribute__((host)) __attribute__((device)) Vec4(T x, T y, T z, T w)
        : mVec{x, y, z, w}
    {
    }
    template<typename T2>
    __attribute__((host)) __attribute__((device)) explicit Vec4(const Vec4<T2>& v)
        : mVec{T(v[0]), T(v[1]), T(v[2]), T(v[3])}
    {
    }
    __attribute__((host)) __attribute__((device)) bool operator==(const Vec4& rhs) const { return mVec[0] == rhs[0] && mVec[1] == rhs[1] && mVec[2] == rhs[2] && mVec[3] == rhs[3]; }
    __attribute__((host)) __attribute__((device)) bool operator!=(const Vec4& rhs) const { return mVec[0] != rhs[0] || mVec[1] != rhs[1] || mVec[2] != rhs[2] || mVec[3] != rhs[3]; }
    template<typename Vec4T>
    __attribute__((host)) __attribute__((device)) Vec4& operator=(const Vec4T& rhs)
    {
        mVec[0] = rhs[0];
        mVec[1] = rhs[1];
        mVec[2] = rhs[2];
        mVec[3] = rhs[3];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) const T& operator[](int i) const { return mVec[i]; }
    __attribute__((host)) __attribute__((device)) T& operator[](int i) { return mVec[i]; }
    template<typename Vec4T>
    __attribute__((host)) __attribute__((device)) T dot(const Vec4T& v) const { return mVec[0] * v[0] + mVec[1] * v[1] + mVec[2] * v[2] + mVec[3] * v[3]; }
    __attribute__((host)) __attribute__((device)) T lengthSqr() const
    {
        return mVec[0] * mVec[0] + mVec[1] * mVec[1] + mVec[2] * mVec[2] + mVec[3] * mVec[3];
    }
    __attribute__((host)) __attribute__((device)) T length() const { return Sqrt(this->lengthSqr()); }
    __attribute__((host)) __attribute__((device)) Vec4 operator-() const { return Vec4(-mVec[0], -mVec[1], -mVec[2], -mVec[3]); }
    __attribute__((host)) __attribute__((device)) Vec4 operator*(const Vec4& v) const { return Vec4(mVec[0] * v[0], mVec[1] * v[1], mVec[2] * v[2], mVec[3] * v[3]); }
    __attribute__((host)) __attribute__((device)) Vec4 operator/(const Vec4& v) const { return Vec4(mVec[0] / v[0], mVec[1] / v[1], mVec[2] / v[2], mVec[3] / v[3]); }
    __attribute__((host)) __attribute__((device)) Vec4 operator+(const Vec4& v) const { return Vec4(mVec[0] + v[0], mVec[1] + v[1], mVec[2] + v[2], mVec[3] + v[3]); }
    __attribute__((host)) __attribute__((device)) Vec4 operator-(const Vec4& v) const { return Vec4(mVec[0] - v[0], mVec[1] - v[1], mVec[2] - v[2], mVec[3] - v[3]); }
    __attribute__((host)) __attribute__((device)) Vec4 operator*(const T& s) const { return Vec4(s * mVec[0], s * mVec[1], s * mVec[2], s * mVec[3]); }
    __attribute__((host)) __attribute__((device)) Vec4 operator/(const T& s) const { return (T(1) / s) * (*this); }
    __attribute__((host)) __attribute__((device)) Vec4& operator+=(const Vec4& v)
    {
        mVec[0] += v[0];
        mVec[1] += v[1];
        mVec[2] += v[2];
        mVec[3] += v[3];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Vec4& operator-=(const Vec4& v)
    {
        mVec[0] -= v[0];
        mVec[1] -= v[1];
        mVec[2] -= v[2];
        mVec[3] -= v[3];
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Vec4& operator*=(const T& s)
    {
        mVec[0] *= s;
        mVec[1] *= s;
        mVec[2] *= s;
        mVec[3] *= s;
        return *this;
    }
    __attribute__((host)) __attribute__((device)) Vec4& operator/=(const T& s) { return (*this) *= T(1) / s; }
    __attribute__((host)) __attribute__((device)) Vec4& normalize() { return (*this) /= this->length(); }

    __attribute__((host)) __attribute__((device)) Vec4& minComponent(const Vec4& other)
    {
        if (other[0] < mVec[0])
            mVec[0] = other[0];
        if (other[1] < mVec[1])
            mVec[1] = other[1];
        if (other[2] < mVec[2])
            mVec[2] = other[2];
        if (other[3] < mVec[3])
            mVec[3] = other[3];
        return *this;
    }


    __attribute__((host)) __attribute__((device)) Vec4& maxComponent(const Vec4& other)
    {
        if (other[0] > mVec[0])
            mVec[0] = other[0];
        if (other[1] > mVec[1])
            mVec[1] = other[1];
        if (other[2] > mVec[2])
            mVec[2] = other[2];
        if (other[3] > mVec[3])
            mVec[3] = other[3];
        return *this;
    }
};

template<typename T1, typename T2>
inline __attribute__((host)) __attribute__((device)) Vec4<T2> operator*(T1 scalar, const Vec4<T2>& vec)
{
    return Vec4<T2>(scalar * vec[0], scalar * vec[1], scalar * vec[2], scalar * vec[3]);
}
template<typename T1, typename T2>
inline __attribute__((host)) __attribute__((device)) Vec4<T2> operator/(T1 scalar, const Vec3<T2>& vec)
{
    return Vec4<T2>(scalar / vec[0], scalar / vec[1], scalar / vec[2], scalar / vec[3]);
}

using Vec4R = Vec4<double>;
using Vec4d = Vec4<double>;
using Vec4f = Vec4<float>;
using Vec4i = Vec4<int>;



template<typename T, int Rank = (is_specialization<T, Vec3>::value ||
                                 is_specialization<T, Vec4>::value ||
                                 is_same<T, PackedRGBA8>::value) ? 1 : 0>
struct TensorTraits;

template<typename T>
struct TensorTraits<T, 0>
{
    static const int Rank = 0;
    static const bool IsScalar = true;
    static const bool IsVector = false;
    static const int Size = 1;
    using ElementType = T;
    static T scalar(const T& s) { return s; }
};

template<typename T>
struct TensorTraits<T, 1>
{
    static const int Rank = 1;
    static const bool IsScalar = false;
    static const bool IsVector = true;
    static const int Size = T::SIZE;
    using ElementType = typename T::ValueType;
    static ElementType scalar(const T& v) { return v.length(); }
};



template<typename T, int = sizeof(typename TensorTraits<T>::ElementType)>
struct FloatTraits
{
    using FloatType = float;
};

template<typename T>
struct FloatTraits<T, 8>
{
    using FloatType = double;
};

template<>
struct FloatTraits<bool, 1>
{
    using FloatType = bool;
};

template<>
struct FloatTraits<ValueMask, 1>
{
    using FloatType = bool;
};




template<typename BuildT>
__attribute__((host)) __attribute__((device)) GridType mapToGridType()
{
    if (is_same<BuildT, float>::value) {
        return GridType::Float;
    } else if (is_same<BuildT, double>::value) {
        return GridType::Double;
    } else if (is_same<BuildT, int16_t>::value) {
        return GridType::Int16;
    } else if (is_same<BuildT, int32_t>::value) {
        return GridType::Int32;
    } else if (is_same<BuildT, int64_t>::value) {
        return GridType::Int64;
    } else if (is_same<BuildT, Vec3f>::value) {
        return GridType::Vec3f;
    } else if (is_same<BuildT, Vec3d>::value) {
        return GridType::Vec3d;
    } else if (is_same<BuildT, uint32_t>::value) {
        return GridType::UInt32;
    } else if (is_same<BuildT, ValueMask>::value) {
        return GridType::Mask;
    } else if (is_same<BuildT, bool>::value) {
        return GridType::Boolean;
    } else if (is_same<BuildT, PackedRGBA8>::value) {
        return GridType::PackedRGBA8;
    }
    return GridType::Unknown;
}



template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMult(const float* mat, const Vec3T& xyz)
{
    return Vec3T(fmaf(xyz[0], mat[0], fmaf(xyz[1], mat[1], xyz[2] * mat[2])),
                 fmaf(xyz[0], mat[3], fmaf(xyz[1], mat[4], xyz[2] * mat[5])),
                 fmaf(xyz[0], mat[6], fmaf(xyz[1], mat[7], xyz[2] * mat[8])));
}

template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMult(const double* mat, const Vec3T& xyz)
{
    return Vec3T(fma(static_cast<double>(xyz[0]), mat[0], fma(static_cast<double>(xyz[1]), mat[1], static_cast<double>(xyz[2]) * mat[2])),
                 fma(static_cast<double>(xyz[0]), mat[3], fma(static_cast<double>(xyz[1]), mat[4], static_cast<double>(xyz[2]) * mat[5])),
                 fma(static_cast<double>(xyz[0]), mat[6], fma(static_cast<double>(xyz[1]), mat[7], static_cast<double>(xyz[2]) * mat[8])));
}

template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMult(const float* mat, const float* vec, const Vec3T& xyz)
{
    return Vec3T(fmaf(xyz[0], mat[0], fmaf(xyz[1], mat[1], fmaf(xyz[2], mat[2], vec[0]))),
                 fmaf(xyz[0], mat[3], fmaf(xyz[1], mat[4], fmaf(xyz[2], mat[5], vec[1]))),
                 fmaf(xyz[0], mat[6], fmaf(xyz[1], mat[7], fmaf(xyz[2], mat[8], vec[2]))));
}

template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMult(const double* mat, const double* vec, const Vec3T& xyz)
{
    return Vec3T(fma(static_cast<double>(xyz[0]), mat[0], fma(static_cast<double>(xyz[1]), mat[1], fma(static_cast<double>(xyz[2]), mat[2], vec[0]))),
                 fma(static_cast<double>(xyz[0]), mat[3], fma(static_cast<double>(xyz[1]), mat[4], fma(static_cast<double>(xyz[2]), mat[5], vec[1]))),
                 fma(static_cast<double>(xyz[0]), mat[6], fma(static_cast<double>(xyz[1]), mat[7], fma(static_cast<double>(xyz[2]), mat[8], vec[2]))));
}



template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMultT(const float* mat, const Vec3T& xyz)
{
    return Vec3T(fmaf(xyz[0], mat[0], fmaf(xyz[1], mat[3], xyz[2] * mat[6])),
                 fmaf(xyz[0], mat[1], fmaf(xyz[1], mat[4], xyz[2] * mat[7])),
                 fmaf(xyz[0], mat[2], fmaf(xyz[1], mat[5], xyz[2] * mat[8])));
}

template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMultT(const double* mat, const Vec3T& xyz)
{
    return Vec3T(fma(static_cast<double>(xyz[0]), mat[0], fma(static_cast<double>(xyz[1]), mat[3], static_cast<double>(xyz[2]) * mat[6])),
                 fma(static_cast<double>(xyz[0]), mat[1], fma(static_cast<double>(xyz[1]), mat[4], static_cast<double>(xyz[2]) * mat[7])),
                 fma(static_cast<double>(xyz[0]), mat[2], fma(static_cast<double>(xyz[1]), mat[5], static_cast<double>(xyz[2]) * mat[8])));
}

template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMultT(const float* mat, const float* vec, const Vec3T& xyz)
{
    return Vec3T(fmaf(xyz[0], mat[0], fmaf(xyz[1], mat[3], fmaf(xyz[2], mat[6], vec[0]))),
                 fmaf(xyz[0], mat[1], fmaf(xyz[1], mat[4], fmaf(xyz[2], mat[7], vec[1]))),
                 fmaf(xyz[0], mat[2], fmaf(xyz[1], mat[5], fmaf(xyz[2], mat[8], vec[2]))));
}

template<typename Vec3T>
inline __attribute__((host)) __attribute__((device)) Vec3T matMultT(const double* mat, const double* vec, const Vec3T& xyz)
{
    return Vec3T(fma(static_cast<double>(xyz[0]), mat[0], fma(static_cast<double>(xyz[1]), mat[3], fma(static_cast<double>(xyz[2]), mat[6], vec[0]))),
                 fma(static_cast<double>(xyz[0]), mat[1], fma(static_cast<double>(xyz[1]), mat[4], fma(static_cast<double>(xyz[2]), mat[7], vec[1]))),
                 fma(static_cast<double>(xyz[0]), mat[2], fma(static_cast<double>(xyz[1]), mat[5], fma(static_cast<double>(xyz[2]), mat[8], vec[2]))));
}




template<typename Vec3T>
struct BaseBBox
{
    Vec3T mCoord[2];
    __attribute__((host)) __attribute__((device)) bool operator==(const BaseBBox& rhs) const { return mCoord[0] == rhs.mCoord[0] && mCoord[1] == rhs.mCoord[1]; };
    __attribute__((host)) __attribute__((device)) bool operator!=(const BaseBBox& rhs) const { return mCoord[0] != rhs.mCoord[0] || mCoord[1] != rhs.mCoord[1]; };
    __attribute__((host)) __attribute__((device)) const Vec3T& operator[](int i) const { return mCoord[i]; }
    __attribute__((host)) __attribute__((device)) Vec3T& operator[](int i) { return mCoord[i]; }
    __attribute__((host)) __attribute__((device)) Vec3T& min() { return mCoord[0]; }
    __attribute__((host)) __attribute__((device)) Vec3T& max() { return mCoord[1]; }
    __attribute__((host)) __attribute__((device)) const Vec3T& min() const { return mCoord[0]; }
    __attribute__((host)) __attribute__((device)) const Vec3T& max() const { return mCoord[1]; }
    __attribute__((host)) __attribute__((device)) Coord& translate(const Vec3T& xyz)
    {
        mCoord[0] += xyz;
        mCoord[1] += xyz;
        return *this;
    }

    __attribute__((host)) __attribute__((device)) BaseBBox& expand(const Vec3T& xyz)
    {
        mCoord[0].minComponent(xyz);
        mCoord[1].maxComponent(xyz);
        return *this;
    }
    __attribute__((host)) __attribute__((device)) bool isInside(const Vec3T& xyz)
    {
        if (xyz[0] < mCoord[0][0] || xyz[1] < mCoord[0][1] || xyz[2] < mCoord[0][2])
            return false;
        if (xyz[0] > mCoord[1][0] || xyz[1] > mCoord[1][1] || xyz[2] > mCoord[1][2])
            return false;
        return true;
    }

protected:
    __attribute__((host)) __attribute__((device)) BaseBBox() {}
    __attribute__((host)) __attribute__((device)) BaseBBox(const Vec3T& min, const Vec3T& max)
        : mCoord{min, max}
    {
    }
};

template<typename Vec3T, bool = is_floating_point<typename Vec3T::ValueType>::value>
struct BBox;





template<typename Vec3T>
struct BBox<Vec3T, true> : public BaseBBox<Vec3T>
{
    using Vec3Type = Vec3T;
    using ValueType = typename Vec3T::ValueType;
    static_assert(is_floating_point<ValueType>::value, "Expected a floating point coordinate type");
    using BaseT = BaseBBox<Vec3T>;
    using BaseT::mCoord;
    __attribute__((host)) __attribute__((device)) BBox()
        : BaseT(Vec3T( Maximum<typename Vec3T::ValueType>::value()),
                Vec3T(-Maximum<typename Vec3T::ValueType>::value()))
    {
    }
    __attribute__((host)) __attribute__((device)) BBox(const Vec3T& min, const Vec3T& max)
        : BaseT(min, max)
    {
    }
    __attribute__((host)) __attribute__((device)) BBox(const Coord& min, const Coord& max)
        : BaseT(Vec3T(ValueType(min[0]), ValueType(min[1]), ValueType(min[2])),
                Vec3T(ValueType(max[0] + 1), ValueType(max[1] + 1), ValueType(max[2] + 1)))
    {
    }
    __attribute__((host)) __attribute__((device)) BBox(const BaseBBox<Coord>& bbox) : BBox(bbox[0], bbox[1]) {}
    __attribute__((host)) __attribute__((device)) bool empty() const { return mCoord[0][0] >= mCoord[1][0] ||
                                             mCoord[0][1] >= mCoord[1][1] ||
                                             mCoord[0][2] >= mCoord[1][2]; }
    __attribute__((host)) __attribute__((device)) Vec3T dim() const { return this->empty() ? Vec3T(0) : this->max() - this->min(); }
    __attribute__((host)) __attribute__((device)) bool isInside(const Vec3T& p) const
    {
        return p[0] > mCoord[0][0] && p[1] > mCoord[0][1] && p[2] > mCoord[0][2] &&
               p[0] < mCoord[1][0] && p[1] < mCoord[1][1] && p[2] < mCoord[1][2];
    }
};





template<typename CoordT>
struct BBox<CoordT, false> : public BaseBBox<CoordT>
{
    static_assert(is_same<int, typename CoordT::ValueType>::value, "Expected \"int\" coordinate type");
    using BaseT = BaseBBox<CoordT>;
    using BaseT::mCoord;


    class Iterator
    {
        const BBox& mBBox;
        CoordT mPos;
    public:
        __attribute__((host)) __attribute__((device)) Iterator(const BBox& b)
            : mBBox(b)
            , mPos(b.min())
        {
        }
        __attribute__((host)) __attribute__((device)) Iterator& operator++()
        {
            if (mPos[2] < mBBox[1][2]) {
                ++mPos[2];
            } else if (mPos[1] < mBBox[1][1]) {
                mPos[2] = mBBox[0][2];
                ++mPos[1];
            } else if (mPos[0] <= mBBox[1][0]) {
                mPos[2] = mBBox[0][2];
                mPos[1] = mBBox[0][1];
                ++mPos[0];
            }
            return *this;
        }
        __attribute__((host)) __attribute__((device)) Iterator operator++(int)
        {
            auto tmp = *this;
            ++(*this);
            return tmp;
        }

        __attribute__((host)) __attribute__((device)) operator bool() const { return mPos[0] <= mBBox[1][0]; }
        __attribute__((host)) __attribute__((device)) const CoordT& operator*() const { return mPos; }
    };
    __attribute__((host)) __attribute__((device)) Iterator begin() const { return Iterator{*this}; }
    __attribute__((host)) __attribute__((device)) BBox()
        : BaseT(CoordT::max(), CoordT::min())
    {
    }
    __attribute__((host)) __attribute__((device)) BBox(const CoordT& min, const CoordT& max)
        : BaseT(min, max)
    {
    }
    template<typename SplitT>
    __attribute__((host)) __attribute__((device)) BBox(BBox& other, const SplitT&)
        : BaseT(other.mCoord[0], other.mCoord[1])
    {
        
# 1437 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 1437 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       this->is_divisible()
# 1437 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 1437 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "this->is_divisible()"
# 1437 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1437, __PRETTY_FUNCTION__))
# 1437 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                           ;
        const int n = MaxIndex(this->dim());
        mCoord[1][n] = (mCoord[0][n] + mCoord[1][n]) >> 1;
        other.mCoord[0][n] = mCoord[1][n] + 1;
    }
    __attribute__((host)) __attribute__((device)) bool is_divisible() const { return mCoord[0][0] < mCoord[1][0] &&
                                                   mCoord[0][1] < mCoord[1][1] &&
                                                   mCoord[0][2] < mCoord[1][2]; }

    __attribute__((host)) __attribute__((device)) bool empty() const { return mCoord[0][0] > mCoord[1][0] ||
                                              mCoord[0][1] > mCoord[1][1] ||
                                              mCoord[0][2] > mCoord[1][2]; }
    __attribute__((host)) __attribute__((device)) CoordT dim() const { return this->empty() ? Coord(0) : this->max() - this->min() + Coord(1); }
    __attribute__((host)) __attribute__((device)) bool isInside(const CoordT& p) const { return !(CoordT::lessThan(p, this->min()) || CoordT::lessThan(this->max(), p)); }
    __attribute__((host)) __attribute__((device)) bool isInside(const BBox& b) const
    {
        return !(CoordT::lessThan(b.min(), this->min()) || CoordT::lessThan(this->max(), b.max()));
    }


    template<typename RealT>
    __attribute__((host)) __attribute__((device)) BBox<Vec3<RealT>> asReal() const
    {
        static_assert(is_floating_point<RealT>::value, "CoordBBox::asReal: Expected a floating point coordinate");
        return BBox<Vec3<RealT>>(Vec3<RealT>(RealT(mCoord[0][0]), RealT(mCoord[0][1]), RealT(mCoord[0][2])),
                                 Vec3<RealT>(RealT(mCoord[1][0] + 1), RealT(mCoord[1][1] + 1), RealT(mCoord[1][2] + 1)));
    }
};

using CoordBBox = BBox<Coord>;
using BBoxR = BBox<Vec3R>;






__attribute__((host)) __attribute__((device)) static inline uint32_t FindLowestOn(uint32_t v)
{
    
# 1476 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 1476 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   v
# 1476 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 1476 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "v"
# 1476 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1476, __PRETTY_FUNCTION__))
# 1476 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                    ;







    static const unsigned char DeBruijn[32] = {
        0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};





    return DeBruijn[uint32_t((v & -v) * 0x077CB531U) >> 27];





}




__attribute__((host)) __attribute__((device)) static inline uint32_t FindHighestOn(uint32_t v)
{
    
# 1504 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 1504 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   v
# 1504 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 1504 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "v"
# 1504 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1504, __PRETTY_FUNCTION__))
# 1504 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                    ;
# 1513 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
    static const unsigned char DeBruijn[32] = {
        0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31};
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    return DeBruijn[uint32_t(v * 0x07C4ACDDU) >> 27];

}




__attribute__((host)) __attribute__((device)) static inline uint32_t FindLowestOn(uint64_t v)
{
    
# 1529 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 1529 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   v
# 1529 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 1529 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "v"
# 1529 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1529, __PRETTY_FUNCTION__))
# 1529 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                    ;







    static const unsigned char DeBruijn[64] = {
        0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28,
        62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11,
        63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12,
    };





    return DeBruijn[uint64_t((v & -v) * 0x022FDD63CC95386DUL) >> 58];





}




__attribute__((host)) __attribute__((device)) static inline uint32_t FindHighestOn(uint64_t v)
{
    
# 1561 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 1561 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   v
# 1561 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 1561 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "v"
# 1561 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1561, __PRETTY_FUNCTION__))
# 1561 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                    ;







    const uint32_t* p = reinterpret_cast<const uint32_t*>(&v);
    return p[1] ? 32u + FindHighestOn(p[1]) : FindHighestOn(p[0]);

}





template<uint32_t LOG2DIM>
class Mask
{
    static constexpr uint32_t SIZE = 1U << (3 * LOG2DIM);
    static constexpr uint32_t WORD_COUNT = SIZE >> 6;
    uint64_t mWords[WORD_COUNT];

public:

    __attribute__((host)) __attribute__((device)) static size_t memUsage() { return sizeof(Mask); }


    __attribute__((host)) __attribute__((device)) static uint32_t bitCount() { return SIZE; }


    __attribute__((host)) __attribute__((device)) static uint32_t wordCount() { return WORD_COUNT; }

    __attribute__((host)) __attribute__((device)) uint32_t countOn() const
    {
        uint32_t sum = 0, n = WORD_COUNT;
        for (const uint64_t* w = mWords; n--; ++w)
            sum += CountOn(*w);
        return sum;
    }

    class Iterator
    {
    public:
        __attribute__((host)) __attribute__((device)) Iterator()
            : mPos(Mask::SIZE)
            , mParent(nullptr)
        {
        }
        __attribute__((host)) __attribute__((device)) Iterator(uint32_t pos, const Mask* parent)
            : mPos(pos)
            , mParent(parent)
        {
        }
        Iterator& operator=(const Iterator&) = default;
        __attribute__((host)) __attribute__((device)) uint32_t operator*() const { return mPos; }
        __attribute__((host)) __attribute__((device)) operator bool() const { return mPos != Mask::SIZE; }
        __attribute__((host)) __attribute__((device)) Iterator& operator++()
        {
            mPos = mParent->findNextOn(mPos + 1);
            return *this;
        }

    private:
        uint32_t mPos;
        const Mask* mParent;
    };


    __attribute__((host)) __attribute__((device)) Mask()
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            mWords[i] = 0;
    }
    __attribute__((host)) __attribute__((device)) Mask(bool on)
    {
        const uint64_t v = on ? ~uint64_t(0) : uint64_t(0);
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            mWords[i] = v;
    }


    __attribute__((host)) __attribute__((device)) Mask(const Mask& other)
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            mWords[i] = other.mWords[i];
    }


    template<typename WordT>
    __attribute__((host)) __attribute__((device)) WordT getWord(int n) const
    {
        
# 1654 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 1654 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       n * 8 * sizeof(WordT) < SIZE
# 1654 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 1654 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "n * 8 * sizeof(WordT) < SIZE"
# 1654 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1654, __PRETTY_FUNCTION__))
# 1654 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                   ;
        return reinterpret_cast<const WordT*>(mWords)[n];
    }


    template<typename MaskT>
    __attribute__((host)) __attribute__((device)) Mask& operator=(const MaskT& other)
    {
        static_assert(sizeof(Mask) == sizeof(MaskT), "Mismatching sizeof");
        static_assert(WORD_COUNT == MaskT::WORD_COUNT, "Mismatching word count");
        static_assert(LOG2DIM == MaskT::LOG2DIM, "Mismatching LOG2DIM");
        auto *src = reinterpret_cast<const uint64_t*>(&other);
        uint64_t *dst = mWords;
        for (uint32_t i = 0; i < WORD_COUNT; ++i) {
            *dst++ = *src++;
        }
        return *this;
    }

    __attribute__((host)) __attribute__((device)) bool operator==(const Mask& other) const
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i) {
            if (mWords[i] != other.mWords[i]) return false;
        }
        return true;
    }

    __attribute__((host)) __attribute__((device)) bool operator!=(const Mask& other) const { return !((*this) == other); }

    __attribute__((host)) __attribute__((device)) Iterator beginOn() const { return Iterator(this->findFirstOn(), this); }


    __attribute__((host)) __attribute__((device)) bool isOn(uint32_t n) const { return 0 != (mWords[n >> 6] & (uint64_t(1) << (n & 63))); }

    __attribute__((host)) __attribute__((device)) bool isOn() const
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            if (mWords[i] != ~uint64_t(0))
                return false;
        return true;
    }

    __attribute__((host)) __attribute__((device)) bool isOff() const
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            if (mWords[i] != uint64_t(0))
                return false;
        return true;
    }


    __attribute__((host)) __attribute__((device)) void setOn(uint32_t n) { mWords[n >> 6] |= uint64_t(1) << (n & 63); }
    __attribute__((host)) __attribute__((device)) void setOff(uint32_t n) { mWords[n >> 6] &= ~(uint64_t(1) << (n & 63)); }

    __attribute__((host)) __attribute__((device)) void set(uint32_t n, bool On) { On ? this->setOn(n) : this->setOff(n); }


    __attribute__((host)) __attribute__((device)) void setOn()
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            mWords[i] = ~uint64_t(0);
    }


    __attribute__((host)) __attribute__((device)) void setOff()
    {
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            mWords[i] = uint64_t(0);
    }


    __attribute__((host)) __attribute__((device)) void set(bool on)
    {
        const uint64_t v = on ? ~uint64_t(0) : uint64_t(0);
        for (uint32_t i = 0; i < WORD_COUNT; ++i)
            mWords[i] = v;
    }

    __attribute__((host)) __attribute__((device)) void toggle()
    {
        uint32_t n = WORD_COUNT;
        for (auto* w = mWords; n--; ++w)
            *w = ~*w;
    }
    __attribute__((host)) __attribute__((device)) void toggle(uint32_t n) { mWords[n >> 6] ^= uint64_t(1) << (n & 63); }

private:
    __attribute__((host)) __attribute__((device)) static inline uint32_t CountOn(uint64_t v)
    {
        v = v - ((v >> 1) & uint64_t(0x5555555555555555));
        v = (v & uint64_t(0x3333333333333333)) + ((v >> 2) & uint64_t(0x3333333333333333));
        return (((v + (v >> 4)) & uint64_t(0xF0F0F0F0F0F0F0F)) * uint64_t(0x101010101010101)) >> 56;
    }

    __attribute__((host)) __attribute__((device)) uint32_t findFirstOn() const
    {
        uint32_t n = 0;
        const uint64_t* w = mWords;
        for (; n < WORD_COUNT && !*w; ++w, ++n)
            ;
        return n == WORD_COUNT ? SIZE : (n << 6) + FindLowestOn(*w);
    }
    __attribute__((host)) __attribute__((device)) uint32_t findNextOn(uint32_t start) const
    {
        uint32_t n = start >> 6;
        if (n >= WORD_COUNT)
            return SIZE;
        uint32_t m = start & 63;
        uint64_t b = mWords[n];
        if (b & (uint64_t(1) << m))
            return start;
        b &= ~uint64_t(0) << m;
        while (!b && ++n < WORD_COUNT)
            b = mWords[n];
        return (!b ? SIZE : (n << 6) + FindLowestOn(b));
    }
};




struct Map
{
    float mMatF[9];
    float mInvMatF[9];
    float mVecF[3];
    float mTaperF;
    double mMatD[9];
    double mInvMatD[9];
    double mVecD[3];
    double mTaperD;


    template<typename Mat4T>
    __attribute__((host)) __attribute__((device)) void set(const Mat4T& mat, const Mat4T& invMat, double taper);

    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyMap(const Vec3T& xyz) const { return matMult(mMatD, mVecD, xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyMapF(const Vec3T& xyz) const { return matMult(mMatF, mVecF, xyz); }

    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyJacobian(const Vec3T& xyz) const { return matMult(mMatD, xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyJacobianF(const Vec3T& xyz) const { return matMult(mMatF, xyz); }

    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseMap(const Vec3T& xyz) const
    {
        return matMult(mInvMatD, Vec3T(xyz[0] - mVecD[0], xyz[1] - mVecD[1], xyz[2] - mVecD[2]));
    }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseMapF(const Vec3T& xyz) const
    {
        return matMult(mInvMatF, Vec3T(xyz[0] - mVecF[0], xyz[1] - mVecF[1], xyz[2] - mVecF[2]));
    }

    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseJacobian(const Vec3T& xyz) const { return matMult(mInvMatD, xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseJacobianF(const Vec3T& xyz) const { return matMult(mInvMatF, xyz); }

    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyIJT(const Vec3T& xyz) const { return matMultT(mInvMatD, xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyIJTF(const Vec3T& xyz) const { return matMultT(mInvMatF, xyz); }
};

template<typename Mat4T>
void Map::set(const Mat4T& mat, const Mat4T& invMat, double taper)
{
    float * mf = mMatF, *vf = mVecF;
    float* mif = mInvMatF;
    double *md = mMatD, *vd = mVecD;
    double* mid = mInvMatD;
    mTaperF = static_cast<float>(taper);
    mTaperD = taper;
    for (int i = 0; i < 3; ++i) {
        *vd++ = mat[3][i];
        *vf++ = static_cast<float>(mat[3][i]);
        for (int j = 0; j < 3; ++j) {
            *md++ = mat[j][i];
            *mid++ = invMat[j][i];
            *mf++ = static_cast<float>(mat[j][i]);
            *mif++ = static_cast<float>(invMat[j][i]);
        }
    }
}



struct alignas(32) GridBlindMetaData
{
    static const int MaxNameSize = 256;
    int64_t mByteOffset;
    uint64_t mElementCount;
    uint32_t mFlags;
    GridBlindDataSemantic mSemantic;
    GridBlindDataClass mDataClass;
    GridType mDataType;
    char mName[MaxNameSize];


    __attribute__((host)) __attribute__((device)) static uint64_t memUsage(uint64_t blindDataCount = 0)
    {
        return blindDataCount * sizeof(GridBlindMetaData);
    }

};
# 1890 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
struct alignas(32) GridData
{
    static const int MaxNameSize = 256;
    uint64_t mMagic;
    uint64_t mChecksum;
    Version mVersion;
    uint32_t mFlags;
    uint64_t mGridSize;
    char mGridName[MaxNameSize];
    Map mMap;
    BBox<Vec3R> mWorldBBox;
    Vec3R mVoxelSize;
    GridClass mGridClass;
    GridType mGridType;
    uint64_t mBlindMetadataOffset;
    uint32_t mBlindMetadataCount;


    __attribute__((host)) __attribute__((device)) void setFlagsOff() { mFlags = uint32_t(0); }
    __attribute__((host)) __attribute__((device)) void setMinMaxOn(bool on = true)
    {
        if (on) {
            mFlags |= static_cast<uint32_t>(GridFlags::HasMinMax);
        } else {
            mFlags &= ~static_cast<uint32_t>(GridFlags::HasMinMax);
        }
    }
    __attribute__((host)) __attribute__((device)) void setBBoxOn(bool on = true)
    {
        if (on) {
            mFlags |= static_cast<uint32_t>(GridFlags::HasBBox);
        } else {
            mFlags &= ~static_cast<uint32_t>(GridFlags::HasBBox);
        }
    }
    __attribute__((host)) __attribute__((device)) void setLongGridNameOn(bool on = true)
    {
        if (on) {
            mFlags |= static_cast<uint32_t>(GridFlags::HasLongGridName);
        } else {
            mFlags &= ~static_cast<uint32_t>(GridFlags::HasLongGridName);
        }
    }
    __attribute__((host)) __attribute__((device)) void setAverageOn(bool on = true)
    {
        if (on) {
            mFlags |= static_cast<uint32_t>(GridFlags::HasAverage);
        } else {
            mFlags &= ~static_cast<uint32_t>(GridFlags::HasAverage);
        }
    }
    __attribute__((host)) __attribute__((device)) void setStdDeviationOn(bool on = true)
    {
        if (on) {
            mFlags |= static_cast<uint32_t>(GridFlags::HasStdDeviation);
        } else {
            mFlags &= ~static_cast<uint32_t>(GridFlags::HasStdDeviation);
        }
    }


    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyMap(const Vec3T& xyz) const { return mMap.applyMap(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseMap(const Vec3T& xyz) const { return mMap.applyInverseMap(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyJacobian(const Vec3T& xyz) const { return mMap.applyJacobian(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseJacobian(const Vec3T& xyz) const { return mMap.applyInverseJacobian(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyIJT(const Vec3T& xyz) const { return mMap.applyIJT(xyz); }

    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyMapF(const Vec3T& xyz) const { return mMap.applyMapF(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseMapF(const Vec3T& xyz) const { return mMap.applyInverseMapF(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyJacobianF(const Vec3T& xyz) const { return mMap.applyJacobianF(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyInverseJacobianF(const Vec3T& xyz) const { return mMap.applyInverseJacobianF(xyz); }
    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T applyIJTF(const Vec3T& xyz) const { return mMap.applyIJTF(xyz); }


    __attribute__((host)) __attribute__((device)) const GridBlindMetaData* metaPtr() const
    {
        return reinterpret_cast<const GridBlindMetaData*>(reinterpret_cast<const uint8_t*>(this) + mBlindMetadataOffset);
    }


    __attribute__((host)) __attribute__((device)) void* treePtr() { return this + 1; }


    __attribute__((host)) __attribute__((device)) const void* treePtr() const { return this + 1; }




    __attribute__((host)) __attribute__((device)) const GridBlindMetaData& blindMetaData(uint32_t n) const
    {
        
# 1990 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 1990 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       n < mBlindMetadataCount
# 1990 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 1990 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "n < mBlindMetadataCount"
# 1990 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 1990, __PRETTY_FUNCTION__))
# 1990 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                              ;
        return *(this->metaPtr() + n);
    }

};


template <typename ValueT, int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1>
class ReadAccessor;

template <typename ValueT>
using DefaultReadAccessor = ReadAccessor<ValueT, 0, 1, 2>;





template<typename TreeT>
class Grid : private GridData
{
public:
    using TreeType = TreeT;
    using DataType = GridData;
    using ValueType = typename TreeT::ValueType;
    using BuildType = typename TreeT::BuildType;
    using CoordType = typename TreeT::CoordType;
    using AccessorType = DefaultReadAccessor<ValueType>;






    Grid(const Grid&) = delete;
    Grid& operator=(const Grid&) = delete;
    ~Grid() = delete;

    __attribute__((host)) __attribute__((device)) Version version() const { return DataType::mVersion; }

    __attribute__((host)) __attribute__((device)) DataType* data() { return reinterpret_cast<DataType*>(this); }

    __attribute__((host)) __attribute__((device)) const DataType* data() const { return reinterpret_cast<const DataType*>(this); }


    __attribute__((host)) __attribute__((device)) static uint64_t memUsage() { return sizeof(GridData); }


    __attribute__((host)) __attribute__((device)) uint64_t totalMemUsage() const { return DataType::mGridSize; }


    __attribute__((host)) __attribute__((device)) const TreeT& tree() const { return *reinterpret_cast<const TreeT*>(this->treePtr()); }


    __attribute__((host)) __attribute__((device)) TreeT& tree() { return *reinterpret_cast<TreeT*>(this->treePtr()); }


    __attribute__((host)) __attribute__((device)) AccessorType getAccessor() const { return AccessorType(this->tree().root()); }


    __attribute__((host)) __attribute__((device)) const Vec3R& voxelSize() const { return DataType::mVoxelSize; }


    __attribute__((host)) __attribute__((device)) const Map& map() const { return DataType::mMap; }


    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T worldToIndex(const Vec3T& xyz) const { return this->applyInverseMap(xyz); }


    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T indexToWorld(const Vec3T& xyz) const { return this->applyMap(xyz); }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T indexToWorldDir(const Vec3T& dir) const { return this->applyJacobian(dir); }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T worldToIndexDir(const Vec3T& dir) const { return this->applyInverseJacobian(dir); }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T indexToWorldGrad(const Vec3T& grad) const { return this->applyIJT(grad); }


    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T worldToIndexF(const Vec3T& xyz) const { return this->applyInverseMapF(xyz); }


    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T indexToWorldF(const Vec3T& xyz) const { return this->applyMapF(xyz); }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T indexToWorldDirF(const Vec3T& dir) const { return this->applyJacobianF(dir); }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T worldToIndexDirF(const Vec3T& dir) const { return this->applyInverseJacobianF(dir); }



    template<typename Vec3T>
    __attribute__((host)) __attribute__((device)) Vec3T indexToWorldGradF(const Vec3T& grad) const { return DataType::applyIJTF(grad); }


    __attribute__((host)) __attribute__((device)) const BBox<Vec3R>& worldBBox() const { return DataType::mWorldBBox; }





    __attribute__((host)) __attribute__((device)) const BBox<CoordType>& indexBBox() const { return this->tree().bbox(); }


    __attribute__((host)) __attribute__((device)) const uint64_t& activeVoxelCount() const { return this->tree().activeVoxelCount(); }


    __attribute__((host)) __attribute__((device)) bool isValid() const { return DataType::mMagic == 0x304244566f6e614eUL; }
    __attribute__((host)) __attribute__((device)) const GridType& gridType() const { return DataType::mGridType; }
    __attribute__((host)) __attribute__((device)) const GridClass& gridClass() const { return DataType::mGridClass; }
    __attribute__((host)) __attribute__((device)) bool isLevelSet() const { return DataType::mGridClass == GridClass::LevelSet; }
    __attribute__((host)) __attribute__((device)) bool isFogVolume() const { return DataType::mGridClass == GridClass::FogVolume; }
    __attribute__((host)) __attribute__((device)) bool isStaggered() const { return DataType::mGridClass == GridClass::Staggered; }
    __attribute__((host)) __attribute__((device)) bool isPointIndex() const { return DataType::mGridClass == GridClass::PointIndex; }
    __attribute__((host)) __attribute__((device)) bool isPointData() const { return DataType::mGridClass == GridClass::PointData; }
    __attribute__((host)) __attribute__((device)) bool isMask() const { return DataType::mGridClass == GridClass::Topology; }
    __attribute__((host)) __attribute__((device)) bool isUnknown() const { return DataType::mGridClass == GridClass::Unknown; }
    __attribute__((host)) __attribute__((device)) bool hasMinMax() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasMinMax); }
    __attribute__((host)) __attribute__((device)) bool hasBBox() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasBBox); }
    __attribute__((host)) __attribute__((device)) bool hasLongGridName() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasLongGridName); }
    __attribute__((host)) __attribute__((device)) bool hasAverage() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasAverage); }
    __attribute__((host)) __attribute__((device)) bool hasStdDeviation() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasStdDeviation); }


    __attribute__((host)) __attribute__((device)) const char* gridName() const
    {
        if (this->hasLongGridName()) {
            const auto &meta = this->blindMetaData(DataType::mBlindMetadataCount-1);
            
# 2134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
           ((
# 2134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
           meta.mDataClass == GridBlindDataClass::GridName
# 2134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
           ) ? static_cast<void> (0) : __assert_fail (
# 2134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
           "meta.mDataClass == GridBlindDataClass::GridName"
# 2134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
           , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2134, __PRETTY_FUNCTION__))
# 2134 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                                          ;
            return reinterpret_cast<const char*>(this) + meta.mByteOffset;
        }
        return DataType::mGridName;
    }


    __attribute__((host)) __attribute__((device)) uint64_t checksum() const { return DataType::mChecksum; }


    __attribute__((host)) __attribute__((device)) uint64_t gridSize() const { return DataType::mGridSize; }


    __attribute__((host)) __attribute__((device)) bool isEmpty() const { return this->tree().isEmpty(); }


    __attribute__((host)) __attribute__((device)) int blindDataCount() const { return DataType::mBlindMetadataCount; }


    __attribute__((host)) __attribute__((device)) int findBlindDataForSemantic(GridBlindDataSemantic semantic) const;




    __attribute__((host)) __attribute__((device)) const void* blindData(uint32_t n) const
    {
        if (DataType::mBlindMetadataCount == 0)
            return nullptr;
        
# 2162 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 2162 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       n < DataType::mBlindMetadataCount
# 2162 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 2162 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "n < DataType::mBlindMetadataCount"
# 2162 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2162, __PRETTY_FUNCTION__))
# 2162 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                        ;
        return reinterpret_cast<const char*>(this) + this->blindMetaData(n).mByteOffset;
    }

    __attribute__((host)) __attribute__((device)) const GridBlindMetaData& blindMetaData(int n) const { return DataType::blindMetaData(n); }

private:
    static_assert(sizeof(GridData) % 32 == 0, "sizeof(GridData) is misaligned");
};

template<typename TreeT>
int Grid<TreeT>::findBlindDataForSemantic(GridBlindDataSemantic semantic) const
{
    for (uint32_t i = 0, n = blindDataCount(); i < n; ++i)
        if (blindMetaData(i).mSemantic == semantic)
            return int(i);
    return -1;
}



template<int ROOT_LEVEL = 3>
struct alignas(32) TreeData
{
    static_assert(ROOT_LEVEL == 3, "Root level is assumed to be three");
    uint64_t mBytes[ROOT_LEVEL + 1];
    uint32_t mCount[ROOT_LEVEL + 1];
    uint32_t mPFSum[ROOT_LEVEL + 1];
};


template<typename TreeT, int LEVEL>
struct TreeNode;


template<typename TreeT>
struct TreeNode<TreeT, 0>
{
    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
    using type = typename TreeT::LeafNodeType;
};
template<typename TreeT>
struct TreeNode<TreeT, 1>
{
    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
    using type = typename TreeT::RootType::ChildNodeType::ChildNodeType;
};
template<typename TreeT>
struct TreeNode<TreeT, 2>
{
    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
    using type = typename TreeT::RootType::ChildNodeType;
};
template<typename TreeT>
struct TreeNode<TreeT, 3>
{
    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
    using type = typename TreeT::RootType;
};


template<typename RootT>
class Tree : private TreeData<RootT::LEVEL>
{
    static_assert(RootT::LEVEL == 3, "Tree depth is not supported");
    static_assert(RootT::ChildNodeType::LOG2DIM == 5, "Tree configuration is not supported");
    static_assert(RootT::ChildNodeType::ChildNodeType::LOG2DIM == 4, "Tree configuration is not supported");
    static_assert(RootT::LeafNodeType::LOG2DIM == 3, "Tree configuration is not supported");

public:
    using DataType = TreeData<RootT::LEVEL>;
    using RootType = RootT;
    using LeafNodeType = typename RootT::LeafNodeType;
    using ValueType = typename RootT::ValueType;
    using BuildType = typename RootT::BuildType;
    using CoordType = typename RootT::CoordType;
    using AccessorType = DefaultReadAccessor<ValueType>;

    using Node3 = RootT;
    using Node2 = typename RootT::ChildNodeType;
    using Node1 = typename Node2::ChildNodeType;
    using Node0 = LeafNodeType;

    template<int LEVEL>
    using TreeNodeT = typename TreeNode<Tree, LEVEL>::type;

    static_assert(is_same<TreeNodeT<0>, Node0>::value, "TreeNodeT<0> error");
    static_assert(is_same<TreeNodeT<1>, Node1>::value, "TreeNodeT<1> error");
    static_assert(is_same<TreeNodeT<2>, Node2>::value, "TreeNodeT<2> error");
    static_assert(is_same<TreeNodeT<3>, Node3>::value, "TreeNodeT<3> error");


    Tree() = delete;
    Tree(const Tree&) = delete;
    Tree& operator=(const Tree&) = delete;
    ~Tree() = delete;

    __attribute__((host)) __attribute__((device)) DataType* data() { return reinterpret_cast<DataType*>(this); }

    __attribute__((host)) __attribute__((device)) const DataType* data() const { return reinterpret_cast<const DataType*>(this); }


    __attribute__((host)) __attribute__((device)) static uint64_t memUsage() { return sizeof(DataType); }

    __attribute__((host)) __attribute__((device)) RootT& root() { return *reinterpret_cast<RootT*>(reinterpret_cast<uint8_t*>(this) + DataType::mBytes[RootT::LEVEL]); }

    __attribute__((host)) __attribute__((device)) const RootT& root() const { return *reinterpret_cast<const RootT*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[RootT::LEVEL]); }

    __attribute__((host)) __attribute__((device)) AccessorType getAccessor() const { return AccessorType(this->root()); }


    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const { return this->root().getValue(ijk); }


    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const { return this->root().isActive(ijk); }


    __attribute__((host)) __attribute__((device)) bool isEmpty() const { return this->root().isEmpty(); }


    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const { return this->root().probeValue(ijk, v); }


    __attribute__((host)) __attribute__((device)) const ValueType& background() const { return this->root().background(); }


    __attribute__((host)) __attribute__((device)) void extrema(ValueType& min, ValueType& max) const;


    __attribute__((host)) __attribute__((device)) const BBox<CoordType>& bbox() const { return this->root().bbox(); }


    __attribute__((host)) __attribute__((device)) const uint64_t& activeVoxelCount() const { return this->root().activeVoxelCount(); }

    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) uint32_t nodeCount() const { return DataType::mCount[NodeT::LEVEL]; }

    __attribute__((host)) __attribute__((device)) uint32_t nodeCount(int level) const { return DataType::mCount[level]; }

    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) const NodeT* getNode(uint32_t i) const;

    template<int LEVEL>
    __attribute__((host)) __attribute__((device)) const TreeNodeT<LEVEL>* getNode(uint32_t i) const;

    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) NodeT* getNode(uint32_t i);

    template<int LEVEL>
    __attribute__((host)) __attribute__((device)) TreeNodeT<LEVEL>* getNode(uint32_t i);


    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) uint32_t getNodeID(const NodeT& node) const;






    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) uint32_t getLinearOffset(const NodeT& node) const;

private:
    static_assert(sizeof(DataType) % 32 == 0, "sizeof(TreeData) is misaligned");

};

template<typename RootT>
void Tree<RootT>::extrema(ValueType& min, ValueType& max) const
{
    min = this->root().valueMin();
    max = this->root().valueMax();
}

template<typename RootT>
template<typename NodeT>
const NodeT* Tree<RootT>::getNode(uint32_t i) const
{
    static_assert(is_same<TreeNodeT<NodeT::LEVEL>, NodeT>::value, "Tree::getNode: unvalid node type");
    
# 2342 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 2342 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   i < DataType::mCount[NodeT::LEVEL]
# 2342 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 2342 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "i < DataType::mCount[NodeT::LEVEL]"
# 2342 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2342, __PRETTY_FUNCTION__))
# 2342 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                     ;
    return reinterpret_cast<const NodeT*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[NodeT::LEVEL]) + i;
}

template<typename RootT>
template<int LEVEL>
const typename TreeNode<Tree<RootT>, LEVEL>::type* Tree<RootT>::getNode(uint32_t i) const
{
    
# 2350 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 2350 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   i < DataType::mCount[LEVEL]
# 2350 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 2350 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "i < DataType::mCount[LEVEL]"
# 2350 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2350, __PRETTY_FUNCTION__))
# 2350 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                              ;
    return reinterpret_cast<const TreeNodeT<LEVEL>*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[LEVEL]) + i;
}

template<typename RootT>
template<typename NodeT>
NodeT* Tree<RootT>::getNode(uint32_t i)
{
    static_assert(is_same<TreeNodeT<NodeT::LEVEL>, NodeT>::value, "Tree::getNode: invalid node type");
    
# 2359 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 2359 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   i < DataType::mCount[NodeT::LEVEL]
# 2359 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 2359 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "i < DataType::mCount[NodeT::LEVEL]"
# 2359 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2359, __PRETTY_FUNCTION__))
# 2359 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                     ;
    return reinterpret_cast<NodeT*>(reinterpret_cast<uint8_t*>(this) + DataType::mBytes[NodeT::LEVEL]) + i;
}

template<typename RootT>
template<int LEVEL>
typename TreeNode<Tree<RootT>, LEVEL>::type* Tree<RootT>::getNode(uint32_t i)
{
    
# 2367 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 2367 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   i < DataType::mCount[LEVEL]
# 2367 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 2367 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "i < DataType::mCount[LEVEL]"
# 2367 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2367, __PRETTY_FUNCTION__))
# 2367 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                              ;
    return reinterpret_cast<TreeNodeT<LEVEL>*>(reinterpret_cast<uint8_t*>(this) + DataType::mBytes[LEVEL]) + i;
}

template<typename RootT>
template<typename NodeT>
uint32_t Tree<RootT>::getNodeID(const NodeT& node) const
{
    static_assert(is_same<TreeNodeT<NodeT::LEVEL>, NodeT>::value, "Tree::getNodeID: invalid node type");
    const NodeT* first = reinterpret_cast<const NodeT*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[NodeT::LEVEL]);
    
# 2377 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 2377 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   &node >= first
# 2377 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 2377 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "&node >= first"
# 2377 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2377, __PRETTY_FUNCTION__))
# 2377 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                 ;
    return static_cast<uint32_t>(&node - first);
}

template<typename RootT>
template<typename NodeT>
uint32_t Tree<RootT>::getLinearOffset(const NodeT& node) const
{
    return this->getNodeID(node) + DataType::mPFSum[NodeT::LEVEL];
}






template<typename ChildT>
struct alignas(32) RootData
{
    using ValueT = typename ChildT::ValueType;
    using BuildT = typename ChildT::BuildType;
    using CoordT = typename ChildT::CoordType;
    using StatsT = typename ChildT::FloatType;


    using KeyT = uint64_t;
    template <typename CoordType>
    __attribute__((host)) __attribute__((device)) static KeyT CoordToKey(const CoordType& ijk)
    {
        static_assert(sizeof(CoordT) == sizeof(CoordType), "Mismatching sizeof");
        static_assert(32 - ChildT::TOTAL <= 21, "Cannot use 64 bit root keys");
        return (KeyT(uint32_t(ijk[2]) >> ChildT::TOTAL)) |
               (KeyT(uint32_t(ijk[1]) >> ChildT::TOTAL) << 21) |
               (KeyT(uint32_t(ijk[0]) >> ChildT::TOTAL) << 42);
    }
    __attribute__((host)) __attribute__((device)) static CoordT KeyToCoord(const KeyT& key)
    {
        static constexpr uint64_t MASK = (1u << 21) - 1;
        return Coord(((key >> 42) & MASK) << ChildT::TOTAL,
                     ((key >> 21) & MASK) << ChildT::TOTAL,
                     (key & MASK) << ChildT::TOTAL);
    }





    BBox<CoordT> mBBox;
    uint64_t mActiveVoxelCount;
    uint32_t mTileCount;

    ValueT mBackground;
    ValueT mMinimum;
    ValueT mMaximum;
    StatsT mAverage;
    StatsT mStdDevi;

    struct alignas(32) Tile
    {
        template <typename CoordType>
        __attribute__((host)) __attribute__((device)) void setChild(const CoordType& k, int32_t n)
        {
            key = CoordToKey(k);
            childID = n;
        }
        template <typename CoordType, typename ValueType>
        __attribute__((host)) __attribute__((device)) void setValue(const CoordType& k, bool s, const ValueType &v)
        {
            key = CoordToKey(k);
            state = s;
            value = v;
            childID = -1;
        }
        __attribute__((host)) __attribute__((device)) bool isChild() const { return childID >= 0; }
        __attribute__((host)) __attribute__((device)) CoordT origin() const { return KeyToCoord(key); }
        KeyT key;
        int32_t childID;
        uint32_t state;
        ValueT value;
    };




    __attribute__((host)) __attribute__((device)) Tile& tile(uint32_t n) const
    {
        
# 2463 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 2463 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       n < mTileCount
# 2463 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 2463 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "n < mTileCount"
# 2463 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2463, __PRETTY_FUNCTION__))
# 2463 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                     ;
        return *(reinterpret_cast<Tile*>(const_cast<RootData*>(this) + 1) + n);
    }




    __attribute__((host)) __attribute__((device)) const ChildT& child(const Tile& tile) const
    {
        
# 2472 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 2472 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       tile.isChild() && tile.childID < int32_t(ChildT::SIZE)
# 2472 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 2472 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "tile.isChild() && tile.childID < int32_t(ChildT::SIZE)"
# 2472 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2472, __PRETTY_FUNCTION__))
# 2472 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                                             ;
        return *(reinterpret_cast<const ChildT*>(reinterpret_cast<const Tile*>(this + 1) + mTileCount) + tile.childID);
    }

    __attribute__((host)) __attribute__((device)) const ValueT& valueMin() const { return mMinimum; }
    __attribute__((host)) __attribute__((device)) const ValueT& valueMax() const { return mMaximum; }
    __attribute__((host)) __attribute__((device)) const StatsT& average() const { return mAverage; }
    __attribute__((host)) __attribute__((device)) const StatsT& stdDeviation() const { return mStdDevi; }

    __attribute__((host)) __attribute__((device)) void setMin(const ValueT& v) { mMinimum = v; }
    __attribute__((host)) __attribute__((device)) void setMax(const ValueT& v) { mMaximum = v; }
    __attribute__((host)) __attribute__((device)) void setAvg(const StatsT& v) { mAverage = v; }
    __attribute__((host)) __attribute__((device)) void setStd(const StatsT& v) { mStdDevi = v; }


    RootData() = delete;
    RootData(const RootData&) = delete;
    RootData& operator=(const RootData&) = delete;
    ~RootData() = delete;
};


template<typename ChildT>
class RootNode : private RootData<ChildT>
{
public:
    using DataType = RootData<ChildT>;
    using LeafNodeType = typename ChildT::LeafNodeType;
    using ChildNodeType = ChildT;

    using ValueType = typename DataType::ValueT;
    using FloatType = typename DataType::StatsT;
    using BuildType = typename DataType::BuildT;

    using CoordType = typename ChildT::CoordType;
    using AccessorType = DefaultReadAccessor<ValueType>;
    using Tile = typename DataType::Tile;

    static constexpr uint32_t LEVEL = 1 + ChildT::LEVEL;


    RootNode() = delete;
    RootNode(const RootNode&) = delete;
    RootNode& operator=(const RootNode&) = delete;
    ~RootNode() = delete;

    __attribute__((host)) __attribute__((device)) AccessorType getAccessor() const { return AccessorType(*this); }

    __attribute__((host)) __attribute__((device)) DataType* data() { return reinterpret_cast<DataType*>(this); }

    __attribute__((host)) __attribute__((device)) const DataType* data() const { return reinterpret_cast<const DataType*>(this); }


    __attribute__((host)) __attribute__((device)) const BBox<CoordType>& bbox() const { return DataType::mBBox; }


    __attribute__((host)) __attribute__((device)) const uint64_t& activeVoxelCount() const { return DataType::mActiveVoxelCount; }



    __attribute__((host)) __attribute__((device)) const ValueType& background() const { return DataType::mBackground; }


    __attribute__((host)) __attribute__((device)) const uint32_t& tileCount() const { return DataType::mTileCount; }


    __attribute__((host)) __attribute__((device)) const ValueType& valueMin() const { return DataType::mMinimum; }


    __attribute__((host)) __attribute__((device)) const ValueType& valueMax() const { return DataType::mMaximum; }


    __attribute__((host)) __attribute__((device)) const FloatType& average() const { return DataType::mAverage; }


    __attribute__((host)) __attribute__((device)) FloatType variance() const { return DataType::mStdDevi * DataType::mStdDevi; }


    __attribute__((host)) __attribute__((device)) const FloatType& stdDeviation() const { return DataType::mStdDevi; }


    __attribute__((host)) __attribute__((device)) static uint64_t memUsage(uint32_t _tileCount) { return sizeof(RootNode) + _tileCount * sizeof(Tile); }


    __attribute__((host)) __attribute__((device)) uint64_t memUsage() const { return sizeof(RootNode) + DataType::mTileCount * sizeof(Tile); }


    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const
    {
        const Tile* tile = this->findTile(ijk);
        return tile ? (tile->childID < 0 ? tile->value : this->child(*tile).getValue(ijk)) : DataType::mBackground;
    }

    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const
    {
        const Tile* tile = this->findTile(ijk);
        return tile ? (tile->childID < 0 ? tile->state : this->child(*tile).isActive(ijk)) : false;
    }


    __attribute__((host)) __attribute__((device)) bool isEmpty() const { return DataType::mTileCount == uint32_t(0); }

    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const
    {
        if (const Tile* tile = this->findTile(ijk)) {
            if (tile->childID < 0) {
                v = tile->value;
                return tile->state;
            } else {
                return this->child(*tile).probeValue(ijk, v);
            }
        }
        v = DataType::mBackground;
        return false;
    }

    __attribute__((host)) __attribute__((device)) const LeafNodeType* probeLeaf(const CoordType& ijk) const
    {
        const Tile* tile = this->findTile(ijk);
        if (tile == nullptr || tile->childID < 0)
            return nullptr;
        return this->child(*tile).probeLeaf(ijk);
    }

private:
    static_assert(sizeof(DataType) % 32 == 0, "sizeof(RootData) is misaligned");
    static_assert(sizeof(typename DataType::Tile) % 32 == 0, "sizeof(RootData::Tile) is misaligned");

    template<typename, int, int, int>
    friend class ReadAccessor;

    template<typename>
    friend class Tree;





    __attribute__((host)) __attribute__((device)) const Tile* findTile(const CoordType& ijk) const
    {

        int32_t low = 0, high = DataType::mTileCount;
        const Tile* tiles = reinterpret_cast<const Tile*>(this + 1);
        const auto key = DataType::CoordToKey(ijk);

        for (int i = low; i < high; i++) {
            const Tile* tile = &tiles[i];
            if (tile->key == key)
                return tile;
        }
# 2635 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
        return nullptr;
    }


    template<typename AccT>
    __attribute__((host)) __attribute__((device)) typename AccT::NodeInfo getNodeInfoAndCache(const CoordType& ijk, const AccT& acc) const
    {
        using NodeInfoT = typename AccT::NodeInfo;
        if (const Tile* tile = this->findTile(ijk)) {
            if (tile->childID < 0) {
                return NodeInfoT{LEVEL, ChildT::dim(), tile->value, tile->value, tile->value,
                                 0, tile->origin(), tile->origin() + CoordType(ChildT::DIM)};
            }
            const ChildT& child = this->child(*tile);
            acc.insert(ijk, &child);
            return child.getNodeInfoAndCache(ijk, acc);
        }
        return NodeInfoT{LEVEL, Maximum<uint32_t>::value(), this->valueMin(), this->valueMax(),
                         this->average(), this->stdDeviation(), this->bbox()[0], this->bbox()[1]};
    }


    template<typename AccT>
    __attribute__((host)) __attribute__((device)) const ValueType& getValueAndCache(const CoordType& ijk, const AccT& acc) const
    {
        if (const Tile* tile = this->findTile(ijk)) {
            if (tile->childID < 0)
                return tile->value;
            const ChildT& child = this->child(*tile);
            acc.insert(ijk, &child);
            return child.getValueAndCache(ijk, acc);
        }
        return DataType::mBackground;
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) bool isActiveAndCache(const CoordType& ijk, const AccT& acc) const
    {
        if (const Tile* tile = this->findTile(ijk)) {
            if (tile->childID < 0)
                return tile->state;
            const ChildT& child = this->child(*tile);
            acc.insert(ijk, &child);
            return child.isActiveAndCache(ijk, acc);
        }
        return false;
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) bool probeValueAndCache(const CoordType& ijk, ValueType& v, const AccT& acc) const
    {
        if (const Tile* tile = this->findTile(ijk)) {
            if (tile->childID < 0) {
                v = tile->value;
                return tile->state;
            }
            const ChildT& child = this->child(*tile);
            acc.insert(ijk, &child);
            return child.probeValueAndCache(ijk, v, acc);
        }
        v = DataType::mBackground;
        return false;
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) const LeafNodeType* probeLeafAndCache(const CoordType& ijk, const AccT& acc) const
    {
        const Tile* tile = this->findTile(ijk);
        if (tile == nullptr || tile->childID < 0)
            return nullptr;
        const ChildT& child = this->child(*tile);
        acc.insert(ijk, &child);
        return child.probeLeafAndCache(ijk, acc);
    }

    template<typename RayT, typename AccT>
    __attribute__((host)) __attribute__((device)) uint32_t getDimAndCache(const CoordType& ijk, const RayT& ray, const AccT& acc) const
    {
        if (const Tile* tile = this->findTile(ijk)) {
            if (tile->childID < 0)
                return 1 << ChildT::TOTAL;
            const ChildT& child = this->child(*tile);
            acc.insert(ijk, &child);
            return child.getDimAndCache(ijk, ray, acc);
        }
        return ChildNodeType::dim();
    }

};
# 2732 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
template<typename ChildT, uint32_t LOG2DIM>
struct alignas(32) InternalData
{
    using ValueT = typename ChildT::ValueType;
    using BuildT = typename ChildT::BuildType;
    using StatsT = typename ChildT::FloatType;
    using CoordT = typename ChildT::CoordType;
    using MaskT = typename ChildT::template MaskType<LOG2DIM>;

    union Tile
    {
        ValueT value;
        uint32_t childID;


        Tile() = delete;
        Tile(const Tile&) = delete;
        Tile& operator=(const Tile&) = delete;
        ~Tile() = delete;
    };

    BBox<CoordT> mBBox;
    int32_t mOffset;
    uint32_t mFlags;
    MaskT mValueMask;
    MaskT mChildMask;

    ValueT mMinimum;
    ValueT mMaximum;
    StatsT mAverage;
    StatsT mStdDevi;
    alignas(32) Tile mTable[1u << (3 * LOG2DIM)];


    __attribute__((host)) __attribute__((device)) const ChildT* child(uint32_t n) const
    {
        
# 2768 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 2768 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       mChildMask.isOn(n)
# 2768 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 2768 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "mChildMask.isOn(n)"
# 2768 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2768, __PRETTY_FUNCTION__))
# 2768 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                         ;
        return reinterpret_cast<const ChildT*>(this + mOffset) + mTable[n].childID;
    }

    __attribute__((host)) __attribute__((device)) const ValueT& valueMin() const { return mMinimum; }
    __attribute__((host)) __attribute__((device)) const ValueT& valueMax() const { return mMaximum; }
    __attribute__((host)) __attribute__((device)) const StatsT& average() const { return mAverage; }
    __attribute__((host)) __attribute__((device)) const StatsT& stdDeviation() const { return mStdDevi; }

    __attribute__((host)) __attribute__((device)) void setMin(const ValueT& v) { mMinimum = v; }
    __attribute__((host)) __attribute__((device)) void setMax(const ValueT& v) { mMaximum = v; }
    __attribute__((host)) __attribute__((device)) void setAvg(const StatsT& v) { mAverage = v; }
    __attribute__((host)) __attribute__((device)) void setStd(const StatsT& v) { mStdDevi = v; }


    InternalData() = delete;
    InternalData(const InternalData&) = delete;
    InternalData& operator=(const InternalData&) = delete;
    ~InternalData() = delete;
};


template<typename ChildT, uint32_t Log2Dim = ChildT::LOG2DIM + 1>
class InternalNode : private InternalData<ChildT, Log2Dim>
{
public:
    using DataType = InternalData<ChildT, Log2Dim>;
    using ValueType = typename DataType::ValueT;
    using FloatType = typename DataType::StatsT;
    using BuildType = typename DataType::BuildT;
    using LeafNodeType = typename ChildT::LeafNodeType;
    using ChildNodeType = ChildT;
    using CoordType = typename ChildT::CoordType;
    template<uint32_t LOG2>
    using MaskType = typename ChildT::template MaskType<LOG2>;

    static constexpr uint32_t LOG2DIM = Log2Dim;
    static constexpr uint32_t TOTAL = LOG2DIM + ChildT::TOTAL;
    static constexpr uint32_t DIM = 1u << TOTAL;
    static constexpr uint32_t SIZE = 1u << (3 * LOG2DIM);
    static constexpr uint32_t MASK = (1u << TOTAL) - 1u;
    static constexpr uint32_t LEVEL = 1 + ChildT::LEVEL;
    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL);


    InternalNode() = delete;
    InternalNode(const InternalNode&) = delete;
    InternalNode& operator=(const InternalNode&) = delete;
    ~InternalNode() = delete;

    __attribute__((host)) __attribute__((device)) DataType* data() { return reinterpret_cast<DataType*>(this); }

    __attribute__((host)) __attribute__((device)) const DataType* data() const { return reinterpret_cast<const DataType*>(this); }


    __attribute__((host)) __attribute__((device)) static uint32_t dim() { return 1u << TOTAL; }


    __attribute__((host)) __attribute__((device)) static size_t memUsage() { return sizeof(DataType); }


    __attribute__((host)) __attribute__((device)) const MaskType<LOG2DIM>& valueMask() const { return DataType::mValueMask; }


    __attribute__((host)) __attribute__((device)) const MaskType<LOG2DIM>& childMask() const { return DataType::mChildMask; }


    __attribute__((host)) __attribute__((device)) CoordType origin() const { return DataType::mBBox.min() & ~MASK; }


    __attribute__((host)) __attribute__((device)) const ValueType& valueMin() const { return DataType::mMinimum; }


    __attribute__((host)) __attribute__((device)) const ValueType& valueMax() const { return DataType::mMaximum; }


    __attribute__((host)) __attribute__((device)) const FloatType& average() const { return DataType::mAverage; }


    __attribute__((host)) __attribute__((device)) FloatType variance() const { return DataType::mStdDevi*DataType::mStdDevi; }


    __attribute__((host)) __attribute__((device)) const FloatType& stdDeviation() const { return DataType::mStdDevi; }


    __attribute__((host)) __attribute__((device)) const BBox<CoordType>& bbox() const { return DataType::mBBox; }


    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const
    {
        const uint32_t n = CoordToOffset(ijk);
        return DataType::mChildMask.isOn(n) ? this->child(n)->getValue(ijk) : DataType::mTable[n].value;
    }

    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const
    {
        const uint32_t n = CoordToOffset(ijk);
        return DataType::mChildMask.isOn(n) ? this->child(n)->isActive(ijk) : DataType::mValueMask.isOn(n);
    }

    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const
    {
        const uint32_t n = CoordToOffset(ijk);
        if (DataType::mChildMask.isOn(n))
            return this->child(n)->probeValue(ijk, v);
        v = DataType::mTable[n].value;
        return DataType::mValueMask.isOn(n);
    }

    __attribute__((host)) __attribute__((device)) const LeafNodeType* probeLeaf(const CoordType& ijk) const
    {
        const uint32_t n = CoordToOffset(ijk);
        if (DataType::mChildMask.isOn(n))
            return this->child(n)->probeLeaf(ijk);
        return nullptr;
    }


    __attribute__((host)) __attribute__((device)) static uint32_t CoordToOffset(const CoordType& ijk)
    {





        return (((ijk[0] & MASK) >> ChildT::TOTAL) << (2 * LOG2DIM)) |
               (((ijk[1] & MASK) >> ChildT::TOTAL) << (LOG2DIM)) |
               ((ijk[2] & MASK) >> ChildT::TOTAL);

    }

    __attribute__((host)) __attribute__((device)) static Coord OffsetToLocalCoord(uint32_t n)
    {
        
# 2901 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 2901 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       n < SIZE
# 2901 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 2901 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "n < SIZE"
# 2901 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 2901, __PRETTY_FUNCTION__))
# 2901 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                               ;
        const uint32_t m = n & ((1 << 2 * LOG2DIM) - 1);
        return Coord(n >> 2 * LOG2DIM, m >> LOG2DIM, m & ((1 << LOG2DIM) - 1));
    }

    __attribute__((host)) __attribute__((device)) void localToGlobalCoord(Coord& ijk) const
    {
        ijk <<= ChildT::TOTAL;
        ijk += this->origin();
    }

    __attribute__((host)) __attribute__((device)) Coord offsetToGlobalCoord(uint32_t n) const
    {
        Coord ijk = InternalNode::OffsetToLocalCoord(n);
        this->localToGlobalCoord(ijk);
        return ijk;
    }


    __attribute__((host)) __attribute__((device)) bool isActive() const
    {
        return DataType::mFlags & uint32_t(2);
    }

private:
    static_assert(sizeof(DataType) % 32 == 0, "sizeof(InternalData) is misaligned");


    template<typename, int, int, int>
    friend class ReadAccessor;

    template<typename>
    friend class RootNode;
    template<typename, uint32_t>
    friend class InternalNode;


    template<typename AccT>
    __attribute__((host)) __attribute__((device)) const ValueType& getValueAndCache(const CoordType& ijk, const AccT& acc) const
    {
        const uint32_t n = CoordToOffset(ijk);
        if (!DataType::mChildMask.isOn(n))
            return DataType::mTable[n].value;
        const ChildT* child = this->child(n);
        acc.insert(ijk, child);
        return child->getValueAndCache(ijk, acc);
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) typename AccT::NodeInfo getNodeInfoAndCache(const CoordType& ijk, const AccT& acc) const
    {
        using NodeInfoT = typename AccT::NodeInfo;
        const uint32_t n = CoordToOffset(ijk);
        if (!DataType::mChildMask.isOn(n)) {
            return NodeInfoT{LEVEL, this->dim(), this->valueMin(), this->valueMax(), this->average(),
                             this->stdDeviation(), this->bbox()[0], this->bbox()[1]};
        }
        const ChildT* child = this->child(n);
        acc.insert(ijk, child);
        return child->getNodeInfoAndCache(ijk, acc);
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) bool isActiveAndCache(const CoordType& ijk, const AccT& acc) const
    {
        const uint32_t n = CoordToOffset(ijk);
        if (!DataType::mChildMask.isOn(n))
            return DataType::mValueMask.isOn(n);
        const ChildT* child = this->child(n);
        acc.insert(ijk, child);
        return child->isActiveAndCache(ijk, acc);
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) bool probeValueAndCache(const CoordType& ijk, ValueType& v, const AccT& acc) const
    {
        const uint32_t n = CoordToOffset(ijk);
        if (!DataType::mChildMask.isOn(n)) {
            v = DataType::mTable[n].value;
            return DataType::mValueMask.isOn(n);
        }
        const ChildT* child = this->child(n);
        acc.insert(ijk, child);
        return child->probeValueAndCache(ijk, v, acc);
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) const LeafNodeType* probeLeafAndCache(const CoordType& ijk, const AccT& acc) const
    {
        const uint32_t n = CoordToOffset(ijk);
        if (!DataType::mChildMask.isOn(n))
            return nullptr;
        const ChildT* child = this->child(n);
        acc.insert(ijk, child);
        return child->probeLeafAndCache(ijk, acc);
    }

    template<typename RayT, typename AccT>
    __attribute__((host)) __attribute__((device)) uint32_t getDimAndCache(const CoordType& ijk, const RayT& ray, const AccT& acc) const
    {
        if (DataType::mFlags & uint32_t(1))
            this->dim();


        const uint32_t n = CoordToOffset(ijk);
        if (DataType::mChildMask.isOn(n)) {
            const ChildT* child = this->child(n);
            acc.insert(ijk, child);
            return child->getDimAndCache(ijk, ray, acc);
        }
        return ChildNodeType::dim();
    }

};






template<typename ValueT, typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
struct alignas(32) LeafData
{
    static_assert(sizeof(CoordT) == sizeof(Coord), "Mismatching sizeof");
    static_assert(sizeof(MaskT<LOG2DIM>) == sizeof(Mask<LOG2DIM>), "Mismatching sizeof");
    using ValueType = ValueT;
    using BuildType = ValueT;
    using FloatType = typename FloatTraits<ValueT>::FloatType;

    CoordT mBBoxMin;
    uint8_t mBBoxDif[3];
    uint8_t mFlags;
    MaskT<LOG2DIM> mValueMask;

    ValueType mMinimum;
    ValueType mMaximum;
    FloatType mAverage;
    FloatType mStdDevi;
    alignas(32) ValueType mValues[1u << 3 * LOG2DIM];

    __attribute__((host)) __attribute__((device)) const ValueType* values() const { return mValues; }
    __attribute__((host)) __attribute__((device)) const ValueType& value(uint32_t i) const { return mValues[i]; }
    __attribute__((host)) __attribute__((device)) void setValueOnly(uint32_t offset, const ValueType& value) { mValues[offset] = value; }
    __attribute__((host)) __attribute__((device)) void setValue(uint32_t offset, const ValueType& value)
    {
        mValueMask.setOn(offset);
        mValues[offset] = value;
    }

    __attribute__((host)) __attribute__((device)) const ValueType& valueMin() const { return mMinimum; }
    __attribute__((host)) __attribute__((device)) const ValueType& valueMax() const { return mMaximum; }
    __attribute__((host)) __attribute__((device)) const FloatType& average() const { return mAverage; }
    __attribute__((host)) __attribute__((device)) const FloatType& stdDeviation() const { return mStdDevi; }

    __attribute__((host)) __attribute__((device)) void setMin(const ValueType& v) { mMinimum = v; }
    __attribute__((host)) __attribute__((device)) void setMax(const ValueType& v) { mMaximum = v; }
    __attribute__((host)) __attribute__((device)) void setAvg(const FloatType& v) { mAverage = v; }
    __attribute__((host)) __attribute__((device)) void setStd(const FloatType& v) { mStdDevi = v; }


    LeafData() = delete;
    LeafData(const LeafData&) = delete;
    LeafData& operator=(const LeafData&) = delete;
    ~LeafData() = delete;
};


template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
struct alignas(32) LeafData<bool, CoordT, MaskT, LOG2DIM>
{
    static_assert(sizeof(CoordT) == sizeof(Coord), "Mismatching sizeof");
    static_assert(sizeof(MaskT<LOG2DIM>) == sizeof(Mask<LOG2DIM>), "Mismatching sizeof");
    using ValueType = bool;
    using BuildType = bool;
    using FloatType = bool;
    static const bool sOn, sOff;

    CoordT mBBoxMin;
    uint8_t mBBoxDif[3];
    uint8_t mFlags;
    MaskT<LOG2DIM> mValueMask;
    MaskT<LOG2DIM> mValues;

    __attribute__((host)) __attribute__((device)) const ValueType* values() const { return nullptr; }
    __attribute__((host)) __attribute__((device)) const ValueType& value(uint32_t i) const
    {
        return mValues.isOn(i) ? sOn : sOff;
    }
    __attribute__((host)) __attribute__((device)) const ValueType& valueMin() const { return sOff; }
    __attribute__((host)) __attribute__((device)) const ValueType& valueMax() const { return sOff; }
    __attribute__((host)) __attribute__((device)) const FloatType& average() const { return sOff; }
    __attribute__((host)) __attribute__((device)) const FloatType& stdDeviation() const { return sOff; }
    __attribute__((host)) __attribute__((device)) void setValue(uint32_t offset, bool v)
    {
        mValueMask.setOn(offset);
        mValues.set(offset, v);
    }

    __attribute__((host)) __attribute__((device)) void setMin(const ValueType&) {}
    __attribute__((host)) __attribute__((device)) void setMax(const ValueType&) {}
    __attribute__((host)) __attribute__((device)) void setAvg(const FloatType&) {}
    __attribute__((host)) __attribute__((device)) void setStd(const FloatType&) {}


    LeafData() = delete;
    LeafData(const LeafData&) = delete;
    LeafData& operator=(const LeafData&) = delete;
    ~LeafData() = delete;
};

template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
const bool LeafData<bool, CoordT, MaskT, LOG2DIM>::sOn = true;
template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
const bool LeafData<bool, CoordT, MaskT, LOG2DIM>::sOff = false;


template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
struct alignas(32) LeafData<ValueMask, CoordT, MaskT, LOG2DIM>
{
    static_assert(sizeof(CoordT) == sizeof(Coord), "Mismatching sizeof");
    static_assert(sizeof(MaskT<LOG2DIM>) == sizeof(Mask<LOG2DIM>), "Mismatching sizeof");
    using ValueType = bool;
    using BuildType = ValueMask;
    using FloatType = bool;
    static const bool sOn, sOff;

    CoordT mBBoxMin;
    uint8_t mBBoxDif[3];
    uint8_t mFlags;
    MaskT<LOG2DIM> mValueMask;

    __attribute__((host)) __attribute__((device)) const ValueType* values() const { return nullptr; }
    __attribute__((host)) __attribute__((device)) const ValueType& value(uint32_t i) const
    {
        return mValueMask.isOn(i) ? sOn : sOff;
    }
    __attribute__((host)) __attribute__((device)) const ValueType& valueMin() const { return sOff; }
    __attribute__((host)) __attribute__((device)) const ValueType& valueMax() const { return sOff; }
    __attribute__((host)) __attribute__((device)) const FloatType& average() const { return sOff; }
    __attribute__((host)) __attribute__((device)) const FloatType& stdDeviation() const { return sOff; }
    __attribute__((host)) __attribute__((device)) void setValue(uint32_t offset, bool)
    {
        mValueMask.setOn(offset);
    }

    __attribute__((host)) __attribute__((device)) void setMin(const ValueType&) {}
    __attribute__((host)) __attribute__((device)) void setMax(const ValueType&) {}
    __attribute__((host)) __attribute__((device)) void setAvg(const FloatType&) {}
    __attribute__((host)) __attribute__((device)) void setStd(const FloatType&) {}


    LeafData() = delete;
    LeafData(const LeafData&) = delete;
    LeafData& operator=(const LeafData&) = delete;
    ~LeafData() = delete;
};

template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
const bool LeafData<ValueMask, CoordT, MaskT, LOG2DIM>::sOn = true;
template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
const bool LeafData<ValueMask, CoordT, MaskT, LOG2DIM>::sOff = false;


template<typename BuildT,
         typename CoordT = Coord,
         template<uint32_t> class MaskT = Mask,
         uint32_t Log2Dim = 3>
class LeafNode : private LeafData<BuildT, CoordT, MaskT, Log2Dim>
{
public:
    struct ChildNodeType
    {
        __attribute__((host)) __attribute__((device)) static uint32_t dim() { return 1u; }
    };
    using LeafNodeType = LeafNode<BuildT, CoordT, MaskT, Log2Dim>;
    using DataType = LeafData<BuildT, CoordT, MaskT, Log2Dim>;
    using ValueType = typename DataType::ValueType;
    using FloatType = typename DataType::FloatType;
    using BuildType = typename DataType::BuildType;
    using CoordType = CoordT;
    template<uint32_t LOG2>
    using MaskType = MaskT<LOG2>;

    static constexpr uint32_t LOG2DIM = Log2Dim;
    static constexpr uint32_t TOTAL = LOG2DIM;
    static constexpr uint32_t DIM = 1u << TOTAL;
    static constexpr uint32_t SIZE = 1u << 3 * LOG2DIM;
    static constexpr uint32_t MASK = (1u << LOG2DIM) - 1u;
    static constexpr uint32_t LEVEL = 0;
    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL);

    __attribute__((host)) __attribute__((device)) DataType* data() { return reinterpret_cast<DataType*>(this); }

    __attribute__((host)) __attribute__((device)) const DataType* data() const { return reinterpret_cast<const DataType*>(this); }


    __attribute__((host)) __attribute__((device)) const MaskType<LOG2DIM>& valueMask() const { return DataType::mValueMask; }


    __attribute__((host)) __attribute__((device)) const ValueType* voxels() const { return DataType::values(); }


    __attribute__((host)) __attribute__((device)) const ValueType& valueMin() const { return DataType::valueMin(); }


    __attribute__((host)) __attribute__((device)) const ValueType& valueMax() const { return DataType::valueMax(); }


    __attribute__((host)) __attribute__((device)) const FloatType& average() const { return DataType::average(); }


    __attribute__((host)) __attribute__((device)) FloatType variance() const { return DataType::stdDeviation()*DataType::stdDeviation(); }


    __attribute__((host)) __attribute__((device)) const FloatType& stdDeviation() const { return DataType::stdDeviation(); }

    __attribute__((host)) __attribute__((device)) uint8_t flags() const { return DataType::mFlags; }


    __attribute__((host)) __attribute__((device)) CoordT origin() const { return DataType::mBBoxMin & ~MASK; }

    __attribute__((host)) __attribute__((device)) static CoordT OffsetToLocalCoord(uint32_t n)
    {
        
# 3224 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 3224 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       n < SIZE
# 3224 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 3224 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "n < SIZE"
# 3224 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 3224, __PRETTY_FUNCTION__))
# 3224 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                               ;
        const uint32_t m = n & ((1 << 2 * LOG2DIM) - 1);
        return CoordT(n >> 2 * LOG2DIM, m >> LOG2DIM, m & MASK);
    }


    __attribute__((host)) __attribute__((device)) void localToGlobalCoord(Coord& ijk) const { ijk += this->origin(); }

    __attribute__((host)) __attribute__((device)) CoordT offsetToGlobalCoord(uint32_t n) const
    {
        return OffsetToLocalCoord(n) + this->origin();
    }


    __attribute__((host)) __attribute__((device)) static uint32_t dim() { return 1u << LOG2DIM; }


    __attribute__((host)) __attribute__((device)) BBox<CoordT> bbox() const
    {
        BBox<CoordT> bbox(DataType::mBBoxMin, DataType::mBBoxMin);
        if ( this->isActive() ) {
            bbox.max()[0] += DataType::mBBoxDif[0];
            bbox.max()[1] += DataType::mBBoxDif[1];
            bbox.max()[2] += DataType::mBBoxDif[2];
        } else {
            bbox = BBox<CoordT>();
        }
        return bbox;
    }


    __attribute__((host)) __attribute__((device)) static uint32_t voxelCount() { return 1u << (3 * LOG2DIM); }


    __attribute__((host)) __attribute__((device)) static uint64_t memUsage() { return sizeof(LeafNodeType); }


    LeafNode() = delete;
    LeafNode(const LeafNode&) = delete;
    LeafNode& operator=(const LeafNode&) = delete;
    ~LeafNode() = delete;


    __attribute__((host)) __attribute__((device)) const ValueType& getValue(uint32_t offset) const { return DataType::value(offset); }


    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordT& ijk) const { return DataType::value(CoordToOffset(ijk)); }




    __attribute__((host)) __attribute__((device)) void setValue(const CoordT& ijk, const ValueType& v) { DataType::setValue(CoordToOffset(ijk), v); }




    __attribute__((host)) __attribute__((device)) void setValueOnly(uint32_t offset, const ValueType& v) { DataType::setValueOnly(offset, v); }
    __attribute__((host)) __attribute__((device)) void setValueOnly(const CoordT& ijk, const ValueType& v) { DataType::setValueOnly(CoordToOffset(ijk), v); }


    __attribute__((host)) __attribute__((device)) bool isActive(const CoordT& ijk) const { return DataType::mValueMask.isOn(CoordToOffset(ijk)); }
    __attribute__((host)) __attribute__((device)) bool isActive(uint32_t n) const { return DataType::mValueMask.isOn(n); }


    __attribute__((host)) __attribute__((device)) bool isActive() const
    {
        
# 3290 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 3290 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       bool(DataType::mFlags & uint8_t(2)) != DataType::mValueMask.isOff()
# 3290 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 3290 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "bool(DataType::mFlags & uint8_t(2)) != DataType::mValueMask.isOff()"
# 3290 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 3290, __PRETTY_FUNCTION__))
# 3290 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                                                            ;
        return DataType::mFlags & uint8_t(2);
    }



    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordT& ijk, ValueType& v) const
    {
        const uint32_t n = CoordToOffset(ijk);
        v = DataType::value(n);
        return DataType::mValueMask.isOn(n);
    }

    __attribute__((host)) __attribute__((device)) const LeafNode* probeLeaf(const CoordT&) const { return this; }


    __attribute__((host)) __attribute__((device)) static uint32_t CoordToOffset(const CoordT& ijk)
    {



        return ((ijk[0] & MASK) << (2 * LOG2DIM)) | ((ijk[1] & MASK) << LOG2DIM) | (ijk[2] & MASK);

    }
# 3322 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
    __attribute__((host)) __attribute__((device)) void updateBBox();

private:
    static_assert(sizeof(DataType) % 32 == 0, "sizeof(LeafData) is misaligned");


    template<typename, int, int, int>
    friend class ReadAccessor;

    template<typename>
    friend class RootNode;
    template<typename, uint32_t>
    friend class InternalNode;


    template<typename AccT>
    __attribute__((host)) __attribute__((device)) const ValueType& getValueAndCache(const CoordT& ijk, const AccT&) const { return this->getValue(ijk); }


    template<typename AccT>
    __attribute__((host)) __attribute__((device)) typename AccT::NodeInfo getNodeInfoAndCache(const CoordType& , const AccT& ) const {
        using NodeInfoT = typename AccT::NodeInfo;
        return NodeInfoT{LEVEL, this->dim(), this->valueMin(), this->valueMax(),
                         this->average(), this->stdDeviation(), this->bbox()[0], this->bbox()[1]};
    }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) bool isActiveAndCache(const CoordT& ijk, const AccT&) const { return this->isActive(ijk); }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) bool probeValueAndCache(const CoordT& ijk, ValueType& v, const AccT&) const { return this->probeValue(ijk, v); }

    template<typename AccT>
    __attribute__((host)) __attribute__((device)) const LeafNode* probeLeafAndCache(const CoordT&, const AccT&) const { return this; }

    template<typename RayT, typename AccT>
    __attribute__((host)) __attribute__((device)) uint32_t getDimAndCache(const CoordT&, const RayT& , const AccT&) const
    {
        if (DataType::mFlags & uint8_t(1))
            return this->dim();

        return ChildNodeType::dim();
    }

};

template<typename ValueT, typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
inline void LeafNode<ValueT, CoordT, MaskT, LOG2DIM>::updateBBox()
{
    static_assert(LOG2DIM == 3, "LeafNode::updateBBox: only supports LOGDIM = 3!");
    if (!this->isActive()) return;
    auto update = [&](uint32_t min, uint32_t max, int axis) {
        
# 3374 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 3374 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       min <= max && max < 8
# 3374 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 3374 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "min <= max && max < 8"
# 3374 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 3374, __PRETTY_FUNCTION__))
# 3374 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                            ;
        DataType::mBBoxMin[axis] = (DataType::mBBoxMin[axis] & ~MASK) + int(min);
        DataType::mBBoxDif[axis] = uint8_t(max - min);
    };
    uint64_t word64 = DataType::mValueMask.template getWord<uint64_t>(0);
    uint32_t Xmin = word64 ? 0u : 8u;
    uint32_t Xmax = Xmin;
    for (int i = 1; i < 8; ++i) {
        if (uint64_t w = DataType::mValueMask.template getWord<uint64_t>(i)) {
            word64 |= w;
            if (Xmin == 8)
                Xmin = i;
            Xmax = i;
        }
    }
    
# 3389 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 3389 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   word64
# 3389 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 3389 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "word64"
# 3389 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 3389, __PRETTY_FUNCTION__))
# 3389 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                         ;
    update(Xmin, Xmax, 0);
    update(FindLowestOn(word64) >> 3, FindHighestOn(word64) >> 3, 1);
    const uint32_t *p = reinterpret_cast<const uint32_t*>(&word64), word32 = p[0] | p[1];
    const uint16_t *q = reinterpret_cast<const uint16_t*>(&word32), word16 = q[0] | q[1];
    const uint8_t *b = reinterpret_cast<const uint8_t* >(&word16), byte = b[0] | b[1];
    
# 3395 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ((
# 3395 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   byte
# 3395 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   ) ? static_cast<void> (0) : __assert_fail (
# 3395 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
   "byte"
# 3395 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
   , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 3395, __PRETTY_FUNCTION__))
# 3395 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                       ;
    update(FindLowestOn(static_cast<uint32_t>(byte)), FindHighestOn(static_cast<uint32_t>(byte)), 2);
}





template<typename BuildT>
using NanoLeaf = LeafNode<BuildT, Coord, Mask, 3>;
template<typename BuildT>
using NanoNode1 = InternalNode<NanoLeaf<BuildT>, 4>;
template<typename BuildT>
using NanoNode2 = InternalNode<NanoNode1<BuildT>, 5>;
template<typename BuildT>
using NanoRoot = RootNode<NanoNode2<BuildT>>;
template<typename BuildT>
using NanoTree = Tree<NanoRoot<BuildT>>;
template<typename BuildT>
using NanoGrid = Grid<NanoTree<BuildT>>;

using FloatTree = NanoTree<float>;
using DoubleTree = NanoTree<double>;
using Int32Tree = NanoTree<int32_t>;
using UInt32Tree = NanoTree<uint32_t>;
using Int64Tree = NanoTree<int64_t>;
using Vec3fTree = NanoTree<Vec3f>;
using Vec3dTree = NanoTree<Vec3d>;
using Vec3ITree = NanoTree<Vec3i>;
using MaskTree = NanoTree<ValueMask>;
using BoolTree = NanoTree<bool>;

using FloatGrid = Grid<FloatTree>;
using DoubleGrid = Grid<DoubleTree>;
using Int32Grid = Grid<Int32Tree>;
using UInt32Grid = Grid<UInt32Tree>;
using Int64Grid = Grid<Int64Tree>;
using Vec3fGrid = Grid<Vec3fTree>;
using Vec3dGrid = Grid<Vec3dTree>;
using Vec3IGrid = Grid<Vec3ITree>;
using MaskGrid = Grid<MaskTree>;
using BoolGrid = Grid<BoolTree>;
# 3459 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
template <typename ValueT>
class ReadAccessor<ValueT, -1, -1, -1>
{
    using RootT = NanoRoot<ValueT>;
    using FloatType = typename RootT::FloatType;
    using CoordValueType = typename RootT::CoordType::ValueType;

    mutable const RootT* mRoot;
public:
    using ValueType = ValueT;
    using CoordType = typename RootT::CoordType;

    static const int CacheLevels = 0;

    struct NodeInfo {
        uint32_t mLevel;
        uint32_t mDim;
        ValueType mMinimum;
        ValueType mMaximum;
        FloatType mAverage;
        FloatType mStdDevi;
        CoordType mBBoxMin;
        CoordType mBBoxMax;
    };


    __attribute__((host)) __attribute__((device)) ReadAccessor(const RootT& root) : mRoot{&root} {}

    __attribute__((host)) __attribute__((device)) const RootT& root() const { return *mRoot; }


    ReadAccessor(const ReadAccessor&) = default;
    ~ReadAccessor() = default;
    ReadAccessor& operator=(const ReadAccessor&) = default;

    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const
    {
        return mRoot->getValueAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) NodeInfo getNodeInfo(const CoordType& ijk) const
    {
        return mRoot->getNodeInfoAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const
    {
        return mRoot->isActiveAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const
    {
        return mRoot->probeValueAndCache(ijk, v, *this);
    }

    __attribute__((host)) __attribute__((device)) const NanoLeaf<ValueT>* probeLeaf(const CoordType& ijk) const
    {
        return mRoot->probeLeafAndCache(ijk, *this);
    }

    template<typename RayT>
    __attribute__((host)) __attribute__((device)) uint32_t getDim(const CoordType& ijk, const RayT& ray) const
    {
        return mRoot->getDimAndCache(ijk, ray, *this);
    }

private:

    template<typename>
    friend class RootNode;
    template<typename, uint32_t>
    friend class InternalNode;
    template<typename, typename, template<uint32_t> class, uint32_t>
    friend class LeafNode;


    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) void insert(const CoordType&, const NodeT*) const {}
};


template <typename ValueT, int LEVEL0>
class ReadAccessor<ValueT, LEVEL0, -1, -1>
{
    static_assert(LEVEL0 >= 0 && LEVEL0 <= 2, "LEVEL0 should be 0, 1, 2");

    using TreeT = NanoTree<ValueT>;
    using RootT = NanoRoot<ValueT>;
    using LeafT = NanoLeaf< ValueT>;
    using NodeT = typename TreeNode<TreeT, LEVEL0>::type;
    using CoordT = typename RootT::CoordType;

    using FloatType = typename RootT::FloatType;
    using CoordValueType = typename RootT::CoordT::ValueType;


    mutable CoordT mKey;
    mutable const RootT* mRoot;
    mutable const NodeT* mNode;

public:
    using ValueType = ValueT;
    using CoordType = CoordT;

    static const int CacheLevels = 1;

    using NodeInfo = typename ReadAccessor<ValueT, -1, -1, -1>::NodeInfo;


    __attribute__((host)) __attribute__((device)) ReadAccessor(const RootT& root)
        : mKey(CoordType::max())
        , mRoot(&root)
        , mNode(nullptr)
    {
    }

    __attribute__((host)) __attribute__((device)) const RootT& root() const { return *mRoot; }


    ReadAccessor(const ReadAccessor&) = default;
    ~ReadAccessor() = default;
    ReadAccessor& operator=(const ReadAccessor&) = default;

    __attribute__((host)) __attribute__((device)) bool isCached(const CoordType& ijk) const
    {
        return (ijk[0] & int32_t(~NodeT::MASK)) == mKey[0] &&
               (ijk[1] & int32_t(~NodeT::MASK)) == mKey[1] &&
               (ijk[2] & int32_t(~NodeT::MASK)) == mKey[2];
    }

    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const
    {
        if (this->isCached(ijk)) {
            return mNode->getValueAndCache(ijk, *this);
        }
        return mRoot->getValueAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) NodeInfo getNodeInfo(const CoordType& ijk) const
    {
        if (this->isCached(ijk)) {
            return mNode->getNodeInfoAndCache(ijk, *this);
        }
        return mRoot->getNodeInfoAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const
    {
        if (this->isCached(ijk)) {
            return mNode->isActiveAndCache(ijk, *this);
        }
        return mRoot->isActiveAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const
    {
        if (this->isCached(ijk)) {
            return mNode->probeValueAndCache(ijk, v, *this);
        }
        return mRoot->probeValueAndCache(ijk, v, *this);
    }

    __attribute__((host)) __attribute__((device)) const LeafT* probeLeaf(const CoordType& ijk) const
    {
        if (this->isCached(ijk)) {
            return mNode->probeLeafAndCache(ijk, *this);
        }
        return mRoot->probeLeafAndCache(ijk, *this);
    }

    template<typename RayT>
    __attribute__((host)) __attribute__((device)) uint32_t getDim(const CoordType& ijk, const RayT& ray) const
    {
        if (this->isCached(ijk)) {
            return mNode->getDimAndCache(ijk, ray, *this);
        }
        return mRoot->getDimAndCache(ijk, ray, *this);
    }

private:

    template<typename>
    friend class RootNode;
    template<typename, uint32_t>
    friend class InternalNode;
    template<typename, typename, template<uint32_t> class, uint32_t>
    friend class LeafNode;


    __attribute__((host)) __attribute__((device)) void insert(const CoordType& ijk, const NodeT* node) const
    {
        mKey = ijk & ~NodeT::MASK;
        mNode = node;
    }


    template<typename OtherNodeT>
    __attribute__((host)) __attribute__((device)) void insert(const CoordType&, const OtherNodeT*) const {}

};

template <typename ValueT, int LEVEL0, int LEVEL1>
class ReadAccessor<ValueT, LEVEL0, LEVEL1, -1>
{
    static_assert(LEVEL0 >=0 && LEVEL0 <=2, "LEVEL0 must be 0, 1, 2");
    static_assert(LEVEL1 >=0 && LEVEL1 <=2, "LEVEL1 must be 0, 1, 2");
    static_assert(LEVEL0 < LEVEL1, "Level 0 must be lower than level 1");
    using TreeT = NanoTree<ValueT>;
    using RootT = NanoRoot<ValueT>;
    using LeafT = NanoLeaf<ValueT>;
    using Node1T = typename TreeNode<TreeT, LEVEL0>::type;
    using Node2T = typename TreeNode<TreeT, LEVEL1>::type;
    using CoordT = typename RootT::CoordType;

    using FloatType = typename RootT::FloatType;
    using CoordValueType = typename RootT::CoordT::ValueType;



    mutable CoordT mKey;



    mutable const RootT* mRoot;
    mutable const Node1T* mNode1;
    mutable const Node2T* mNode2;

public:
    using ValueType = ValueT;
    using CoordType = CoordT;

    static const int CacheLevels = 2;

    using NodeInfo = typename ReadAccessor<ValueT,-1,-1,-1>::NodeInfo;


    __attribute__((host)) __attribute__((device)) ReadAccessor(const RootT& root)

        : mKey(CoordType::max())



        , mRoot(&root)
        , mNode1(nullptr)
        , mNode2(nullptr)
    {
    }

    __attribute__((host)) __attribute__((device)) const RootT& root() const { return *mRoot; }


    ReadAccessor(const ReadAccessor&) = default;
    ~ReadAccessor() = default;
    ReadAccessor& operator=(const ReadAccessor&) = default;


    __attribute__((host)) __attribute__((device)) bool isCached1(CoordValueType dirty) const
    {
        if (!mNode1)
            return false;
        if (dirty & int32_t(~Node1T::MASK)) {
            mNode1 = nullptr;
            return false;
        }
        return true;
    }
    __attribute__((host)) __attribute__((device)) bool isCached2(CoordValueType dirty) const
    {
        if (!mNode2)
            return false;
        if (dirty & int32_t(~Node2T::MASK)) {
            mNode2 = nullptr;
            return false;
        }
        return true;
    }
    __attribute__((host)) __attribute__((device)) CoordValueType computeDirty(const CoordType& ijk) const
    {
        return (ijk[0] ^ mKey[0]) | (ijk[1] ^ mKey[1]) | (ijk[2] ^ mKey[2]);
    }
# 3754 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached1(dirty)) {
            return mNode1->getValueAndCache(ijk, *this);
        } else if (this->isCached2(dirty)) {
            return mNode2->getValueAndCache(ijk, *this);
        }
        return mRoot->getValueAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) NodeInfo getNodeInfo(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached1(dirty)) {
            return mNode1->getNodeInfoAndCache(ijk, *this);
        } else if (this->isCached2(dirty)) {
            return mNode2->getNodeInfoAndCache(ijk, *this);
        }
        return mRoot->getNodeInfoAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached1(dirty)) {
            return mNode1->isActiveAndCache(ijk, *this);
        } else if (this->isCached2(dirty)) {
            return mNode2->isActiveAndCache(ijk, *this);
        }
        return mRoot->isActiveAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached1(dirty)) {
            return mNode1->probeValueAndCache(ijk, v, *this);
        } else if (this->isCached2(dirty)) {
            return mNode2->probeValueAndCache(ijk, v, *this);
        }
        return mRoot->probeValueAndCache(ijk, v, *this);
    }

    __attribute__((host)) __attribute__((device)) const LeafT* probeLeaf(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached1(dirty)) {
            return mNode1->probeLeafAndCache(ijk, *this);
        } else if (this->isCached2(dirty)) {
            return mNode2->probeLeafAndCache(ijk, *this);
        }
        return mRoot->probeLeafAndCache(ijk, *this);
    }

    template<typename RayT>
    __attribute__((host)) __attribute__((device)) uint32_t getDim(const CoordType& ijk, const RayT& ray) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached1(dirty)) {
            return mNode1->getDimAndCache(ijk, ray, *this);
        } else if (this->isCached2(dirty)) {
            return mNode2->getDimAndCache(ijk, ray, *this);
        }
        return mRoot->getDimAndCache(ijk, ray, *this);
    }

private:

    template<typename>
    friend class RootNode;
    template<typename, uint32_t>
    friend class InternalNode;
    template<typename, typename, template<uint32_t> class, uint32_t>
    friend class LeafNode;


    __attribute__((host)) __attribute__((device)) void insert(const CoordType& ijk, const Node1T* node) const
    {

        mKey = ijk;



        mNode1 = node;
    }
    __attribute__((host)) __attribute__((device)) void insert(const CoordType& ijk, const Node2T* node) const
    {

        mKey = ijk;



        mNode2 = node;
    }
    template <typename OtherNodeT>
    __attribute__((host)) __attribute__((device)) void insert(const CoordType&, const OtherNodeT*) const {}
};



template <typename ValueT>
class ReadAccessor<ValueT, 0, 1, 2>
{
    using TreeT = NanoTree<ValueT>;
    using RootT = NanoRoot<ValueT>;
    using NodeT2 = NanoNode2<ValueT>;
    using NodeT1 = NanoNode1<ValueT>;
    using LeafT = NanoLeaf< ValueT>;
    using CoordT = typename RootT::CoordType;

    using FloatType = typename RootT::FloatType;
    using CoordValueType = typename RootT::CoordT::ValueType;



    mutable CoordT mKey;



    mutable const RootT* mRoot;
    mutable const void* mNode[3];

public:
    using ValueType = ValueT;
    using CoordType = CoordT;

    static const int CacheLevels = 3;

    using NodeInfo = typename ReadAccessor<ValueT, -1, -1, -1>::NodeInfo;


    __attribute__((host)) __attribute__((device)) ReadAccessor(const RootT& root)

        : mKey(CoordType::max())



        , mRoot(&root)
        , mNode{nullptr, nullptr, nullptr}
    {
    }

    __attribute__((host)) __attribute__((device)) const RootT& root() const { return *mRoot; }


    ReadAccessor(const ReadAccessor&) = default;
    ~ReadAccessor() = default;
    ReadAccessor& operator=(const ReadAccessor&) = default;




    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) const NodeT* getNode() const
    {
        using T = typename TreeNode<TreeT, NodeT::LEVEL>::type;
        static_assert(is_same<T, NodeT>::value, "ReadAccessor::getNode: Invalid node type");
        return reinterpret_cast<const T*>(mNode[NodeT::LEVEL]);
    }


    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) bool isCached(CoordValueType dirty) const
    {
        if (!mNode[NodeT::LEVEL])
            return false;
        if (dirty & int32_t(~NodeT::MASK)) {
            mNode[NodeT::LEVEL] = nullptr;
            return false;
        }
        return true;
    }

    __attribute__((host)) __attribute__((device)) CoordValueType computeDirty(const CoordType& ijk) const
    {
        return (ijk[0] ^ mKey[0]) | (ijk[1] ^ mKey[1]) | (ijk[2] ^ mKey[2]);
    }
# 3964 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
    __attribute__((host)) __attribute__((device)) const ValueType& getValue(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached<LeafT>(dirty)) {
            return ((LeafT*)mNode[0])->getValue(ijk);
        } else if (this->isCached<NodeT1>(dirty)) {
            return ((NodeT1*)mNode[1])->getValueAndCache(ijk, *this);
        } else if (this->isCached<NodeT2>(dirty)) {
            return ((NodeT2*)mNode[2])->getValueAndCache(ijk, *this);
        }
        return mRoot->getValueAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) NodeInfo getNodeInfo(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached<LeafT>(dirty)) {
            return ((LeafT*)mNode[0])->getNodeInfoAndCache(ijk, *this);
        } else if (this->isCached<NodeT1>(dirty)) {
            return ((NodeT1*)mNode[1])->getNodeInfoAndCache(ijk, *this);
        } else if (this->isCached<NodeT2>(dirty)) {
            return ((NodeT2*)mNode[2])->getNodeInfoAndCache(ijk, *this);
        }
        return mRoot->getNodeInfoAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool isActive(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached<LeafT>(dirty)) {
            return ((LeafT*)mNode[0])->isActive(ijk);
        } else if (this->isCached<NodeT1>(dirty)) {
            return ((NodeT1*)mNode[1])->isActiveAndCache(ijk, *this);
        } else if (this->isCached<NodeT2>(dirty)) {
            return ((NodeT2*)mNode[2])->isActiveAndCache(ijk, *this);
        }
        return mRoot->isActiveAndCache(ijk, *this);
    }

    __attribute__((host)) __attribute__((device)) bool probeValue(const CoordType& ijk, ValueType& v) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached<LeafT>(dirty)) {
            return ((LeafT*)mNode[0])->probeValue(ijk, v);
        } else if (this->isCached<NodeT1>(dirty)) {
            return ((NodeT1*)mNode[1])->probeValueAndCache(ijk, v, *this);
        } else if (this->isCached<NodeT2>(dirty)) {
            return ((NodeT2*)mNode[2])->probeValueAndCache(ijk, v, *this);
        }
        return mRoot->probeValueAndCache(ijk, v, *this);
    }

    __attribute__((host)) __attribute__((device)) const LeafT* probeLeaf(const CoordType& ijk) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached<LeafT>(dirty)) {
            return ((LeafT*)mNode[0]);
        } else if (this->isCached<NodeT1>(dirty)) {
            return ((NodeT1*)mNode[1])->probeLeafAndCache(ijk, *this);
        } else if (this->isCached<NodeT2>(dirty)) {
            return ((NodeT2*)mNode[2])->probeLeafAndCache(ijk, *this);
        }
        return mRoot->probeLeafAndCache(ijk, *this);
    }

    template<typename RayT>
    __attribute__((host)) __attribute__((device)) uint32_t getDim(const CoordType& ijk, const RayT& ray) const
    {

        const CoordValueType dirty = this->computeDirty(ijk);



        if (this->isCached<LeafT>(dirty)) {
            return ((LeafT*)mNode[0])->getDimAndCache(ijk, ray, *this);
        } else if (this->isCached<NodeT1>(dirty)) {
            return ((NodeT1*)mNode[1])->getDimAndCache(ijk, ray, *this);
        } else if (this->isCached<NodeT2>(dirty)) {
            return ((NodeT2*)mNode[2])->getDimAndCache(ijk, ray, *this);
        }
        return mRoot->getDimAndCache(ijk, ray, *this);
    }

private:

    template<typename>
    friend class RootNode;
    template<typename, uint32_t>
    friend class InternalNode;
    template<typename, typename, template<uint32_t> class, uint32_t>
    friend class LeafNode;


    template<typename NodeT>
    __attribute__((host)) __attribute__((device)) void insert(const CoordType& ijk, const NodeT* node) const
    {

        mKey = ijk;



        mNode[NodeT::LEVEL] = node;
    }
};
# 4103 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
template <int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1, typename ValueT = float>
ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2> createAccessor(const NanoGrid<ValueT> &grid)
{
    return ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2>(grid.tree().root());
}

template <int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1, typename ValueT = float>
ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2> createAccessor(const NanoTree<ValueT> &tree)
{
    return ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2>(tree().root());
}

template <int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1, typename ValueT = float>
ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2> createAccessor(const NanoRoot<ValueT> &root)
{
    return ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2>(root);
}







class GridMetaData
{





    using GridT = NanoGrid<int>;
    __attribute__((host)) __attribute__((device)) const GridT& grid() const { return *reinterpret_cast<const GridT*>(this); }

public:
    __attribute__((host)) __attribute__((device)) bool isValid() const { return this->grid().isValid(); }
    __attribute__((host)) __attribute__((device)) uint64_t gridSize() const { return this->grid().gridSize(); }
    __attribute__((host)) __attribute__((device)) const char* gridName() const { return this->grid().gridName(); }
    __attribute__((host)) __attribute__((device)) GridType gridType() const { return this->grid().gridType(); }
    __attribute__((host)) __attribute__((device)) GridClass gridClass() const { return this->grid().gridClass(); }
    __attribute__((host)) __attribute__((device)) bool isLevelSet() const { return this->grid().isLevelSet(); }
    __attribute__((host)) __attribute__((device)) bool isFogVolume() const { return this->grid().isFogVolume(); }
    __attribute__((host)) __attribute__((device)) bool isPointIndex() const { return this->grid().isPointIndex(); }
    __attribute__((host)) __attribute__((device)) bool isPointData() const { return this->grid().isPointData(); }
    __attribute__((host)) __attribute__((device)) bool isMask() const { return this->grid().isMask(); }
    __attribute__((host)) __attribute__((device)) bool isStaggered() const { return this->grid().isStaggered(); }
    __attribute__((host)) __attribute__((device)) bool isUnknown() const { return this->grid().isUnknown(); }
    __attribute__((host)) __attribute__((device)) const Map& map() const { return this->grid().map(); }
    __attribute__((host)) __attribute__((device)) const BBox<Vec3R>& worldBBox() const { return this->grid().worldBBox(); }
    __attribute__((host)) __attribute__((device)) const BBox<Coord>& indexBBox() const { return this->grid().indexBBox(); }
    __attribute__((host)) __attribute__((device)) Vec3R voxelSize() const { return this->grid().voxelSize(); }
    __attribute__((host)) __attribute__((device)) int blindDataCount() const { return this->grid().blindDataCount(); }
    __attribute__((host)) __attribute__((device)) const GridBlindMetaData& blindMetaData(int n) const { return this->grid().blindMetaData(n); }
    __attribute__((host)) __attribute__((device)) uint64_t activeVoxelCount() const { return this->grid().activeVoxelCount(); }
    __attribute__((host)) __attribute__((device)) uint32_t nodeCount(uint32_t level) const { return this->grid().tree().nodeCount(level); }
    __attribute__((host)) __attribute__((device)) uint64_t checksum() const { return this->grid().checksum(); }
    __attribute__((host)) __attribute__((device)) bool isEmpty() const { return this->grid().isEmpty(); }
    __attribute__((host)) __attribute__((device)) Version version() const { return this->grid().version(); }
};


template<typename AttT>
class PointAccessor : public DefaultReadAccessor<uint32_t>
{
    using AccT = DefaultReadAccessor<uint32_t>;
    const UInt32Grid* mGrid;
    const AttT* mData;

public:
    using LeafNodeType = typename NanoRoot<uint32_t>::LeafNodeType;

    PointAccessor(const UInt32Grid& grid)
        : AccT(grid.tree().root())
        , mGrid(&grid)
        , mData(reinterpret_cast<const AttT*>(grid.blindData(0)))
    {
        
# 4179 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 4179 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       grid.gridType() == GridType::UInt32
# 4179 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 4179 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "grid.gridType() == GridType::UInt32"
# 4179 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 4179, __PRETTY_FUNCTION__))
# 4179 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                          ;
        
# 4180 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 4180 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       (grid.gridClass() == GridClass::PointIndex && is_same<uint32_t, AttT>::value) || (grid.gridClass() == GridClass::PointData && is_same<Vec3f, AttT>::value)
# 4180 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 4180 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "(grid.gridClass() == GridClass::PointIndex && is_same<uint32_t, AttT>::value) || (grid.gridClass() == GridClass::PointData && is_same<Vec3f, AttT>::value)"
# 4180 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 4180, __PRETTY_FUNCTION__))
                                                                                                 
# 4181 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                                                                ;
        
# 4182 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ((
# 4182 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       grid.blindDataCount() >= 1
# 4182 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 4182 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
       "grid.blindDataCount() >= 1"
# 4182 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h", 4182, __PRETTY_FUNCTION__))
# 4182 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/NanoVDB.h"
                                                 ;
    }


    __attribute__((host)) __attribute__((device)) uint64_t gridPoints(const AttT*& begin, const AttT*& end) const
    {
        const uint64_t count = mGrid->blindMetaData(0).mElementCount;
        begin = mData;
        end = begin + count;
        return count;
    }



    __attribute__((host)) __attribute__((device)) uint64_t leafPoints(const Coord& ijk, const AttT*& begin, const AttT*& end) const
    {
        auto* leaf = this->probeLeaf(ijk);
        if (leaf == nullptr) {
            return 0;
        }
        begin = mData + leaf->valueMin();
        end = begin + leaf->valueMax();
        return leaf->valueMax();
    }


    __attribute__((host)) __attribute__((device)) uint64_t voxelPoints(const Coord& ijk, const AttT*& begin, const AttT*& end) const
    {
        auto* leaf = this->probeLeaf(ijk);
        if (leaf == nullptr)
            return 0;
        const uint32_t offset = LeafNodeType::CoordToOffset(ijk);
        if (leaf->isActive(offset)) {
            auto* p = mData + leaf->valueMin();
            begin = p + (offset == 0 ? 0 : leaf->getValue(offset - 1));
            end = p + leaf->getValue(offset);
            return end - begin;
        }
        return 0;
    }
};

}
# 11 "/beegfs/teran_parrales/NVISII/include/nvisii/volume_struct.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/GridHandle.h" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/GridHandle.h"
# 1 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/../NanoVDB.h" 1
# 21 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/GridHandle.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/HostBuffer.h" 1
# 20 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/HostBuffer.h"
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
# 21 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/HostBuffer.h" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdlib" 3
# 22 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/HostBuffer.h" 2






namespace nanovdb {




class HostBuffer
{
    uint64_t mSize;
    uint8_t* mData;
# 48 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/HostBuffer.h"
    static inline void ptrAssert(void*, const char*, const char*, int, bool = true)
    {
    }


public:
    HostBuffer(uint64_t size = 0)
        : mSize(0)
        , mData(nullptr)
    {
        this->init(size);
    }

    HostBuffer(const HostBuffer&) = delete;

    HostBuffer(HostBuffer&& other) noexcept
        : mSize(other.mSize)
        , mData(other.mData)
    {
        other.mSize = 0;
        other.mData = nullptr;
    }

    HostBuffer& operator=(const HostBuffer&) = delete;

    HostBuffer& operator=(HostBuffer&& other) noexcept
    {
        clear();
        mSize = other.mSize;
        mData = other.mData;
        other.mSize = 0;
        other.mData = nullptr;
        return *this;
    }

    ~HostBuffer() { this->clear(); };

    void init(uint64_t size);




    const uint8_t* data() const { return mData; }
    uint8_t* data() { return mData; }


    uint64_t size() const { return mSize; }


    bool empty() const { return mSize == 0; }


    void clear();

    static HostBuffer create(uint64_t size, const HostBuffer* context = nullptr);

};



inline HostBuffer HostBuffer::create(uint64_t size, const HostBuffer*)
{
    return HostBuffer(size);
}

inline void HostBuffer::init(uint64_t size)
{
    if (size == mSize)
        return;
    if (mSize > 0)
        this->clear();
    if (size == 0)
        return;
    mSize = size;
    mData = static_cast<uint8_t*>(std::malloc(size));
    { ptrAssert((mData), ("failed to allocate host data"), "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/HostBuffer.h", 123); };
}

inline void HostBuffer::clear()
{
    std::free(mData);
    mData = nullptr;
    mSize = 0;
}

}
# 22 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/GridHandle.h" 2

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 1 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
       
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3





# 44 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 70 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 118 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 157 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 198 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 239 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 276 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };







  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 698 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };
# 805 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3
  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;
# 840 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/codecvt.h" 3

}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 2 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 3


# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++io.h" 1 3
# 35 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++io.h" 3
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cstdio" 3
# 36 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/x86_64-pc-linux-gnu/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);






      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 2 3
# 52 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Path, typename _Result = _Path, typename _Path2
    = decltype(std::declval<_Path&>().make_preferred().filename())>
    using _If_fs_path = enable_if_t<is_same_v<_Path, _Path2>, _Result>;
# 84 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 160 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      {
 try
   { this->close(); }
 catch(...)
   { }
      }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 314 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 335 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 346 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, __filebuf_type*>
 open(const _Path& __s, ios_base::openmode __mode)
 { return open(__s.c_str(), __mode); }
# 365 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 397 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 417 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 463 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 496 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 523 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 533 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 566 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 583 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      template<typename _Path, typename _Require = _If_fs_path<_Path>>
 basic_ifstream(const _Path& __s,
         ios_base::openmode __mode = ios_base::in)
 : basic_ifstream(__s.c_str(), __mode)
 { }


      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 604 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 636 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 662 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 701 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 721 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, void>
 open(const _Path& __s, ios_base::openmode __mode = ios_base::in)
 { open(__s.c_str(), __mode); }
# 734 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 757 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 784 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 794 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 829 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 846 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      template<typename _Path, typename _Require = _If_fs_path<_Path>>
 basic_ofstream(const _Path& __s,
         ios_base::openmode __mode = ios_base::out)
 : basic_ofstream(__s.c_str(), __mode)
 { }


      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 867 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 899 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 925 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 964 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 984 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, void>
 open(const _Path& __s, ios_base::openmode __mode = ios_base::out)
 { open(__s.c_str(), __mode); }
# 997 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 1020 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 1048 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }






      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 1087 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      template<typename _Path, typename _Require = _If_fs_path<_Path>>
 basic_fstream(const _Path& __s,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
 : basic_fstream(__s.c_str(), __mode)
 { }


      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 1123 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 1155 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1181 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1222 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1243 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      template<typename _Path>
 _If_fs_path<_Path, void>
 open(const _Path& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
 { open(__s.c_str(), __mode); }
# 1257 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}

# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/fstream.tcc" 1 3
# 37 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/fstream.tcc" 3
       
# 38 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/fstream.tcc" 3



# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 1 3
# 39 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 3
       
# 40 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 43 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/cerrno" 2 3
# 42 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/fstream.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }
# 247 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/fstream.tcc" 3
  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(...)
   {
     _M_file.close();
     throw;
   }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             , (*__errno_location ()));
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
   if (overflow() == traits_type::eof())
     return __ret;
   _M_set_buffer(-1);
   _M_writing = false;
 }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
   && __testin)
 {

   const streamsize __avail = this->egptr() - this->gptr();
   if (__avail != 0)
     {
       traits_type::copy(__s, this->gptr(), __avail);
       __s += __avail;
       this->setg(this->eback(), this->gptr() + __avail, this->egptr());
       __ret += __avail;
       __n -= __avail;
     }



   streamsize __len;
   for (;;)
     {
       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s), __n);
       if (__len == -1)
  __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                              , (*__errno_location ()));
       if (__len == 0)
  break;

       __n -= __len;
       __ret += __len;
       if (__n == 0)
  break;

       __s += __len;
     }

   if (__n == 0)
     {

       _M_reading = true;
     }
   else if (__len == 0)
     {



       _M_set_buffer(-1);
       _M_reading = false;
     }
 }
      else
 __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
   && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 820 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

       off_type __file_off = _M_file.seekoff(0, ios_base::cur);
       if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1299 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/fstream" 2 3
# 24 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/GridHandle.h" 2





# 28 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/GridHandle.h"
namespace nanovdb {

template<typename BufferT>
struct BufferTraits
{
    static const bool hasDeviceDual = false;
};



class GridHandleBase
{
public:
    virtual ~GridHandleBase() {}


    virtual uint64_t size() const = 0;

    virtual uint8_t* data() = 0;
    virtual const uint8_t* data() const = 0;


    bool empty() const { return size() == 0; }


    operator bool() const { return !empty(); }




    const GridMetaData* gridMetaData() const { return reinterpret_cast<const GridMetaData*>(data()); }


    GridType gridType() const
    {
        const GridMetaData* ptr = this->gridMetaData();
        return ptr ? ptr->gridType() : GridType::End;
    }
};






template<typename BufferT = HostBuffer>
class GridHandle : public GridHandleBase
{
    BufferT mBuffer;

public:
    GridHandle(BufferT&& resources);

    GridHandle() = default;

    GridHandle(const GridHandle&) = delete;

    GridHandle& operator=(const GridHandle&) = delete;

    GridHandle& operator=(GridHandle&& other) noexcept
    {
        mBuffer = std::move(other.mBuffer);
        return *this;
    }

    GridHandle(GridHandle&& other) noexcept
    {
        mBuffer = std::move(other.mBuffer);
    }

    ~GridHandle() override { reset(); }

    void reset() { mBuffer.clear(); }

    BufferT& buffer() { return mBuffer; }
    const BufferT& buffer() const { return mBuffer; }




    uint8_t* data() override
    {
        return mBuffer.data();
    }




    const uint8_t* data() const override
    {
        return mBuffer.data();
    }


    uint64_t size() const override
    {
        return mBuffer.size();
    }





    template<typename ValueT>
    const NanoGrid<ValueT>* grid() const;

    template<typename ValueT>
    NanoGrid<ValueT>* grid();

    template<typename ValueT, typename U = BufferT>
    typename std::enable_if<BufferTraits<U>::hasDeviceDual, const NanoGrid<ValueT>*>::type
    deviceGrid() const;

    template<typename U = BufferT>
    typename std::enable_if<BufferTraits<U>::hasDeviceDual, void>::type
    deviceUpload(void* stream = nullptr, bool sync = true);

    template<typename U = BufferT>
    typename std::enable_if<BufferTraits<U>::hasDeviceDual, void>::type
    deviceDownload(void* stream = nullptr, bool sync = true);
};



template<typename BufferT>
GridHandle<BufferT>::GridHandle(BufferT&& resources)
{
    mBuffer = std::move(resources);
}

template<typename BufferT>
template<typename ValueT>
inline const NanoGrid<ValueT>* GridHandle<BufferT>::grid() const
{
    using GridT = const NanoGrid<ValueT>;
    GridT* grid = reinterpret_cast<GridT*>(mBuffer.data());
    return (grid && grid->gridType() == mapToGridType<ValueT>()) ? grid : nullptr;
}

template<typename BufferT>
template<typename ValueT>
inline NanoGrid<ValueT>* GridHandle<BufferT>::grid()
{
    using GridT = NanoGrid<ValueT>;
    GridT* grid = reinterpret_cast<GridT*>(mBuffer.data());
    return (grid && grid->gridType() == mapToGridType<ValueT>()) ? grid : nullptr;
}

template<typename BufferT>
template<typename ValueT, typename U>
inline typename std::enable_if<BufferTraits<U>::hasDeviceDual, const NanoGrid<ValueT>*>::type
GridHandle<BufferT>::deviceGrid() const
{
    using GridT = const NanoGrid<ValueT>;
    GridT* grid = reinterpret_cast<GridT*>(mBuffer.deviceData());
    return (grid && this->gridMetaData()->gridType() == mapToGridType<ValueT>()) ? grid : nullptr;
}

template<typename BufferT>
template<typename U>
inline typename std::enable_if<BufferTraits<U>::hasDeviceDual, void>::type GridHandle<BufferT>::deviceUpload(void* stream, bool sync)
{
    mBuffer.deviceUpload(stream, sync);
}

template<typename BufferT>
template<typename U>
inline typename std::enable_if<BufferTraits<U>::hasDeviceDual, void>::type GridHandle<BufferT>::deviceDownload(void* stream, bool sync)
{
    mBuffer.deviceDownload(stream, sync);
}

}
# 12 "/beegfs/teran_parrales/NVISII/include/nvisii/volume_struct.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 1
# 15 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
namespace nanovdb {

template<typename RealT>
class Ray
{
public:
    using RealType = RealT;
    using Vec3Type = Vec3<RealT>;
    using Vec3T = Vec3Type;

    struct TimeSpan
    {
        RealT t0, t1;

        __attribute__((host)) __attribute__((device)) TimeSpan() {}

        __attribute__((host)) __attribute__((device)) TimeSpan(RealT _t0, RealT _t1)
            : t0(_t0)
            , t1(_t1)
        {
        }

        __attribute__((host)) __attribute__((device)) void set(RealT _t0, RealT _t1)
        {
            t0 = _t0;
            t1 = _t1;
        }

        __attribute__((host)) __attribute__((device)) void get(RealT& _t0, RealT& _t1) const
        {
            _t0 = t0;
            _t1 = t1;
        }

        __attribute__((host)) __attribute__((device)) bool valid(RealT eps = Delta<RealT>::value()) const { return (t1 - t0) > eps; }

        __attribute__((host)) __attribute__((device)) RealT mid() const { return 0.5 * (t0 + t1); }

        __attribute__((host)) __attribute__((device)) void scale(RealT s)
        {
            
# 55 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 3 4
           ((
# 55 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
           s > 0
# 55 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 3 4
           ) ? static_cast<void> (0) : __assert_fail (
# 55 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
           "s > 0"
# 55 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 3 4
           , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h", 55, __PRETTY_FUNCTION__))
# 55 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
                        ;
            t0 *= s;
            t1 *= s;
        }

        __attribute__((host)) __attribute__((device)) bool test(RealT t) const { return (t >= t0 && t <= t1); }
    };

    __attribute__((host)) __attribute__((device)) Ray(const Vec3Type& eye = Vec3Type(0, 0, 0),
                    const Vec3Type& direction = Vec3Type(1, 0, 0),
                    RealT t0 = Delta<RealT>::value(),
                    RealT t1 = Maximum<RealT>::value())
        : mEye(eye)
        , mDir(direction)
        , mInvDir(1 / mDir[0], 1 / mDir[1], 1 / mDir[2])
        , mTimeSpan(t0, t1)
        , mSign{mInvDir[0] < 0, mInvDir[1] < 0, mInvDir[2] < 0}
    {
    }

    __attribute__((host)) __attribute__((device)) Ray& offsetEye(RealT offset)
    {
        mEye[0] += offset;
        mEye[1] += offset;
        mEye[2] += offset;
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& setEye(const Vec3Type& eye)
    {
        mEye = eye;
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& setDir(const Vec3Type& dir)
    {
        mDir = dir;
        mInvDir[0] = 1.0 / mDir[0];
        mInvDir[1] = 1.0 / mDir[1];
        mInvDir[2] = 1.0 / mDir[2];
        mSign[0] = mInvDir[0] < 0;
        mSign[1] = mInvDir[1] < 0;
        mSign[2] = mInvDir[2] < 0;
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& setMinTime(RealT t0)
    {
        mTimeSpan.t0 = t0;
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& setMaxTime(RealT t1)
    {
        mTimeSpan.t1 = t1;
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& setTimes(
        RealT t0 = Delta<RealT>::value(),
        RealT t1 = Maximum<RealT>::value())
    {
        
# 117 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 3 4
       ((
# 117 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
       t0 > 0 && t1 > 0
# 117 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 3 4
       ) ? static_cast<void> (0) : __assert_fail (
# 117 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
       "t0 > 0 && t1 > 0"
# 117 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h" 3 4
       , "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h", 117, __PRETTY_FUNCTION__))
# 117 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
                               ;
        mTimeSpan.set(t0, t1);
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& scaleTimes(RealT scale)
    {
        mTimeSpan.scale(scale);
        return *this;
    }

    __attribute__((host)) __attribute__((device)) Ray& reset(
        const Vec3Type& eye,
        const Vec3Type& direction,
        RealT t0 = Delta<RealT>::value(),
        RealT t1 = Maximum<RealT>::value())
    {
        this->setEye(eye);
        this->setDir(direction);
        this->setTimes(t0, t1);
        return *this;
    }

    __attribute__((host)) __attribute__((device)) const Vec3T& eye() const { return mEye; }

    __attribute__((host)) __attribute__((device)) const Vec3T& dir() const { return mDir; }

    __attribute__((host)) __attribute__((device)) const Vec3T& invDir() const { return mInvDir; }

    __attribute__((host)) __attribute__((device)) RealT t0() const { return mTimeSpan.t0; }

    __attribute__((host)) __attribute__((device)) RealT t1() const { return mTimeSpan.t1; }

    __attribute__((host)) __attribute__((device)) int sign(int i) const { return mSign[i]; }


    __attribute__((host)) __attribute__((device)) Vec3T operator()(RealT time) const
    {

        return Vec3T(fmaf(time, mDir[0], mEye[0]),
                     fmaf(time, mDir[1], mEye[1]),
                     fmaf(time, mDir[2], mEye[2]));



    }


    __attribute__((host)) __attribute__((device)) Vec3T start() const { return (*this)(mTimeSpan.t0); }


    __attribute__((host)) __attribute__((device)) Vec3T end() const { return (*this)(mTimeSpan.t1); }


    __attribute__((host)) __attribute__((device)) Vec3T mid() const { return (*this)(mTimeSpan.mid()); }


    __attribute__((host)) __attribute__((device)) bool valid(RealT eps = Delta<float>::value()) const { return mTimeSpan.valid(eps); }


    __attribute__((host)) __attribute__((device)) bool test(RealT time) const { return mTimeSpan.test(time); }
# 188 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    template<typename MapType>
    __attribute__((host)) __attribute__((device)) Ray applyMap(const MapType& map) const
    {
        const Vec3T eye = map.applyMap(mEye);
        const Vec3T dir = map.applyJacobian(mDir);
        const RealT length = dir.length(), invLength = RealT(1) / length;
        RealT t1 = mTimeSpan.t1;
        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
            t1 *= length;
        }
        return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
    }
    template<typename MapType>
    __attribute__((host)) __attribute__((device)) Ray applyMapF(const MapType& map) const
    {
        const Vec3T eye = map.applyMapF(mEye);
        const Vec3T dir = map.applyJacobianF(mDir);
        const RealT length = dir.length(), invLength = RealT(1) / length;
        RealT t1 = mTimeSpan.t1;
        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
            t1 *= length;
        }
        return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
    }
# 222 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    template<typename MapType>
    __attribute__((host)) __attribute__((device)) Ray applyInverseMap(const MapType& map) const
    {
        const Vec3T eye = map.applyInverseMap(mEye);
        const Vec3T dir = map.applyInverseJacobian(mDir);
        const RealT length = dir.length(), invLength = RealT(1) / length;
        return Ray(eye, dir * invLength, length * mTimeSpan.t0, length * mTimeSpan.t1);
    }
    template<typename MapType>
    __attribute__((host)) __attribute__((device)) Ray applyInverseMapF(const MapType& map) const
    {
        const Vec3T eye = map.applyInverseMapF(mEye);
        const Vec3T dir = map.applyInverseJacobianF(mDir);
        const RealT length = dir.length(), invLength = RealT(1) / length;
        return Ray(eye, dir * invLength, length * mTimeSpan.t0, length * mTimeSpan.t1);
    }



    template<typename GridType>
    __attribute__((host)) __attribute__((device)) Ray indexToWorldF(const GridType& grid) const
    {
        const Vec3T eye = grid.indexToWorldF(mEye);
        const Vec3T dir = grid.indexToWorldDirF(mDir);
        const RealT length = dir.length(), invLength = RealT(1) / length;
        RealT t1 = mTimeSpan.t1;
        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
            t1 *= length;
        }
        return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
    }



    template<typename GridType>
    __attribute__((host)) __attribute__((device)) Ray worldToIndexF(const GridType& grid) const
    {
        const Vec3T eye = grid.worldToIndexF(mEye);
        const Vec3T dir = grid.worldToIndexDirF(mDir);
        const RealT length = dir.length(), invLength = RealT(1) / length;
        RealT t1 = mTimeSpan.t1;
        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
            t1 *= length;
        }
        return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
    }
# 278 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    __attribute__((host)) __attribute__((device)) bool intersects(const Vec3T& center, RealT radius, RealT& t0, RealT& t1) const
    {
        const Vec3T origin = mEye - center;
        const RealT A = mDir.lengthSqr();
        const RealT B = 2 * mDir.dot(origin);
        const RealT C = origin.lengthSqr() - radius * radius;
        const RealT D = B * B - 4 * A * C;

        if (D < 0) {
            return false;
        }
        const RealT Q = RealT(-0.5) * (B < 0 ? (B + Sqrt(D)) : (B - Sqrt(D)));

        t0 = Q / A;
        t1 = C / Q;

        if (t0 > t1) {
            RealT tmp = t0;
            t0 = t1;
            t1 = tmp;
        }
        if (t0 < mTimeSpan.t0) {
            t0 = mTimeSpan.t0;
        }
        if (t1 > mTimeSpan.t1) {
            t1 = mTimeSpan.t1;
        }
        return t0 <= t1;
    }





    __attribute__((host)) __attribute__((device)) bool intersects(const Vec3T& center, RealT radius) const
    {
        RealT t0, t1;
        return this->intersects(center, radius, t0, t1) > 0;
    }







    __attribute__((host)) __attribute__((device)) bool clip(const Vec3T& center, RealT radius)
    {
        RealT t0, t1;
        const bool hit = this->intersects(center, radius, t0, t1);
        if (hit) {
            mTimeSpan.set(t0, t1);
        }
        return hit;
    }
# 397 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    __attribute__((host)) __attribute__((device)) bool intersects(const CoordBBox& bbox, RealT& t0, RealT& t1) const
    {
        mTimeSpan.get(t0, t1);
        for (int i = 0; i < 3; ++i) {
            RealT a = RealT(bbox.min()[i]), b = RealT(bbox.max()[i] + 1);
            if (a >= b) {
                return false;
            }
            a = (a - mEye[i]) * mInvDir[i];
            b = (b - mEye[i]) * mInvDir[i];
            if (a > b) {
                RealT tmp = a;
                a = b;
                b = tmp;
            }
            if (a > t0) {
                t0 = a;
            }
            if (b < t1) {
                t1 = b;
            }
            if (t0 > t1) {
                return false;
            }
        }
        return true;
    }



    template<typename OtherVec3T>
    __attribute__((host)) __attribute__((device)) bool intersects(const BBox<OtherVec3T>& bbox, RealT& t0, RealT& t1) const
    {
        static_assert(is_floating_point<typename OtherVec3T::ValueType>::value, "Ray::intersects: Expected a floating point coordinate");
        mTimeSpan.get(t0, t1);
        for (int i = 0; i < 3; ++i) {
            RealT a = RealT(bbox.min()[i]), b = RealT(bbox.max()[i]);
            if (a >= b) {
                return false;
            }
            a = (a - mEye[i]) * mInvDir[i];
            b = (b - mEye[i]) * mInvDir[i];
            if (a > b) {
                RealT tmp = a;
                a = b;
                b = tmp;
            }
            if (a > t0) {
                t0 = a;
            }
            if (b < t1) {
                t1 = b;
            }
            if (t0 > t1) {
                return false;
            }
        }
        return true;
    }
# 466 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    template<typename BBoxT>
    __attribute__((host)) __attribute__((device)) bool intersects(const BBoxT& bbox) const
    {

        RealT t0, t1;
        return this->intersects(bbox, t0, t1);
# 499 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    }
# 511 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/Ray.h"
    template<typename BBoxT>
    __attribute__((host)) __attribute__((device)) bool clip(const BBoxT& bbox)
    {
        RealT t0, t1;
        const bool hit = this->intersects(bbox, t0, t1);
        if (hit) {
            mTimeSpan.set(t0, t1);
        }
        return hit;
    }







    __attribute__((host)) __attribute__((device)) bool intersects(const Vec3T& normal, RealT distance, RealT& t) const
    {
        const RealT cosAngle = mDir.dot(normal);
        if (isApproxZero(cosAngle)) {
            return false;
        }
        t = (distance - mEye.dot(normal)) / cosAngle;
        return this->test(t);
    }







    __attribute__((host)) __attribute__((device)) bool intersects(const Vec3T& normal, const Vec3T& point, RealT& t) const
    {
        return this->intersects(normal, point.dot(normal), t);
    }

private:
    Vec3T mEye, mDir, mInvDir;
    TimeSpan mTimeSpan;
    int mSign[3];
};

}
# 13 "/beegfs/teran_parrales/NVISII/include/nvisii/volume_struct.h" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/SampleFromVoxels.h" 1
# 32 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/SampleFromVoxels.h"
namespace nanovdb {


template<typename TreeT, int Order, bool UseCache = true>
class SampleFromVoxels;
# 45 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/SampleFromVoxels.h"
template<int Order, typename TreeOrAccT, bool UseCache = true>
__attribute__((host)) __attribute__((device)) SampleFromVoxels<TreeOrAccT, Order, UseCache> createSampler(const TreeOrAccT& acc)
{
    return SampleFromVoxels<TreeOrAccT, Order, UseCache>(acc);
}



template<typename CoordT, typename RealT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT Floor(Vec3T<RealT>& xyz);


template<typename CoordT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT Floor(Vec3T<float>& xyz)
{
    const float ijk[3] = {floorf(xyz[0]), floorf(xyz[1]), floorf(xyz[2])};
    xyz[0] -= ijk[0];
    xyz[1] -= ijk[1];
    xyz[2] -= ijk[2];
    return CoordT(int32_t(ijk[0]), int32_t(ijk[1]), int32_t(ijk[2]));
}


template<typename CoordT, template<typename> class Vec3T>
__attribute__((host)) __attribute__((device)) inline CoordT Floor(Vec3T<double>& xyz)
{
    const double ijk[3] = {floor(xyz[0]), floor(xyz[1]), floor(xyz[2])};
    xyz[0] -= ijk[0];
    xyz[1] -= ijk[1];
    xyz[2] -= ijk[2];
    return CoordT(int32_t(ijk[0]), int32_t(ijk[1]), int32_t(ijk[2]));
}




template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 0, true>
{
public:
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

    static const int ORDER = 0;

    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc)
        : mAcc(acc)
        , mPos(CoordT::max())
    {
    }

    __attribute__((host)) __attribute__((device)) const TreeOrAccT& accessor() const { return mAcc; }


    template<typename Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(const Vec3T& xyz) const;

    inline __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT& ijk) const;

private:
    const TreeOrAccT& mAcc;
    mutable CoordT mPos;
    mutable ValueT mVal;
};


template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 0, false>
{
public:
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;
    static const int ORDER = 0;


    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc)
        : mAcc(acc)
    {
    }

    __attribute__((host)) __attribute__((device)) const TreeOrAccT& accessor() const { return mAcc; }


    template<typename Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(const Vec3T& xyz) const;

    inline __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT& ijk) const { return mAcc.getValue(ijk);}

private:
    const TreeOrAccT& mAcc;
};

template<typename TreeOrAccT>
template<typename Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 0, true>::operator()(const Vec3T& xyz) const
{
    const CoordT ijk = Round<CoordT>(xyz);
    if (ijk != mPos) {
        mPos = ijk;
        mVal = mAcc.getValue(mPos);
    }
    return mVal;
}

template<typename TreeOrAccT>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 0, true>::operator()(const CoordT& ijk) const
{
    if (ijk != mPos) {
        mPos = ijk;
        mVal = mAcc.getValue(mPos);
    }
    return mVal;
}

template<typename TreeOrAccT>
template<typename Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 0, false>::operator()(const Vec3T& xyz) const
{
    return mAcc.getValue(Round<CoordT>(xyz));
}




template<typename TreeOrAccT>
class TrilinearSampler
{
protected:
    const TreeOrAccT& mAcc;

public:
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;
    static const int ORDER = 1;


    __attribute__((host)) __attribute__((device)) TrilinearSampler(const TreeOrAccT& acc) : mAcc(acc) {}

    __attribute__((host)) __attribute__((device)) const TreeOrAccT& accessor() const { return mAcc; }


    inline __attribute__((host)) __attribute__((device)) void stencil(CoordT& ijk, ValueT (&v)[2][2][2]) const;

    template<typename RealT, template<typename...> class Vec3T>
    static inline __attribute__((host)) __attribute__((device)) ValueT sample(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2]);

    template<typename RealT, template<typename...> class Vec3T>
    static inline __attribute__((host)) __attribute__((device)) Vec3T<ValueT> gradient(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2]);

    static inline __attribute__((host)) __attribute__((device)) bool zeroCrossing(const ValueT (&v)[2][2][2]);
};

template<typename TreeOrAccT>
void TrilinearSampler<TreeOrAccT>::stencil(CoordT& ijk, ValueT (&v)[2][2][2]) const
{
    v[0][0][0] = mAcc.getValue(ijk);

    ijk[2] += 1;
    v[0][0][1] = mAcc.getValue(ijk);

    ijk[1] += 1;
    v[0][1][1] = mAcc.getValue(ijk);

    ijk[2] -= 1;
    v[0][1][0] = mAcc.getValue(ijk);

    ijk[0] += 1;
    ijk[1] -= 1;
    v[1][0][0] = mAcc.getValue(ijk);

    ijk[2] += 1;
    v[1][0][1] = mAcc.getValue(ijk);

    ijk[1] += 1;
    v[1][1][1] = mAcc.getValue(ijk);

    ijk[2] -= 1;
    v[1][1][0] = mAcc.getValue(ijk);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType TrilinearSampler<TreeOrAccT>::sample(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2])
{




    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };

    return lerp(lerp(lerp(v[0][0][0], v[0][0][1], uvw[2]), lerp(v[0][1][0], v[0][1][1], uvw[2]), uvw[1]),
                lerp(lerp(v[1][0][0], v[1][0][1], uvw[2]), lerp(v[1][1][0], v[1][1][1], uvw[2]), uvw[1]),
                uvw[0]);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
Vec3T<typename TreeOrAccT::ValueType> TrilinearSampler<TreeOrAccT>::gradient(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2])
{
    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::gradient requires a floating-point type");




    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };


    ValueT D[4] = {v[0][0][1] - v[0][0][0], v[0][1][1] - v[0][1][0], v[1][0][1] - v[1][0][0], v[1][1][1] - v[1][1][0]};


    Vec3T<ValueT> grad(0, 0, lerp(lerp(D[0], D[1], uvw[1]), lerp(D[2], D[3], uvw[1]), uvw[0]));

    const ValueT w = ValueT(uvw[2]);
    D[0] = v[0][0][0] + D[0] * w;
    D[1] = v[0][1][0] + D[1] * w;
    D[2] = v[1][0][0] + D[2] * w;
    D[3] = v[1][1][0] + D[3] * w;


    grad[0] = lerp(D[2], D[3], uvw[1]) - lerp(D[0], D[1], uvw[1]);


    grad[1] = lerp(D[1] - D[0], D[3] - D[2], uvw[0]);

    return grad;
}

template<typename TreeOrAccT>
bool TrilinearSampler<TreeOrAccT>::zeroCrossing(const ValueT (&v)[2][2][2])
{
    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::zeroCrossing requires a floating-point type");
    const bool less = v[0][0][0] < ValueT(0);
    return (less ^ (v[0][0][1] < ValueT(0))) ||
           (less ^ (v[0][1][1] < ValueT(0))) ||
           (less ^ (v[0][1][0] < ValueT(0))) ||
           (less ^ (v[1][0][0] < ValueT(0))) ||
           (less ^ (v[1][0][1] < ValueT(0))) ||
           (less ^ (v[1][1][1] < ValueT(0))) ||
           (less ^ (v[1][1][0] < ValueT(0)));
}


template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 1, false> : public TrilinearSampler<TreeOrAccT>
{
    using BaseT = TrilinearSampler<TreeOrAccT>;
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

public:


    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc) {}


    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(Vec3T<RealT> xyz) const;


    __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}




    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) Vec3T<ValueT> gradient(Vec3T<RealT> xyz) const;




    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) bool zeroCrossing(Vec3T<RealT> xyz) const;

};


template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 1, true> : public TrilinearSampler<TreeOrAccT>
{
    using BaseT = TrilinearSampler<TreeOrAccT>;
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

    mutable CoordT mPos;
    mutable ValueT mVal[2][2][2];

    template<typename RealT, template<typename...> class Vec3T>
    __attribute__((host)) __attribute__((device)) void cache(Vec3T<RealT>& xyz) const;
public:


    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc), mPos(CoordT::max()){}


    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(Vec3T<RealT> xyz) const;


    __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT &ijk) const;




    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) Vec3T<ValueT> gradient(Vec3T<RealT> xyz) const;




    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) bool zeroCrossing(Vec3T<RealT> xyz) const;




    __attribute__((host)) __attribute__((device)) bool zeroCrossing() const { return BaseT::zeroCrossing(mVal); }

};

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, true>::operator()(Vec3T<RealT> xyz) const
{
    this->cache(xyz);
    return BaseT::sample(xyz, mVal);
}

template<typename TreeOrAccT>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, true>::operator()(const CoordT &ijk) const
{
    return ijk == mPos ? mVal[0][0][0] : BaseT::mAcc.getValue(ijk);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
Vec3T<typename TreeOrAccT::ValueType> SampleFromVoxels<TreeOrAccT, 1, true>::gradient(Vec3T<RealT> xyz) const
{
    this->cache(xyz);
    return BaseT::gradient(xyz, mVal);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
__attribute__((host)) __attribute__((device)) bool SampleFromVoxels<TreeOrAccT, 1, true>::zeroCrossing(Vec3T<RealT> xyz) const
{
    this->cache(xyz);
    return BaseT::zeroCrossing(mVal);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
void SampleFromVoxels<TreeOrAccT, 1, true>::cache(Vec3T<RealT>& xyz) const
{
    CoordT ijk = Floor<CoordT>(xyz);
    if (ijk != mPos) {
        mPos = ijk;
        BaseT::stencil(ijk, mVal);
    }
}
# 419 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/SampleFromVoxels.h"
template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, false>::operator()(Vec3T<RealT> xyz) const
{
    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };

    CoordT coord = Floor<CoordT>(xyz);

    ValueT vx, vx1, vy, vy1, vz, vz1;

    vz = BaseT::mAcc.getValue(coord);
    coord[2] += 1;
    vz1 = BaseT::mAcc.getValue(coord);
    vy = lerp(vz, vz1, xyz[2]);

    coord[1] += 1;

    vz1 = BaseT::mAcc.getValue(coord);
    coord[2] -= 1;
    vz = BaseT::mAcc.getValue(coord);
    vy1 = lerp(vz, vz1, xyz[2]);

    vx = lerp(vy, vy1, xyz[1]);

    coord[0] += 1;

    vz = BaseT::mAcc.getValue(coord);
    coord[2] += 1;
    vz1 = BaseT::mAcc.getValue(coord);
    vy1 = lerp(vz, vz1, xyz[2]);

    coord[1] -= 1;

    vz1 = BaseT::mAcc.getValue(coord);
    coord[2] -= 1;
    vz = BaseT::mAcc.getValue(coord);
    vy = lerp(vz, vz1, xyz[2]);

    vx1 = lerp(vy, vy1, xyz[1]);

    return lerp(vx, vx1, xyz[0]);
}



template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
inline Vec3T<typename TreeOrAccT::ValueType> SampleFromVoxels<TreeOrAccT, 1, false>::gradient(Vec3T<RealT> xyz) const
{
    ValueT val[2][2][2];
    CoordT ijk = Floor<CoordT>(xyz);
    BaseT::stencil(ijk, val);
    return BaseT::gradient(xyz, val);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
bool SampleFromVoxels<TreeOrAccT, 1, false>::zeroCrossing(Vec3T<RealT> xyz) const
{
    ValueT val[2][2][2];
    CoordT ijk = Floor<CoordT>(xyz);
    BaseT::stencil(ijk, val);
    return BaseT::zeroCrossing(val);
}




template<typename TreeOrAccT>
class TriquadraticSampler
{
protected:
    const TreeOrAccT& mAcc;

public:
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;
    static const int ORDER = 1;


    __attribute__((host)) __attribute__((device)) TriquadraticSampler(const TreeOrAccT& acc) : mAcc(acc) {}

    __attribute__((host)) __attribute__((device)) const TreeOrAccT& accessor() const { return mAcc; }


    inline __attribute__((host)) __attribute__((device)) void stencil(const CoordT &ijk, ValueT (&v)[3][3][3]) const;

    template<typename RealT, template<typename...> class Vec3T>
    static inline __attribute__((host)) __attribute__((device)) ValueT sample(const Vec3T<RealT> &uvw, const ValueT (&v)[3][3][3]);

    static inline __attribute__((host)) __attribute__((device)) bool zeroCrossing(const ValueT (&v)[3][3][3]);
};

template<typename TreeOrAccT>
void TriquadraticSampler<TreeOrAccT>::stencil(const CoordT &ijk, ValueT (&v)[3][3][3]) const
{
    CoordT p(ijk[0] - 1, 0, 0);
    for (int dx = 0; dx < 3; ++dx, ++p[0]) {
        p[1] = ijk[1] - 1;
        for (int dy = 0; dy < 3; ++dy, ++p[1]) {
            p[2] = ijk[2] - 1;
            for (int dz = 0; dz < 3; ++dz, ++p[2]) {
                v[dx][dy][dz] = mAcc.getValue(p);
            }
        }
    }
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType TriquadraticSampler<TreeOrAccT>::sample(const Vec3T<RealT> &uvw, const ValueT (&v)[3][3][3])
{
    auto kernel = [](const ValueT* value, double weight)->ValueT {
        return weight * (weight * (0.5f * (value[0] + value[2]) - value[1]) +
                        0.5f * (value[2] - value[0])) + value[1];
    };

    ValueT vx[3];
    for (int dx = 0; dx < 3; ++dx) {
        ValueT vy[3];
        for (int dy = 0; dy < 3; ++dy) {
            vy[dy] = kernel(&v[dx][dy][0], uvw[2]);
        }
        vx[dx] = kernel(vy, uvw[1]);
    }
    return kernel(vx, uvw[0]);
}

template<typename TreeOrAccT>
bool TriquadraticSampler<TreeOrAccT>::zeroCrossing(const ValueT (&v)[3][3][3])
{
    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::zeroCrossing requires a floating-point type");
    const bool less = v[0][0][0] < ValueT(0);
    for (int dx = 0; dx < 3; ++dx) {
        for (int dy = 0; dy < 3; ++dy) {
            for (int dz = 0; dz < 3; ++dz) {
                if (less ^ (v[dx][dy][dz] < ValueT(0))) return true;
            }
        }
    }
    return false;
}


template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 2, false> : public TriquadraticSampler<TreeOrAccT>
{
    using BaseT = TriquadraticSampler<TreeOrAccT>;
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;
public:


    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc) {}


    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(Vec3T<RealT> xyz) const;

    __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}




    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) bool zeroCrossing(Vec3T<RealT> xyz) const;

};


template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 2, true> : public TriquadraticSampler<TreeOrAccT>
{
    using BaseT = TriquadraticSampler<TreeOrAccT>;
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

    mutable CoordT mPos;
    mutable ValueT mVal[3][3][3];

    template<typename RealT, template<typename...> class Vec3T>
    __attribute__((host)) __attribute__((device)) void cache(Vec3T<RealT>& xyz) const;
public:


    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc), mPos(CoordT::max()){}


    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(Vec3T<RealT> xyz) const;

    inline __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT &ijk) const;




    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) bool zeroCrossing(Vec3T<RealT> xyz) const;




    __attribute__((host)) __attribute__((device)) bool zeroCrossing() const { return BaseT::zeroCrossing(mVal); }

};

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 2, true>::operator()(Vec3T<RealT> xyz) const
{
    this->cache(xyz);
    return BaseT::sample(xyz, mVal);
}

template<typename TreeOrAccT>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 2, true>::operator()(const CoordT &ijk) const
{
    return ijk == mPos ? mVal[1][1][1] : BaseT::mAcc.getValue(ijk);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
__attribute__((host)) __attribute__((device)) bool SampleFromVoxels<TreeOrAccT, 2, true>::zeroCrossing(Vec3T<RealT> xyz) const
{
    this->cache(xyz);
    return BaseT::zeroCrossing(mVal);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
void SampleFromVoxels<TreeOrAccT, 2, true>::cache(Vec3T<RealT>& xyz) const
{
    CoordT ijk = Floor<CoordT>(xyz);
    if (ijk != mPos) {
        mPos = ijk;
        BaseT::stencil(ijk, mVal);
    }
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 2, false>::operator()(Vec3T<RealT> xyz) const
{
    ValueT val[3][3][3];
    CoordT ijk = Floor<CoordT>(xyz);
    BaseT::stencil(ijk, val);
    return BaseT::sample(xyz, val);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
bool SampleFromVoxels<TreeOrAccT, 2, false>::zeroCrossing(Vec3T<RealT> xyz) const
{
    ValueT val[3][3][3];
    CoordT ijk = Floor<CoordT>(xyz);
    BaseT::stencil(ijk, val);
    return BaseT::zeroCrossing(val);
}
# 687 "/beegfs/teran_parrales/NVISII/externals/nanovdb/nanovdb/util/SampleFromVoxels.h"
template<typename TreeOrAccT>
class TricubicSampler
{
protected:
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

    const TreeOrAccT& mAcc;

public:

    __attribute__((host)) __attribute__((device)) TricubicSampler(const TreeOrAccT& acc)
        : mAcc(acc)
    {
    }

    __attribute__((host)) __attribute__((device)) const TreeOrAccT& accessor() const { return mAcc; }


    inline __attribute__((host)) __attribute__((device)) void stencil(const CoordT& ijk, ValueT (&c)[64]) const;

    template<typename RealT, template<typename...> class Vec3T>
    static inline __attribute__((host)) __attribute__((device)) ValueT sample(const Vec3T<RealT> &uvw, const ValueT (&c)[64]);
};

template<typename TreeOrAccT>
void TricubicSampler<TreeOrAccT>::stencil(const CoordT& ijk, ValueT (&C)[64]) const
{
    auto fetch = [&](int i, int j, int k) -> ValueT& { return C[((i + 1) << 4) + ((j + 1) << 2) + k + 1]; };


    for (int i = -1; i < 3; ++i) {
        for (int j = -1; j < 3; ++j) {
            fetch(i, j, -1) = mAcc.getValue(ijk + CoordT(i, j, -1));
            fetch(i, j, 0) = mAcc.getValue(ijk + CoordT(i, j, 0));
            fetch(i, j, 1) = mAcc.getValue(ijk + CoordT(i, j, 1));
            fetch(i, j, 2) = mAcc.getValue(ijk + CoordT(i, j, 2));
        }
    }
    const ValueT half(0.5), quarter(0.25), eighth(0.125);
    const ValueT X[64] = {
                          fetch(0, 0, 0),
                          fetch(1, 0, 0),
                          fetch(0, 1, 0),
                          fetch(1, 1, 0),
                          fetch(0, 0, 1),
                          fetch(1, 0, 1),
                          fetch(0, 1, 1),
                          fetch(1, 1, 1),

                          half * (fetch(1, 0, 0) - fetch(-1, 0, 0)),
                          half * (fetch(2, 0, 0) - fetch(0, 0, 0)),
                          half * (fetch(1, 1, 0) - fetch(-1, 1, 0)),
                          half * (fetch(2, 1, 0) - fetch(0, 1, 0)),
                          half * (fetch(1, 0, 1) - fetch(-1, 0, 1)),
                          half * (fetch(2, 0, 1) - fetch(0, 0, 1)),
                          half * (fetch(1, 1, 1) - fetch(-1, 1, 1)),
                          half * (fetch(2, 1, 1) - fetch(0, 1, 1)),

                          half * (fetch(0, 1, 0) - fetch(0, -1, 0)),
                          half * (fetch(1, 1, 0) - fetch(1, -1, 0)),
                          half * (fetch(0, 2, 0) - fetch(0, 0, 0)),
                          half * (fetch(1, 2, 0) - fetch(1, 0, 0)),
                          half * (fetch(0, 1, 1) - fetch(0, -1, 1)),
                          half * (fetch(1, 1, 1) - fetch(1, -1, 1)),
                          half * (fetch(0, 2, 1) - fetch(0, 0, 1)),
                          half * (fetch(1, 2, 1) - fetch(1, 0, 1)),

                          half * (fetch(0, 0, 1) - fetch(0, 0, -1)),
                          half * (fetch(1, 0, 1) - fetch(1, 0, -1)),
                          half * (fetch(0, 1, 1) - fetch(0, 1, -1)),
                          half * (fetch(1, 1, 1) - fetch(1, 1, -1)),
                          half * (fetch(0, 0, 2) - fetch(0, 0, 0)),
                          half * (fetch(1, 0, 2) - fetch(1, 0, 0)),
                          half * (fetch(0, 1, 2) - fetch(0, 1, 0)),
                          half * (fetch(1, 1, 2) - fetch(1, 1, 0)),

                          quarter * (fetch(1, 1, 0) - fetch(-1, 1, 0) - fetch(1, -1, 0) + fetch(-1, -1, 0)),
                          quarter * (fetch(2, 1, 0) - fetch(0, 1, 0) - fetch(2, -1, 0) + fetch(0, -1, 0)),
                          quarter * (fetch(1, 2, 0) - fetch(-1, 2, 0) - fetch(1, 0, 0) + fetch(-1, 0, 0)),
                          quarter * (fetch(2, 2, 0) - fetch(0, 2, 0) - fetch(2, 0, 0) + fetch(0, 0, 0)),
                          quarter * (fetch(1, 1, 1) - fetch(-1, 1, 1) - fetch(1, -1, 1) + fetch(-1, -1, 1)),
                          quarter * (fetch(2, 1, 1) - fetch(0, 1, 1) - fetch(2, -1, 1) + fetch(0, -1, 1)),
                          quarter * (fetch(1, 2, 1) - fetch(-1, 2, 1) - fetch(1, 0, 1) + fetch(-1, 0, 1)),
                          quarter * (fetch(2, 2, 1) - fetch(0, 2, 1) - fetch(2, 0, 1) + fetch(0, 0, 1)),

                          quarter * (fetch(1, 0, 1) - fetch(-1, 0, 1) - fetch(1, 0, -1) + fetch(-1, 0, -1)),
                          quarter * (fetch(2, 0, 1) - fetch(0, 0, 1) - fetch(2, 0, -1) + fetch(0, 0, -1)),
                          quarter * (fetch(1, 1, 1) - fetch(-1, 1, 1) - fetch(1, 1, -1) + fetch(-1, 1, -1)),
                          quarter * (fetch(2, 1, 1) - fetch(0, 1, 1) - fetch(2, 1, -1) + fetch(0, 1, -1)),
                          quarter * (fetch(1, 0, 2) - fetch(-1, 0, 2) - fetch(1, 0, 0) + fetch(-1, 0, 0)),
                          quarter * (fetch(2, 0, 2) - fetch(0, 0, 2) - fetch(2, 0, 0) + fetch(0, 0, 0)),
                          quarter * (fetch(1, 1, 2) - fetch(-1, 1, 2) - fetch(1, 1, 0) + fetch(-1, 1, 0)),
                          quarter * (fetch(2, 1, 2) - fetch(0, 1, 2) - fetch(2, 1, 0) + fetch(0, 1, 0)),

                          quarter * (fetch(0, 1, 1) - fetch(0, -1, 1) - fetch(0, 1, -1) + fetch(0, -1, -1)),
                          quarter * (fetch(1, 1, 1) - fetch(1, -1, 1) - fetch(1, 1, -1) + fetch(1, -1, -1)),
                          quarter * (fetch(0, 2, 1) - fetch(0, 0, 1) - fetch(0, 2, -1) + fetch(0, 0, -1)),
                          quarter * (fetch(1, 2, 1) - fetch(1, 0, 1) - fetch(1, 2, -1) + fetch(1, 0, -1)),
                          quarter * (fetch(0, 1, 2) - fetch(0, -1, 2) - fetch(0, 1, 0) + fetch(0, -1, 0)),
                          quarter * (fetch(1, 1, 2) - fetch(1, -1, 2) - fetch(1, 1, 0) + fetch(1, -1, 0)),
                          quarter * (fetch(0, 2, 2) - fetch(0, 0, 2) - fetch(0, 2, 0) + fetch(0, 0, 0)),
                          quarter * (fetch(1, 2, 2) - fetch(1, 0, 2) - fetch(1, 2, 0) + fetch(1, 0, 0)),

                          eighth * (fetch(1, 1, 1) - fetch(-1, 1, 1) - fetch(1, -1, 1) + fetch(-1, -1, 1) - fetch(1, 1, -1) + fetch(-1, 1, -1) + fetch(1, -1, -1) - fetch(-1, -1, -1)),
                          eighth * (fetch(2, 1, 1) - fetch(0, 1, 1) - fetch(2, -1, 1) + fetch(0, -1, 1) - fetch(2, 1, -1) + fetch(0, 1, -1) + fetch(2, -1, -1) - fetch(0, -1, -1)),
                          eighth * (fetch(1, 2, 1) - fetch(-1, 2, 1) - fetch(1, 0, 1) + fetch(-1, 0, 1) - fetch(1, 2, -1) + fetch(-1, 2, -1) + fetch(1, 0, -1) - fetch(-1, 0, -1)),
                          eighth * (fetch(2, 2, 1) - fetch(0, 2, 1) - fetch(2, 0, 1) + fetch(0, 0, 1) - fetch(2, 2, -1) + fetch(0, 2, -1) + fetch(2, 0, -1) - fetch(0, 0, -1)),
                          eighth * (fetch(1, 1, 2) - fetch(-1, 1, 2) - fetch(1, -1, 2) + fetch(-1, -1, 2) - fetch(1, 1, 0) + fetch(-1, 1, 0) + fetch(1, -1, 0) - fetch(-1, -1, 0)),
                          eighth * (fetch(2, 1, 2) - fetch(0, 1, 2) - fetch(2, -1, 2) + fetch(0, -1, 2) - fetch(2, 1, 0) + fetch(0, 1, 0) + fetch(2, -1, 0) - fetch(0, -1, 0)),
                          eighth * (fetch(1, 2, 2) - fetch(-1, 2, 2) - fetch(1, 0, 2) + fetch(-1, 0, 2) - fetch(1, 2, 0) + fetch(-1, 2, 0) + fetch(1, 0, 0) - fetch(-1, 0, 0)),
                          eighth * (fetch(2, 2, 2) - fetch(0, 2, 2) - fetch(2, 0, 2) + fetch(0, 0, 2) - fetch(2, 2, 0) + fetch(0, 2, 0) + fetch(2, 0, 0) - fetch(0, 0, 0))};


    static const int8_t A[64][64] = {
        {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {-3, 3, 0, 0, 0, 0, 0, 0, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {2, -2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {9, -9, -9, 9, 0, 0, 0, 0, 6, 3, -6, -3, 0, 0, 0, 0, 6, -6, 3, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {-6, 6, 6, -6, 0, 0, 0, 0, -3, -3, 3, 3, 0, 0, 0, 0, -4, 4, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {-6, 6, 6, -6, 0, 0, 0, 0, -4, -2, 4, 2, 0, 0, 0, 0, -3, 3, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -1, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {4, -4, -4, 4, 0, 0, 0, 0, 2, 2, -2, -2, 0, 0, 0, 0, 2, -2, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, -2, -1, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -9, -9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 3, -6, -3, 0, 0, 0, 0, 6, -6, 3, -3, 0, 0, 0, 0, 4, 2, 2, 1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 6, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, -3, 3, 3, 0, 0, 0, 0, -4, 4, -2, 2, 0, 0, 0, 0, -2, -2, -1, -1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 6, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, -2, 4, 2, 0, 0, 0, 0, -3, 3, -3, 3, 0, 0, 0, 0, -2, -1, -2, -1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, -4, -4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, -2, -2, 0, 0, 0, 0, 2, -2, 2, -2, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0},
        {-3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {9, -9, 0, 0, -9, 9, 0, 0, 6, 3, 0, 0, -6, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -6, 0, 0, 3, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {-6, 6, 0, 0, 6, -6, 0, 0, -3, -3, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -2, 0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, 0, 0, -1, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -9, 0, 0, -9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 3, 0, 0, -6, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -6, 0, 0, 3, -3, 0, 0, 4, 2, 0, 0, 2, 1, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 6, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, -3, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, 4, 0, 0, -2, 2, 0, 0, -2, -2, 0, 0, -1, -1, 0, 0},
        {9, 0, -9, 0, -9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0, -6, 0, -3, 0, 6, 0, -6, 0, 3, 0, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 9, 0, -9, 0, -9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0, -6, 0, -3, 0, 6, 0, -6, 0, 3, 0, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 2, 0, 1, 0},
        {-27, 27, 27, -27, 27, -27, -27, 27, -18, -9, 18, 9, 18, 9, -18, -9, -18, 18, -9, 9, 18, -18, 9, -9, -18, 18, 18, -18, -9, 9, 9, -9, -12, -6, -6, -3, 12, 6, 6, 3, -12, -6, 12, 6, -6, -3, 6, 3, -12, 12, -6, 6, -6, 6, -3, 3, -8, -4, -4, -2, -4, -2, -2, -1},
        {18, -18, -18, 18, -18, 18, 18, -18, 9, 9, -9, -9, -9, -9, 9, 9, 12, -12, 6, -6, -12, 12, -6, 6, 12, -12, -12, 12, 6, -6, -6, 6, 6, 6, 3, 3, -6, -6, -3, -3, 6, 6, -6, -6, 3, 3, -3, -3, 8, -8, 4, -4, 4, -4, 2, -2, 4, 4, 2, 2, 2, 2, 1, 1},
        {-6, 0, 6, 0, 6, 0, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, -3, 0, 3, 0, 3, 0, -4, 0, 4, 0, -2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -2, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, -6, 0, 6, 0, 6, 0, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, -3, 0, 3, 0, 3, 0, -4, 0, 4, 0, -2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -2, 0, -1, 0, -1, 0},
        {18, -18, -18, 18, -18, 18, 18, -18, 12, 6, -12, -6, -12, -6, 12, 6, 9, -9, 9, -9, -9, 9, -9, 9, 12, -12, -12, 12, 6, -6, -6, 6, 6, 3, 6, 3, -6, -3, -6, -3, 8, 4, -8, -4, 4, 2, -4, -2, 6, -6, 6, -6, 3, -3, 3, -3, 4, 2, 4, 2, 2, 1, 2, 1},
        {-12, 12, 12, -12, 12, -12, -12, 12, -6, -6, 6, 6, 6, 6, -6, -6, -6, 6, -6, 6, 6, -6, 6, -6, -8, 8, 8, -8, -4, 4, 4, -4, -3, -3, -3, -3, 3, 3, 3, 3, -4, -4, 4, 4, -2, -2, 2, 2, -4, 4, -4, 4, -2, 2, -2, 2, -2, -2, -2, -2, -1, -1, -1, -1},
        {2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {-6, 6, 0, 0, 6, -6, 0, 0, -4, -2, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -1, 0, 0, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {4, -4, 0, 0, -4, 4, 0, 0, 2, 2, 0, 0, -2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 6, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, -2, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, -3, 3, 0, 0, -2, -1, 0, 0, -2, -1, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, -4, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, -2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, 2, -2, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0},
        {-6, 0, 6, 0, 6, 0, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, 0, -2, 0, 4, 0, 2, 0, -3, 0, 3, 0, -3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -1, 0, -2, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, -6, 0, 6, 0, 6, 0, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, 0, -2, 0, 4, 0, 2, 0, -3, 0, 3, 0, -3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -1, 0, -2, 0, -1, 0},
        {18, -18, -18, 18, -18, 18, 18, -18, 12, 6, -12, -6, -12, -6, 12, 6, 12, -12, 6, -6, -12, 12, -6, 6, 9, -9, -9, 9, 9, -9, -9, 9, 8, 4, 4, 2, -8, -4, -4, -2, 6, 3, -6, -3, 6, 3, -6, -3, 6, -6, 3, -3, 6, -6, 3, -3, 4, 2, 2, 1, 4, 2, 2, 1},
        {-12, 12, 12, -12, 12, -12, -12, 12, -6, -6, 6, 6, 6, 6, -6, -6, -8, 8, -4, 4, 8, -8, 4, -4, -6, 6, 6, -6, -6, 6, 6, -6, -4, -4, -2, -2, 4, 4, 2, 2, -3, -3, 3, 3, -3, -3, 3, 3, -4, 4, -2, 2, -4, 4, -2, 2, -2, -2, -1, -1, -2, -2, -1, -1},
        {4, 0, -4, 0, -4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, -2, 0, -2, 0, 2, 0, -2, 0, 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 4, 0, -4, 0, -4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, -2, 0, -2, 0, 2, 0, -2, 0, 2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0},
        {-12, 12, 12, -12, 12, -12, -12, 12, -8, -4, 8, 4, 8, 4, -8, -4, -6, 6, -6, 6, 6, -6, 6, -6, -6, 6, 6, -6, -6, 6, 6, -6, -4, -2, -4, -2, 4, 2, 4, 2, -4, -2, 4, 2, -4, -2, 4, 2, -3, 3, -3, 3, -3, 3, -3, 3, -2, -1, -2, -1, -2, -1, -2, -1},
        {8, -8, -8, 8, -8, 8, 8, -8, 4, 4, -4, -4, -4, -4, 4, 4, 4, -4, 4, -4, -4, 4, -4, 4, 4, -4, -4, 4, 4, -4, -4, 4, 2, 2, 2, 2, -2, -2, -2, -2, 2, 2, -2, -2, 2, 2, -2, -2, 2, -2, 2, -2, 2, -2, 2, -2, 1, 1, 1, 1, 1, 1, 1, 1}};

    for (int i = 0; i < 64; ++i) {
        C[i] = ValueT(0);





        for (int j = 0; j < 64; j += 4) {
            C[i] += A[i][j] * X[j] + A[i][j + 1] * X[j + 1] + A[i][j + 2] * X[j + 2] + A[i][j + 3] * X[j + 3];
        }

    }
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
__attribute__((host)) __attribute__((device)) typename TreeOrAccT::ValueType TricubicSampler<TreeOrAccT>::sample(const Vec3T<RealT> &xyz, const ValueT (&C)[64])
{
    ValueT zPow(1), sum(0);
    for (int k = 0, n = 0; k < 4; ++k) {
        ValueT yPow(1);
        for (int j = 0; j < 4; ++j, n += 4) {



            sum += yPow * zPow * (C[n] + xyz[0] * (C[n + 1] + xyz[0] * (C[n + 2] + xyz[0] * C[n + 3])));

            yPow *= xyz[1];
        }
        zPow *= xyz[2];
    }
    return sum;
}

template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 3, true> : public TricubicSampler<TreeOrAccT>
{
    using BaseT = TricubicSampler<TreeOrAccT>;
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

    mutable CoordT mPos;
    mutable ValueT mC[64];

    template<typename RealT, template<typename...> class Vec3T>
    __attribute__((host)) __attribute__((device)) void cache(Vec3T<RealT>& xyz) const;

public:

    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc)
        : BaseT(acc)
    {
    }


    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(Vec3T<RealT> xyz) const;


    __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}

};

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 3, true>::operator()(Vec3T<RealT> xyz) const
{
    this->cache(xyz);
    return BaseT::sample(xyz, mC);
}

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
void SampleFromVoxels<TreeOrAccT, 3, true>::cache(Vec3T<RealT>& xyz) const
{
    CoordT ijk = Floor<CoordT>(xyz);
    if (ijk != mPos) {
        mPos = ijk;
        BaseT::stencil(ijk, mC);
    }
}

template<typename TreeOrAccT>
class SampleFromVoxels<TreeOrAccT, 3, false> : public TricubicSampler<TreeOrAccT>
{
    using BaseT = TricubicSampler<TreeOrAccT>;
    using ValueT = typename TreeOrAccT::ValueType;
    using CoordT = typename TreeOrAccT::CoordType;

public:

    __attribute__((host)) __attribute__((device)) SampleFromVoxels(const TreeOrAccT& acc)
        : BaseT(acc)
    {
    }


    template<typename RealT, template<typename...> class Vec3T>
    inline __attribute__((host)) __attribute__((device)) ValueT operator()(Vec3T<RealT> xyz) const;

    __attribute__((host)) __attribute__((device)) ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}

};

template<typename TreeOrAccT>
template<typename RealT, template<typename...> class Vec3T>
__attribute__((host)) __attribute__((device)) typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 3, false>::operator()(Vec3T<RealT> xyz) const
{
    ValueT C[64];
    CoordT ijk = Floor<CoordT>(xyz);
    BaseT::stencil(ijk, C);
    return BaseT::sample(xyz, C);
}

}
# 14 "/beegfs/teran_parrales/NVISII/include/nvisii/volume_struct.h" 2

struct VolumeStruct
{
    float gradient_factor = 0.5f;
    float scale = 1.f;
    float absorption = 0.5f;
    float scattering = 0.5f;
    float g_parameter= 0.0f;
};
# 18 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2

# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/./buffer.h" 1
       






template<class T>
class Buffer : public owl::device::Buffer
{
  public:
  __attribute__((host)) __attribute__((device))
  inline T get(size_t address, uint32_t line) {


    if (data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", line); asm("trap;");}
    if (address >= count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", line, uint32_t(address), uint32_t(count)); asm("trap;");}


    return ((T*)data)[address];
  }

  __attribute__((host)) __attribute__((device))
  inline T* getPtr(size_t address, uint32_t line) {


    if (data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", line); asm("trap;");}
    if (address >= count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", line, uint32_t(address), uint32_t(count)); asm("trap;");}


    return &((T*)data)[address];
  }
};
# 20 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/launch_params.h" 2

struct LaunchParams {
    Buffer<float> assignmentBuffer;

    glm::ivec2 frameSize;
    uint64_t frameID = 0;
    glm::vec4 *frameBuffer;
    uchar4 *albedoBuffer;
    glm::vec4 *normalBuffer;
    glm::vec4 *scratchBuffer;
    glm::vec4 *mvecBuffer;
    glm::vec4 *accumPtr;
    OptixTraversableHandle IAS;
    float domeLightIntensity = 1.f;
    float domeLightExposure = 0.f;
    glm::vec3 domeLightColor = glm::vec3(-1.f);
    float directClamp = 100.f;
    float indirectClamp = 100.f;
    uint32_t maxDiffuseDepth = 2;
    uint32_t maxGlossyDepth = 2;
    uint32_t maxTransparencyDepth = 8;
    uint32_t maxTransmissionDepth = 12;
    uint32_t maxVolumeDepth = 2;
    uint32_t numLightSamples = 1;
    uint32_t seed = 0;
    vec2 xPixelSamplingInterval = vec2(0.f,1.f);
    vec2 yPixelSamplingInterval = vec2(0.f,1.f);
    vec2 timeSamplingInterval = vec2(0.f,1.f);
    mat4 proj;
    mat4 viewT0;
    mat4 viewT1;

    EntityStruct cameraEntity;
    Buffer<EntityStruct> entities;
    Buffer<TransformStruct> transforms;
    Buffer<MaterialStruct> materials;
    Buffer<CameraStruct> cameras;
    Buffer<MeshStruct> meshes;
    Buffer<LightStruct> lights;
    Buffer<TextureStruct> textures;
    Buffer<VolumeStruct> volumes;
    Buffer<uint32_t> lightEntities;
    Buffer<uint32_t> instanceToEntity;
    uint32_t numLightEntities = 0;

    Buffer<Buffer<float3>> vertexLists;
    Buffer<Buffer<float4>> normalLists;
    Buffer<Buffer<float4>> tangentLists;
    Buffer<Buffer<float2>> texCoordLists;
    Buffer<Buffer<int3>> indexLists;

    int32_t environmentMapID = -1;
    glm::quat environmentMapRotation = glm::quat(1,0,0,0);
    float* environmentMapRows = nullptr;
    float* environmentMapCols = nullptr;
    int environmentMapWidth = 0;
    int environmentMapHeight = 0;
    cudaTextureObject_t proceduralSkyTexture = 0;
    Buffer<cudaTextureObject_t> textureObjects;
    Buffer<Buffer<uint8_t>> volumeHandles;

    cudaTextureObject_t GGX_E_AVG_LOOKUP;
    cudaTextureObject_t GGX_E_LOOKUP;


    uint32_t renderDataMode = 0;
    uint32_t renderDataBounce = 0;

    glm::vec3 sceneBBMin = glm::vec3(0.f);
    glm::vec3 sceneBBMax = glm::vec3(0.f);

    bool enableDomeSampling = true;
};

enum RenderDataFlags : uint32_t {
  NONE = 0,
  DEPTH = 1,
  POSITION = 2,
  NORMAL = 3,
  ENTITY_ID = 4,
  SCREEN_SPACE_NORMAL = 5,
  DIFFUSE_MOTION_VECTORS = 7,
  BASE_COLOR = 8,
  DIFFUSE_COLOR = 9,
  DIFFUSE_DIRECT_LIGHTING = 10,
  DIFFUSE_INDIRECT_LIGHTING = 11,
  GLOSSY_COLOR = 12,
  GLOSSY_DIRECT_LIGHTING = 13,
  GLOSSY_INDIRECT_LIGHTING = 14,
  TRANSMISSION_COLOR = 15,
  TRANSMISSION_DIRECT_LIGHTING = 16,
  TRANSMISSION_INDIRECT_LIGHTING = 17,
  RAY_DIRECTION = 18,
  HEATMAP = 19,
  TEXTURE_COORDINATES = 20,
  DEVICE_ID = 21,
  TANGENT = 22
};
# 6 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/types.h" 1
       
# 7 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.h" 1
       







using namespace glm;


struct TrianglesGeomData
{int placeholder;};


struct VolumeGeomData {
    float4 bbmin;
    float4 bbmax;
    uint32_t volumeID;
};


struct RayGenData
{



    int deviceIndex;



    int deviceCount;
};


struct MissProgData
{int placeholder;};
# 8 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 1
       

# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/cuda_utils.h" 1
       



# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 1
       




__attribute__((device)) float4 make_float4(float c) {
 return make_float4(c, c, c, c);
}

__attribute__((device)) float4 make_float4(float3 v, float c) {
 return make_float4(v.x, v.y, v.z, c);
}

__attribute__((device)) float4 make_float4(glm::vec3 v, float c) {
 return make_float4(v.x, v.y, v.z, c);
}

__attribute__((device)) float4 make_float4(glm::vec4 v) {
 return make_float4(v.x, v.y, v.z, v.w);
}

__attribute__((device)) float3 make_float3(float c) {
 return make_float3(c, c, c);
}

__attribute__((device)) float3 make_float3(float4 v) {
 return make_float3(v.x, v.y, v.z);
}

__attribute__((device)) float3 make_float3(glm::vec4 v) {
 return make_float3(v.x, v.y, v.z);
}

__attribute__((device)) float3 make_float3(glm::vec3 v) {
 return make_float3(v.x, v.y, v.z);
}

__attribute__((device)) float2 make_float2(float c) {
 return make_float2(c, c);
}

__attribute__((device)) float2 make_float2(uint2 v) {
 return make_float2(v.x, v.y);
}

__attribute__((device)) float2 make_float2(glm::vec2 v) {
 return make_float2(v.x, v.y);
}

__attribute__((device)) glm::vec4 make_vec4(float4 v) {
 return glm::vec4(v.x, v.y, v.z, v.w);
}

__attribute__((device)) glm::vec4 make_vec4(float3 v, float c) {
 return glm::vec4(v.x, v.y, v.z, c);
}

__attribute__((device)) glm::vec3 make_vec3(float4 v) {
 return glm::vec3(v.x, v.y, v.z);
}

__attribute__((device)) glm::vec3 make_vec3(float3 v) {
 return glm::vec3(v.x, v.y, v.z);
}

__attribute__((device)) glm::vec2 make_vec2(float2 v) {
 return glm::vec2(v.x, v.y);
}

__attribute__((device)) glm::ivec3 make_ivec3(int3 v) {
 return glm::ivec3(v.x, v.y, v.z);
}

__attribute__((device)) glm::mat4 to_mat4(float xfm_[12])
{
    glm::mat4 xfm;
    xfm = glm::column(xfm, 0, vec4(xfm_[0], xfm_[4], xfm_[8], 0.0f));
    xfm = glm::column(xfm, 1, vec4(xfm_[1], xfm_[5], xfm_[9], 0.0f));
    xfm = glm::column(xfm, 2, vec4(xfm_[2], xfm_[6], xfm_[10], 0.0f));
    xfm = glm::column(xfm, 3, vec4(xfm_[3], xfm_[7], xfm_[11], 1.0f));
 return xfm;
}

__attribute__((device)) void to_optix_tfm(glm::mat4 mat, float *xfm)
{
 xfm[0] = mat[0][0];
 xfm[1] = mat[0][1];
 xfm[2] = mat[0][2];
 xfm[3] = mat[1][0];
 xfm[4] = mat[1][1];
 xfm[5] = mat[1][2];
 xfm[6] = mat[2][0];
 xfm[7] = mat[2][1];
 xfm[8] = mat[2][2];
 xfm[9] = mat[3][0];
 xfm[10] = mat[3][1];
 xfm[11] = mat[3][2];
}

__attribute__((device)) float length(const float3 &v) {

 return __fsqrt_rn(v.x * v.x + v.y * v.y + v.z * v.z);
}

__attribute__((device)) float3 normalize(const float3 &v) {




 const float c = __frsqrt_rn(v.x * v.x + v.y * v.y + v.z * v.z);
 return make_float3(v.x * c, v.y * c, v.z * c);
}

__attribute__((device)) float3 cross(const float3 &a, const float3 &b) {
 float3 c;
 c.x = a.y * b.z - a.z * b.y;
 c.y = a.z * b.x - a.x * b.z;
 c.z = a.x * b.y - a.y * b.x;
 return c;
}

__attribute__((device)) float3 neg(const float3 &a) {
 return make_float3(-a.x, -a.y, -a.z);
}

__attribute__((device)) bool all_zero(const float3 &v) {
 return v.x == 0.f && v.y == 0.f && v.z == 0.f;
}

__attribute__((device)) float dot(const float3 a, const float3 b) {
 return a.x * b.x + a.y * b.y + a.z * b.z;
}

__attribute__((device)) float3 operator*(const quat &l, const float3 &r) {
 return make_float3(l * make_vec3(r));
}

__attribute__((device)) float4 operator*(const mat4 &l, const float4 &r) {
 return make_float4(l * make_vec4(r));
}

__attribute__((device)) float4 operator*(const float4 &l, const float4 &r) {
 return make_float4(l.x * r.x, l.y * r.y, l.z * r.z, l.w * r.w);
}

__attribute__((device)) float4 operator*(const uint32_t s, const float4 &v) {
 return make_float4(s * v.x, s * v.y, s * v.z, s * v.w);
}

__attribute__((device)) float4 operator*(const float4 &v, const uint32_t s) {
 return s * v;
}

__attribute__((device)) float4 operator+(const float4 &a, const float4 &b) {
 return make_float4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
}

__attribute__((device)) float4 operator/(const float4 &a, const uint32_t s) {
 const float x = 1.f / s;
 return x * a;
}

__attribute__((device)) float3 operator-(const float3 &a, const float3 &b) {
 return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
}

__attribute__((device)) float3 operator-(const float3 &a, const float s) {
 return make_float3(a.x - s, a.y - s, a.z - s);
}

__attribute__((device)) float3 operator-(const float s, const float3 &a) {
 return make_float3(s - a.x, s - a.y, s - a.z);
}

__attribute__((device)) float3 operator-(const float3 &a) {
 return make_float3(-a.x, -a.y, -a.z);
}

__attribute__((device)) float3 operator+(const float3 &a, const float3 &b) {
 return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
}

__attribute__((device)) float3 operator+(const float3 &a, const float s) {
 return make_float3(a.x + s, a.y + s, a.z + s);
}

__attribute__((device)) float3 operator+(const float s, const float3 &a) {
 return a + s;
}

__attribute__((device)) float3 operator*(const float3 &a, const float s) {
 return make_float3(a.x * s, a.y * s, a.z * s);
}

__attribute__((device)) float3 operator*(const float s, const float3 &a) {
 return a * s;
}

__attribute__((device)) float3 operator*(const float3 &a, const float3 &b) {
 return make_float3(a.x * b.x, a.y * b.y, a.z * b.z);
}

__attribute__((device)) float3 operator/(const float3 &a, const float s) {
 return make_float3(a.x / s, a.y / s, a.z / s);
}

__attribute__((device)) float3 operator/(const float s, const float3 &a) {
 return make_float3(a.x / s, a.y / s, a.z / s);
}

__attribute__((device)) float3 operator/(const float3 &a, const float3 &b) {
 return make_float3(a.x / b.x, a.y / b.y, a.z / b.z);
}

__attribute__((device)) float2 operator-(const float2 &a, const float2 &b) {
 return make_float2(a.x - b.x, a.y - b.y);
}

__attribute__((device)) float2 operator-(const float2 &a, const float s) {
 return make_float2(a.x - s, a.y - s);
}

__attribute__((device)) float2 operator-(const float s, const float2 &a) {
 return make_float2(s - a.x, s - a.y);
}

__attribute__((device)) float2 operator-(const float2 &a) {
 return make_float2(-a.x, -a.y);
}

__attribute__((device)) float2 operator+(const float2 &a, const float2 &b) {
 return make_float2(a.x + b.x, a.y + b.y);
}

__attribute__((device)) float2 operator+(const float2 &a, const float s) {
 return make_float2(a.x + s, a.y + s);
}

__attribute__((device)) float2 operator+(const float s, const float2 &a) {
 return a + s;
}

__attribute__((device)) float2 operator*(const float2 &a, const float s) {
 return make_float2(a.x * s, a.y * s);
}

__attribute__((device)) float2 operator*(const float s, const float2 &a) {
 return a * s;
}

__attribute__((device)) float2 operator/(const float2 &a, const float2 &b) {
 return make_float2(a.x / b.x, a.y / b.y);
}

__attribute__((device))
float approx_acosf(float x) {
    return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f;
}



__attribute__((device))
float approx_atanf(float z)
{
    const float n1 = 0.97239411f;
    const float n2 = -0.19194795f;
    return (n1 + n2 * z * z) * z;
}

__attribute__((device))
float approx_atan2f(float y, float x)
{
    if (x != 0.0f)
    {
        if (fabsf(x) > fabsf(y))
        {
            const float z = y / x;
            if (x > 0.0)
            {

                return approx_atanf(z);
            }
            else if (y >= 0.0)
            {

                return approx_atanf(z) + 
# 286 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 3 4
                                        3.14159265358979323846
# 286 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h"
                                            ;
            }
            else
            {

                return approx_atanf(z) - 
# 291 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 3 4
                                        3.14159265358979323846
# 291 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h"
                                            ;
            }
        }
        else
        {
            const float z = x / y;
            if (y > 0.0)
            {

                return -approx_atanf(z) + 
# 300 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 3 4
                                         1.57079632679489661923
# 300 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h"
                                               ;
            }
            else
            {

                return -approx_atanf(z) - 
# 305 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 3 4
                                         1.57079632679489661923
# 305 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h"
                                               ;
            }
        }
    }
    else
    {
        if (y > 0.0f)
        {
            return 
# 313 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 3 4
                  1.57079632679489661923
# 313 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h"
                        ;
        }
        else if (y < 0.0f)
        {
            return -
# 317 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h" 3 4
                   1.57079632679489661923
# 317 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/float3.h"
                         ;
        }
    }
    return 0.0f;
}
# 6 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/cuda_utils.h" 2




__attribute__((device)) float3 uncharted_2_tonemap(float3 x)
{
 if (x.x < 0) x.x = 0;
 if (x.y < 0) x.y = 0;
 if (x.z < 0) x.z = 0;
 float A = 0.15f;
 float B = 0.50f;
 float C = 0.10f;
 float D = 0.20f;
 float E_ = 0.02f;
 float F = 0.30f;
 float3 result = ((x*(A*x+C*B)+D*E_)/(x*(A*x+B)+D*F)) -E_/F;
 if (result.x < 0) result.x = 0;
 if (result.y < 0) result.y = 0;
 if (result.z < 0) result.z = 0;
 return result;
}

__attribute__((device)) float linear_to_srgb(float x) {
 if (x <= 0.0031308f) {
  return 12.92f * x;
 }
 return 1.055f * pow(x, 1.f/2.4f) - 0.055f;
}

__attribute__((device)) float luminance(const float3 &c) {
 return 0.2126f * c.x + 0.7152f * c.y + 0.0722f * c.z;
}

__attribute__((device)) float pow2(float x) {
 return x * x;
}


__attribute__((device)) void ortho_basis(float3 &b1, float3 &b2, float3 n)
{
    if (n.z < -0.9999999f)
    {
        b1 = make_float3( 0.0f, -1.0f, 0.0f);
        b2 = make_float3(-1.0f, 0.0f, 0.0f);
        return;
    }
    float a = 1.0f / (1.0f + n.z);
    float b = -n.x*n.y*a;
    b1 = make_float3(1.0 - n.x*n.x*a, b, -n.x);
    b2 = make_float3(b, 1.0 - n.y*n.y*a, -n.y);
}

template<typename T>
__attribute__((device)) T clamp(const T &x, const T &lo, const T &hi) {
 if (x < lo) {
  return lo;
 }
 if (x > hi) {
  return hi;
 }
 return x;
}

__attribute__((device)) float lerp(float x, float y, float s) {
 return x * (1.f - s) + y * s;
}

__attribute__((device)) float3 lerp(float3 x, float3 y, float s) {
 return x * (1.f - s) + y * s;
}

__attribute__((device)) float3 reflect(const float3 &i, const float3 &n) {
 return i - 2.f * n * dot(i, n);
}

__attribute__((device)) float3 refract( float3 i, float3 n, float eta )
{
  if (eta == 1.f) return i;
  if (eta <= 0.f) return make_float3(0.f);
  if (isnan(eta)) return make_float3(0.f);
  if (isinf(eta)) return make_float3(0.f);
  float cosi = dot(-i, n);
  float cost2 = 1.0f - eta * eta * (1.0f - cosi*cosi);
  float3 t = eta*i + ((eta*cosi - sqrt(abs(cost2))) * n);
  return t * ((cost2 > 0.f) ? make_float3(1.f) : make_float3(0.f));
}

__attribute__((device)) float3 refract_ray(const float3 &i, const float3 &n, float eta) {
 float n_dot_i = dot(n, i);
 float k = 1.f - eta * eta * (1.f - n_dot_i * n_dot_i);
 if (k < 0.f) {
  return make_float3(0.f);
 }
 return eta * i - (eta * n_dot_i + sqrt(k)) * n;
}

__attribute__((device)) float component(const float4 &v, const uint32_t i) {
    switch (i) {
    case 0: return v.x;
    case 1: return v.y;
    case 2: return v.z;
    case 3: return v.w;
    default: return __int_as_float(0x7fffffffU);
    }
}

__attribute__((device)) void* unpack_ptr(uint32_t hi, uint32_t lo) {
 const uint64_t val = static_cast<uint64_t>(hi) << 32 | lo;
 return reinterpret_cast<void*>(val);
}

__attribute__((device)) void pack_ptr(void *ptr, uint32_t &hi, uint32_t &lo) {
 const uint64_t val = reinterpret_cast<uint64_t>(ptr);
 hi = val >> 32;
 lo = val & 0x00000000ffffffff;
}

template<typename T>
__attribute__((device)) T& get_payload() {
 return *reinterpret_cast<T*>(unpack_ptr(optixGetPayload_0(), optixGetPayload_1()));
}

template<typename T>
__attribute__((device)) const T& get_shader_params() {
 return *reinterpret_cast<const T*>(optixGetSbtDataPointer());
}
# 4 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 2

# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/lcg_rng.h" 1
       




struct LCGRand {
    uint32_t state;
};

__attribute__((device)) uint32_t murmur_hash3_mix(uint32_t hash, uint32_t k)
{
    const uint32_t c1 = 0xcc9e2d51;
    const uint32_t c2 = 0x1b873593;
    const uint32_t r1 = 15;
    const uint32_t r2 = 13;
    const uint32_t m = 5;
    const uint32_t n = 0xe6546b64;

    k *= c1;
    k = (k << r1) | (k >> (32 - r1));
    k *= c2;

    hash ^= k;
    hash = ((hash << r2) | (hash >> (32 - r2))) * m + n;

    return hash;
}

__attribute__((device)) uint32_t murmur_hash3_finalize(uint32_t hash)
{
    hash ^= hash >> 16;
    hash *= 0x85ebca6b;
    hash ^= hash >> 13;
    hash *= 0xc2b2ae35;
    hash ^= hash >> 16;

    return hash;
}

__attribute__((device)) uint32_t lcg_random(LCGRand &rng)
{
    const uint32_t m = 1664525;
    const uint32_t n = 1013904223;
    rng.state = rng.state * m + n;
    return rng.state;
}

__attribute__((device)) float lcg_randomf(LCGRand &rng)
{
    return ldexp((float)lcg_random(rng), -32);
}

__attribute__((device)) LCGRand get_rng(int frame_id, uint2 pixel, uint2 dims)
{
    LCGRand rng;
    rng.state = murmur_hash3_mix(0, pixel.x + pixel.y * dims.x);
    rng.state = murmur_hash3_mix(rng.state, frame_id);
    rng.state = murmur_hash3_finalize(rng.state);

    return rng;
}
# 6 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 2
# 24 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
struct DisneyMaterial {
 float3 base_color;
 float3 subsurface_color;
 float metallic;

 float specular;
 float roughness;
 float specular_tint;
 float anisotropy;

 float sheen;
 float sheen_tint;
 float clearcoat;
 float clearcoat_gloss;

 float ior;
 float specular_transmission;
 float transmission_roughness;
 float flatness;
 float alpha;
};

__attribute__((device)) bool same_hemisphere(const float3 &w_o, const float3 &w_i, const float3 &n) {
 return dot(w_o, n) * dot(w_i, n) > 0.f;
}

__attribute__((device)) bool relative_ior(const float3 &w_o, const float3 &n, float ior, float &eta_o, float &eta_i)
{
 bool entering = dot(w_o, n) > 0.f;
 eta_i = entering ? 1.f : ior;
 eta_o = entering ? ior : 1.f;
 return entering;
}



__attribute__((device)) float3 cos_sample_hemisphere(float2 u) {
 float2 s = 2.f * u - make_float2(1.f);
 float2 d;
 float radius = 0.f;
 float theta = 0.f;
 if (s.x == 0.f && s.y == 0.f) {
  d = s;
 } else {
  if (fabs(s.x) > fabs(s.y)) {
   radius = s.x;
   theta = 
# 70 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
           3.14159265358979323846 
# 70 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                / 4.f * (s.y / s.x);
  } else {
   radius = s.y;
   theta = 
# 73 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
           3.14159265358979323846 
# 73 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                / 2.f - 
# 73 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                        3.14159265358979323846 
# 73 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                             / 4.f * (s.x / s.y);
  }
 }
 d = radius * make_float2(cos(theta), sin(theta));
 return make_float3(d.x, d.y, sqrt(max(0.f, 1.f - d.x * d.x - d.y * d.y)));
}

__attribute__((device)) float3 spherical_dir(float sin_theta, float cos_theta, float phi) {
 return make_float3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);
}

__attribute__((device)) float power_heuristic(float n_f, float pdf_f, float n_g, float pdf_g) {
 float f = n_f * pdf_f;
 float g = n_g * pdf_g;
 return (f * f) / (f * f + g * g);
}

__attribute__((device)) float schlick_weight(float cos_theta) {
 return pow(saturate(1.f - cos_theta), 5.f);
}





__attribute__((device)) float fresnel_dielectric(float cos_theta_i, float eta_i, float eta_t) {
 float g = pow2(eta_t) / pow2(eta_i) - 1.f + pow2(cos_theta_i);
 if (g < 0.f) {
  return 1.f;
 }
 return 0.5f * pow2(g - cos_theta_i) / pow2(g + cos_theta_i)
  * (1.f + pow2(cos_theta_i * (g + cos_theta_i) - 1.f) / pow2(cos_theta_i * (g - cos_theta_i) + 1.f));
}



__attribute__((device)) float gtr_1(float cos_theta_h, float alpha) {
 if (alpha >= 1.f) {
  return 
# 111 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
        0.31830988618379067154
# 111 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
              ;
 }
 float alpha_sqr = alpha * alpha;
 return 
# 114 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
       0.31830988618379067154 
# 114 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
              * (alpha_sqr - 1.f) / (log(alpha_sqr) * (1.f + (alpha_sqr - 1.f) * cos_theta_h * cos_theta_h));
}



__attribute__((device)) float gtr_2(float cos_theta_h, float alpha) {
 float alpha_sqr = alpha * alpha;
 return 
# 121 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
       0.31830988618379067154 
# 121 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
              * alpha_sqr / max(pow2(1.f + (alpha_sqr - 1.f) * cos_theta_h * cos_theta_h), 0.00000000001f);
}



__attribute__((device)) float gtr_2_aniso(float h_dot_n, float h_dot_x, float h_dot_y, float2 alpha) {
 return 
# 127 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
       0.31830988618379067154 
# 127 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
              / max((alpha.x * alpha.y * pow2(pow2(h_dot_x / alpha.x) + pow2(h_dot_y / alpha.y) + h_dot_n * h_dot_n)), 0.00000000001f);
}

__attribute__((device)) float smith_shadowing_ggx(float n_dot_o, float alpha_g) {
 float a = alpha_g * alpha_g;
 float b = n_dot_o * n_dot_o;
 return 1.f / (n_dot_o + sqrt(a + b - a * b));
}

__attribute__((device)) float smith_shadowing_ggx_aniso(float n_dot_o, float o_dot_x, float o_dot_y, float2 alpha) {
 return 1.f / (n_dot_o + sqrt(pow2(o_dot_x * alpha.x) + pow2(o_dot_y * alpha.y) + pow2(n_dot_o)));
}


__attribute__((device)) float3 sample_lambertian_dir(const float3 &n, const float3 &v_x, const float3 &v_y, const float2 &s) {
 const float3 hemi_dir = normalize(cos_sample_hemisphere(s));
 return hemi_dir.x * v_x + hemi_dir.y * v_y + hemi_dir.z * n;
}


__attribute__((device)) float3 sample_gtr_1_h(const float3 &n, const float3 &v_x, const float3 &v_y, float alpha, const float2 &s) {
 float phi_h = 2.f * 
# 148 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                    3.14159265358979323846 
# 148 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                         * s.x;
 float alpha_sqr = alpha * alpha;
 float cos_theta_h_sqr = (1.f - pow(alpha_sqr, 1.f - s.y)) / (1.f - alpha_sqr);
 float cos_theta_h = sqrt(cos_theta_h_sqr);
 float sin_theta_h = 1.f - cos_theta_h_sqr;
 float3 hemi_dir = normalize(spherical_dir(sin_theta_h, cos_theta_h, phi_h));
 return hemi_dir.x * v_x + hemi_dir.y * v_y + hemi_dir.z * n;
}

__attribute__((device)) float3 sample_gtr_2_h(const float3 &n, const float3 &v_x, const float3 &v_y, float alpha, const float2 &s) {
 float phi_h = 2.f * 
# 158 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                    3.14159265358979323846 
# 158 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                         * s.x;
 float cos_theta_h_sqr = (1.f - s.y) / (1.f + (alpha * alpha - 1.f) * s.y);
 float cos_theta_h = sqrt(cos_theta_h_sqr);
 float sin_theta_h = 1.f - cos_theta_h_sqr;
 float3 hemi_dir = normalize(spherical_dir(sin_theta_h, cos_theta_h, phi_h));
 return hemi_dir.x * v_x + hemi_dir.y * v_y + hemi_dir.z * n;
}

__attribute__((device)) float3 sample_gtr_2_aniso_h(const float3 &n, const float3 &v_x, const float3 &v_y, const float2 &alpha, const float2 &s) {
 float x = 2.f * 
# 167 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                3.14159265358979323846 
# 167 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                     * s.x;
 float3 w_h = sqrt(s.y / (1.f - s.y)) * (alpha.x * cos(x) * v_x + alpha.y * sin(x) * v_y) + n;
 return normalize(w_h);
}

__attribute__((device)) float lambertian_pdf(const float3 &w_i, const float3 &n) {
 float d = dot(w_i, n);
 if (d > 0.f) {
  return d * 
# 175 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
            0.31830988618379067154
# 175 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                  ;
 }
 return 0.f;
}

__attribute__((device)) float gtr_1_pdf(const float3 &w_o, const float3 &w_i, const float3 &w_h, const float3 &n, float alpha) {
 if (!same_hemisphere(w_o, w_i, n)) {
  return 0.f;
 }
 float cos_theta_h = dot(n, w_h);
 float d = gtr_1(cos_theta_h, alpha);
 return d * cos_theta_h / (4.f * dot(w_o, w_h));
}

__attribute__((device)) float gtr_2_pdf(const float3 &w_o, const float3 &w_i, const float3 &w_h, const float3 &n, float alpha) {
 if (!same_hemisphere(w_o, w_i, n)) {
  return 0.f;
 }
 float cos_theta_h = fabs(dot(n, w_h));
 float d = gtr_2(cos_theta_h, alpha);
 return d * cos_theta_h / (4.f * fabs(dot(w_o, w_h)));
}

__attribute__((device)) float gtr_2_transmission_pdf(const float3 &w_o, const float3 &w_i, const float3 &n, float transmission_roughness, float ior)
{
 float alpha = max(0.001f, transmission_roughness * transmission_roughness);

 if (same_hemisphere(w_o, w_i, n)) {
  return 0.f;
 }




 float eta_o, eta_i;
 bool entering = relative_ior(w_o, n, ior, eta_o, eta_i);


 float3 w_ht = -(w_o * eta_i + w_i * eta_o);
 w_ht = normalize(w_ht);

 float cos_theta_h = fabs(dot(n, w_ht));
 float d = gtr_2(cos_theta_h, alpha);

 return d;
# 246 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
}
# 276 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
__attribute__((device)) float gtr_2_aniso_pdf(const float3 &w_o, const float3 &w_i, const float3 &w_h, const float3 &n,
 const float3 &v_x, const float3 &v_y, const float2 alpha)
{
 if (!same_hemisphere(w_o, w_i, n)) {
  return 0.f;
 }
 float cos_theta_h = dot(n, w_h);
 float d = gtr_2_aniso(cos_theta_h, fabs(dot(w_h, v_x)), fabs(dot(w_h, v_y)), alpha);
 return d * cos_theta_h / (4.f * dot(w_o, w_h));
}

__attribute__((device)) float3 disney_diffuse_color(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h)
{
 return mat.base_color;
}

__attribute__((device)) float3 disney_subsurface_color(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i)
{
 return mat.subsurface_color;
}

__attribute__((device)) void disney_diffuse(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h, float3 &bsdf, float3 &color)
{
 float n_dot_o = fabs(dot(w_o, n));
 float n_dot_i = fabs(dot(w_i, n));
 float i_dot_h = dot(w_i, w_h);
 float fd90 = 0.5f + 1.0f * mat.roughness * i_dot_h * i_dot_h;
 float fi = schlick_weight(n_dot_i);
 float fo = schlick_weight(n_dot_o);
 color = disney_diffuse_color(mat, n, w_o, w_i, w_h);
 bsdf = make_float3(
# 309 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                   0.31830988618379067154 
# 309 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                          * lerp(1.f, fd90, fi) * lerp(1.f, fd90, fo));
}

__attribute__((device)) void disney_subsurface(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h, float3 &bsdf, float3 &color) {
    float n_dot_o = fabs(dot(w_o, n));
 float n_dot_i = fabs(dot(w_i, n));
 float i_dot_h = dot(w_i, w_h);

    float FL = schlick_weight(n_dot_i), FV = schlick_weight(n_dot_o);
    float Fss90 = i_dot_h*i_dot_h * mat.roughness;
    float Fss = lerp(1.0, Fss90, FL) * lerp(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1. / (n_dot_i + n_dot_o) - .5) + .5);
    color = disney_subsurface_color(mat, n, w_o, w_i);
 bsdf = make_float3(
# 323 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                   0.31830988618379067154 
# 323 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                          * ss);
}


__attribute__((device)) float AverageEnergy(float rough){
    float smoothness = 1.0 - rough;
    float r = -0.0761947 - 0.383026 * smoothness;
          r = 1.04997 + smoothness * r;
          r = 0.409255 + smoothness * r;
    return min(0.9, r);
}



__attribute__((device)) float3 AverageFresnel(float3 specularColor){
    return specularColor + (make_float3(1.0) - specularColor) * (1.0 / 21.0);
}

__attribute__((device)) float3 disney_multiscatter(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h,
 cudaTextureObject_t GGX_E_LOOKUP, cudaTextureObject_t GGX_E_AVG_LOOKUP)
{
 float v_dot_n = abs(dot(w_o, n));
 float l_dot_n = abs(dot(w_i, n));
 float alpha = max(mat.roughness*mat.roughness, .04f * .04f);




 float E_o = tex2D<float>(GGX_E_LOOKUP, v_dot_n, alpha);
    float oneMinusE_o = 1.0 - E_o;
    float E_i = tex2D<float>(GGX_E_LOOKUP, l_dot_n, alpha);
    float oneMinusE_i = 1.0 - E_i;

    float Eavg = tex2D<float>(GGX_E_AVG_LOOKUP, alpha, .5);

    float oneMinusEavg = 1.0 - Eavg;

 float lum = luminance(mat.base_color);
 float3 tint = lum > 0.f ? mat.base_color / lum : make_float3(1.f);
 float3 F0 = lerp(mat.specular * 0.08f * lerp(make_float3(1.f), tint, mat.specular_tint), mat.base_color, mat.metallic);
 float3 Favg = AverageFresnel(F0);

    float brdf = (oneMinusE_o * oneMinusE_i) / (
# 366 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h" 3 4
                                               3.14159265358979323846 
# 366 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
                                                    * oneMinusEavg);
    float3 energyScale = (Favg * Favg * Eavg) / (make_float3(1.0) - Favg * oneMinusEavg);

    return brdf * energyScale;
}
# 410 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
__attribute__((device)) float3 disney_microfacet_reflection_color(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h)
{
 float lum = luminance(mat.base_color);
 float3 tint = lum > 0.f ? mat.base_color / lum : make_float3(1.f);
 float3 spec = lerp(mat.specular * 0.08f * lerp(make_float3(1.f), tint, mat.specular_tint), mat.base_color, mat.metallic);

 float alpha = max(.04f * .04f, mat.roughness * mat.roughness);
 float3 f = lerp(spec, make_float3(1.f), schlick_weight(dot(w_o, n)));

 return f;
}

__attribute__((device)) float3 disney_microfacet_isotropic(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h)
{
 float lum = luminance(mat.base_color);
 float3 tint = lum > 0.f ? mat.base_color / lum : make_float3(1.f);
 float3 spec = lerp(mat.specular * 0.08f * lerp(make_float3(1.f), tint, mat.specular_tint), mat.base_color, mat.metallic);

 float alpha = max(.04f * .04f, mat.roughness * mat.roughness);
 float d = gtr_2(fabs(dot(n, w_h)), alpha);


 float3 f = lerp(spec, make_float3(1.f), schlick_weight(fabs(dot(w_i, w_h))) * lerp(.5f, 1.f, max(mat.metallic, alpha)));
 float g = smith_shadowing_ggx(fabs(dot(n, w_i)), alpha) * smith_shadowing_ggx(fabs(dot(n, w_o)), alpha);
 return d * f * g;
}

__attribute__((device)) float3 disney_microfacet_transmission_color(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h)
{


 return mat.base_color;
}

__attribute__((device)) void disney_microfacet_transmission_isotropic(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, float &bsdf, float3 &color)
{

 float eta_o, eta_i;
 bool entering = relative_ior(w_o, n, mat.ior, eta_o, eta_i);

 float alpha = max(0.001f, mat.transmission_roughness * mat.transmission_roughness);


 float3 w_ht = -(w_o * eta_i + w_i * eta_o);
 w_ht = normalize(w_ht);

 color = disney_microfacet_transmission_color(mat, n, w_o, w_i, w_ht);

 float lum = luminance(color);
 float3 tint = lum > 0.f ? color / lum : make_float3(1.f);

 float3 spec = disney_microfacet_transmission_color(mat, n, w_o, w_i, w_ht);


 float cos_theta_h = fabs(dot(n, w_ht));
 float d = gtr_2(cos_theta_h, alpha);
 float3 f = lerp(spec, make_float3(1.f), 1.0f - schlick_weight(dot(w_i, w_ht)));
 float g = smith_shadowing_ggx(abs(dot(n, w_i)), alpha) * smith_shadowing_ggx(abs(dot(n, w_o)), alpha);

 bsdf = d;
 color = spec;
 return;
# 506 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
}

__attribute__((device)) float3 disney_microfacet_anisotropic(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h, const float3 &v_x, const float3 &v_y)
{
 float lum = luminance(mat.base_color);
 float3 tint = lum > 0.f ? mat.base_color / lum : make_float3(1.f);
 float3 spec = lerp(mat.specular * 0.08f * lerp(make_float3(1.f), tint, mat.specular_tint), mat.base_color, mat.metallic);

 float aspect = sqrt(1.f - mat.anisotropy * 0.9f);
 float a = mat.roughness * mat.roughness;
 float2 alpha = make_float2(max(.04f * .04f, a / aspect), max(.04f * .04f, a * aspect));
 float d = gtr_2_aniso(fabs(dot(n, w_h)), fabs(dot(w_h, v_x)), fabs(dot(w_h, v_y)), alpha);


 float3 f = lerp(spec, make_float3(1.f), schlick_weight(fabs(dot(w_i, w_h))) * lerp(.5f, 1.f, max(mat.metallic, alpha.x * alpha.y)));
 float g = smith_shadowing_ggx_aniso(fabs(dot(n, w_i)), fabs(dot(w_i, v_x)), fabs(dot(w_i, v_y)), alpha)
  * smith_shadowing_ggx_aniso(fabs(dot(n, w_o)), fabs(dot(w_o, v_x)), fabs(dot(w_o, v_y)), alpha);
 return d * f * g;
}

__attribute__((device)) float disney_clear_coat(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h)
{
 float alpha = lerp(0.1f, .04f * .04f, mat.clearcoat_gloss);
 float d = gtr_1(fabs(dot(n, w_h)), alpha);
 float f = lerp(0.04f, 1.f, schlick_weight(dot(w_i, n)));
 float g = smith_shadowing_ggx(fabs(dot(n, w_i)), 0.25f) * smith_shadowing_ggx(fabs(dot(n, w_o)), 0.25f);
 return mat.clearcoat * d * f * g;
}

__attribute__((device)) float3 disney_sheen(const DisneyMaterial &mat, const float3 &n,
 const float3 &w_o, const float3 &w_i, const float3 &w_h)
{
 float lum = luminance(mat.base_color);
 float3 tint = lum > 0.f ? mat.base_color / lum : make_float3(1.f);
 float3 sheen_color = lerp(make_float3(1.f), tint, mat.sheen_tint);
 float f = schlick_weight(dot(w_i, n));
 return f * mat.sheen * sheen_color;
}
# 560 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
__attribute__((device)) void disney_brdf(
 const DisneyMaterial &mat,
 const float3 &g_n,
 const float3 &s_n,
 const float3 &b_n,
 const float3 &v_x,
 const float3 &v_y,
 const float3 &w_o,
 const float3 &w_i,
 const float3 &w_h,
 float3 &bsdf
) {

 bsdf = make_float3(0.f);


 if (!same_hemisphere(w_o, w_i, b_n) && (mat.specular_transmission > 0.f)) {
  float spec_trans; float3 trans_color;
  disney_microfacet_transmission_isotropic(mat, b_n, w_o, w_i, spec_trans, trans_color);
  spec_trans = spec_trans * (1.f - mat.metallic) * mat.specular_transmission;
  bsdf = make_float3(spec_trans) * trans_color;
  return;
 }

 float coat = disney_clear_coat(mat, b_n, w_o, w_i, w_h);
 float3 sheen = disney_sheen(mat, b_n, w_o, w_i, w_h);
 float3 diffuse_bsdf, diffuse_color;
 disney_diffuse(mat, b_n, w_o, w_i, w_h, diffuse_bsdf, diffuse_color);
 float3 subsurface_bsdf, subsurface_color;
 disney_subsurface(mat, b_n, w_o, w_i, w_h, subsurface_bsdf, subsurface_color);
 float3 gloss;
 if (mat.anisotropy == 0.f) {
  gloss = disney_microfacet_isotropic(mat, b_n, w_o, w_i, w_h);

 } else
 {
  gloss = disney_microfacet_anisotropic(mat, b_n, w_o, w_i, w_h, v_x, v_y);

 }

 bsdf = (lerp(diffuse_bsdf * diffuse_color,
    subsurface_bsdf * subsurface_color,
    mat.flatness)
  * (1.f - mat.metallic) * (1.f - mat.specular_transmission)
   + sheen + coat + gloss) * fabs(dot(w_i, b_n));
}
# 620 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
__attribute__((device)) void disney_pdf(
 const DisneyMaterial &mat,
 const float3 &g_n,
 const float3 &s_n,
 const float3 &b_n,
 const float3 &v_x,
 const float3 &v_y,
 const float3 &w_o,
 const float3 &w_i,
 const float3 &w_h,
 float &pdf
) {
 pdf = 0.f;

 bool entering = dot(w_o, b_n) > 0.f;
 bool sameHemisphere = same_hemisphere(w_o, w_i, b_n);

 float alpha = max(0.002f, mat.roughness * mat.roughness);
 float t_alpha = max(0.002f, mat.transmission_roughness * mat.transmission_roughness);
 float aspect = sqrt(1.f - mat.anisotropy * 0.9f);
 float2 alpha_aniso = make_float2(max(0.002f, alpha / aspect), max(0.002f, alpha * aspect));

 float clearcoat_alpha = lerp(0.1f, .04f * .04f, mat.clearcoat_gloss);

 float diffuse = lambertian_pdf(w_i, b_n);
 float clear_coat = gtr_1_pdf(w_o, w_i, w_h, b_n, clearcoat_alpha);

 float n_comp = 3.f;
 float microfacet = 0.f;
 float microfacet_transmission = 0.f;
 if (mat.anisotropy == 0.f) {
  microfacet = gtr_2_pdf(w_o, w_i, w_h, b_n, alpha);
 } else {
  microfacet = gtr_2_aniso_pdf(w_o, w_i, w_h, b_n, v_x, v_y, alpha_aniso);
 }

 if ((mat.specular_transmission > 0.f) && (!same_hemisphere(w_o, w_i, b_n))) {
  microfacet_transmission = gtr_2_transmission_pdf(w_o, w_i, b_n, mat.transmission_roughness, mat.ior);
 }
# 668 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
 float metallic_kludge = mat.metallic;
 float transmission_kludge = mat.specular_transmission;
 n_comp -= lerp(transmission_kludge, metallic_kludge, mat.metallic);
 pdf = (diffuse + microfacet + microfacet_transmission + clear_coat) / n_comp;
}
# 690 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/disney_bsdf.h"
__attribute__((device)) void sample_disney_brdf(
 const DisneyMaterial &mat,
 LCGRand &rng,
 const float3 &g_n, const float3 &s_n, const float3 &b_n,
 const float3 &v_x, const float3 &v_y,
 const float3 &w_o,
 float3 &w_i,
 float &pdf,
 int &sampled_bsdf,
 float3 &bsdf
) {

 if (mat.specular_transmission == 0.f) {
  sampled_bsdf = lcg_randomf(rng) * 3.f;
  sampled_bsdf = glm::clamp(sampled_bsdf, 0, 2);
 } else {

  if (dot(w_o, b_n) > 0.f) {
   sampled_bsdf = lcg_randomf(rng) * 4.f;
   sampled_bsdf = glm::clamp(sampled_bsdf, 0, 3);
  }
  else sampled_bsdf = 3;
 }

 float2 samples = make_float2(lcg_randomf(rng), lcg_randomf(rng));
 if (sampled_bsdf == 0) {
  w_i = sample_lambertian_dir(b_n, v_x, v_y, samples);
 } else if (sampled_bsdf == 1) {
  float3 w_h;
  float alpha = max(.04f * .04f, mat.roughness * mat.roughness);
  if (mat.anisotropy == 0.f) {
   w_h = sample_gtr_2_h(b_n, v_x, v_y, alpha, samples);
  } else {
   float aspect = sqrt(1.f - mat.anisotropy * 0.9f);
   float2 alpha_aniso = make_float2(max(.04f * .04f, alpha / aspect), max(.04f * .04f, alpha * aspect));
   w_h = sample_gtr_2_aniso_h(b_n, v_x, v_y, alpha_aniso, samples);
  }
  w_i = reflect(-w_o, w_h);


  if (!same_hemisphere(w_o, w_i, b_n)) {
   pdf = 0.f;
   w_i = make_float3(0.f);
   bsdf = make_float3(0.f);
   return;
  }
 } else if (sampled_bsdf == 2) {
  float alpha = lerp(0.1f, .04f * .04f, mat.clearcoat_gloss);
  float3 w_h = sample_gtr_1_h(b_n, v_x, v_y, alpha, samples);
  w_i = reflect(-w_o, w_h);


  if (!same_hemisphere(w_o, w_i, b_n)) {
   pdf = 0.f;
   w_i = make_float3(0.f);
   bsdf = make_float3(0.f);
   return;
  }
 } else if (sampled_bsdf == 3) {
  float alpha = max(.04f * .04f, mat.transmission_roughness * mat.transmission_roughness);
  float3 w_h = sample_gtr_2_h(b_n, v_x, v_y, alpha, samples);
  float eta_o, eta_i;
  bool entering = relative_ior(w_o, w_h, mat.ior, eta_o, eta_i);



  w_i = refract(-w_o, (entering) ? w_h : -w_h, eta_i / eta_o);


  if (all_zero(w_i)) {
   w_i = reflect(-w_o, (entering) ? w_h : -w_h);
   pdf = 1.f;
   bsdf = make_float3(1.f);
   return;
  }
 }

 float3 w_h = normalize(w_i + w_o);
 disney_pdf(mat, g_n, s_n, b_n, v_x, v_y, w_o, w_i, w_h, pdf);
 disney_brdf(mat, g_n, s_n, b_n, v_x, v_y, w_o, w_i, w_h, bsdf);
}
# 9 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/lights.h" 1
       




inline __attribute__((device))
float PdfAtoW( float aPdfA, float aDist2, float aCosThere ){
    float absCosTheta = abs(aCosThere);
    if( absCosTheta < 0.0001f )
        return 0.0;

    return aPdfA * aDist2 / absCosTheta;
}

inline __attribute__((device))
float3 uniformPointWithinTriangle( const float3 &v1, const float3 &v2, const float3 &v3, float rand1, float rand2 ) {
    rand1 = sqrt(rand1);
    return (1.0f - rand1)* v1 + rand1 * (1.0f-rand2) * v2 + rand1 * rand2 * v3;
}

inline __attribute__((device))
float2 uniformUVWithinTriangle( const float2 &uv1, const float2 &uv2, const float2 &uv3, float rand1, float rand2 ) {
    rand1 = sqrt(rand1);
    return (1.0f - rand1)* uv1 + rand1 * (1.0f-rand2) * uv2 + rand1 * rand2 * uv3;
}

inline __attribute__((device))
void sampleTriangle(const float3 &pos,
     const float3 &n1, const float3 &n2, const float3 &n3,
     const float3 &v1, const float3 &v2, const float3 &v3,
     const float2 &uv1, const float2 &uv2, const float2 &uv3,
     const float rand1, const float rand2,
          float3 &dir, float &distance, float &pdf, float2 &uv,
     bool double_sided, bool use_surface_area)
{
 float3 p = uniformPointWithinTriangle( v1, v2, v3, rand1, rand2 );
 float3 n = uniformPointWithinTriangle( n1, n2, n3, rand1, rand2 );
 uv = uniformUVWithinTriangle( uv1, uv2, uv3, rand1, rand2 );
 float pdfA;
 if (use_surface_area) {
  float triangleArea = fabs(length(cross(v1-v2, v3-v2)) * 0.5);
  float pdfA = 1.0f / triangleArea;
 } else{
  pdfA = 1.0f;
 }
 dir = p - pos;
 float d2 = dot(dir, dir);
 float d = sqrt(d2);
  distance = d;
 dir = (dir / d);
 float aCosThere = max(0.0, (double_sided) ? fabs(dot(-dir,n)) : dot(-dir,n));
 pdf = PdfAtoW( pdfA, d2, aCosThere );
}

__attribute__((device))
const float* upper_bound (const float* first, const float* last, const float& val)
{
  const float* it;

  int count, step;

  count = (last-first);
  while (count > 0)
  {
    it = first;
    step=count/2;

    it = it + step;
    if ( ! (val < *it))
    {
        first=++it;
        count-=step+1;
    }
    else count=step;
  }
  return first;
}

__attribute__((device)) float sample_cdf(const float* data, unsigned int n, float x, unsigned int *idx, float* pdf)
{
    *idx = upper_bound(data, data + n, x) - data;
    float scaled_sample;
    if (*idx == 0) {
        *pdf = data[0];
        scaled_sample = x / data[0];
    } else {
        *pdf = data[*idx] - data[*idx - 1];
        scaled_sample = (x - data[*idx - 1]) / (data[*idx] - data[*idx - 1]);
    }

    return min(scaled_sample, 0.99999994f);
}
# 10 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/Tools/easybuild/stacks/rome/2022a/software/GCCcore/11.3.0/include/c++/11.3.0/math.h" 1 3
# 11 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_device.h" 1
# 43 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_device.h"
# 1 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_7_device.h" 1
# 44 "/beegfs/teran_parrales/NVISII/externals/optix-7.2.0/include/optix_device.h" 2
# 12 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2
# 1 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/random.h" 1
# 48 "/beegfs/teran_parrales/NVISII/externals/owl/owl/include/owl/common/math/random.h"
       



namespace owl {
  namespace common {


    template<unsigned int N=4>
    struct LCG {

      inline __attribute__((host)) __attribute__((device)) LCG()
      {

      }
      inline __attribute__((host)) __attribute__((device)) LCG(unsigned int val0, unsigned int val1)
      { init(val0,val1); }

      inline __attribute__((host)) __attribute__((device)) LCG(const vec2i &seed)
      { init((unsigned)seed.x,(unsigned)seed.y); }
      inline __attribute__((host)) __attribute__((device)) LCG(const vec2ui &seed)
      { init(seed.x,seed.y); }

      inline __attribute__((host)) __attribute__((device)) void init(unsigned int val0, unsigned int val1)
      {
        unsigned int v0 = val0;
        unsigned int v1 = val1;
        unsigned int s0 = 0;

        for (unsigned int n = 0; n < N; n++) {
          s0 += 0x9e3779b9;
          v0 += ((v1<<4)+0xa341316c)^(v1+s0)^((v1>>5)+0xc8013ea4);
          v1 += ((v0<<4)+0xad90777d)^(v0+s0)^((v0>>5)+0x7e95761e);
        }
        state = v0;
      }


      inline __attribute__((host)) __attribute__((device)) float operator() ()
      {
        const uint32_t LCG_A = 1664525u;
        const uint32_t LCG_C = 1013904223u;
        state = (LCG_A * state + LCG_C);
        return ldexpf(float(state), -32);

      }

      uint32_t state;
    };





    struct DRand48
    {


      inline __attribute__((host)) __attribute__((device)) void init(int seed = 0)
      {
        state = seed;
        for (int warmUp=0;warmUp<10;warmUp++)
          (*this)();
      }


      inline __attribute__((host)) __attribute__((device)) float operator() ()
      {
        const uint64_t a = 0x5DEECE66DULL;
        const uint64_t c = 0xBULL;
        const uint64_t mask = 0xFFFFFFFFFFFFULL;
        state = a*state + c;
        return float(state & mask) / float(mask+1ULL);

      }

      uint64_t state;
    };

  }
}
# 13 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2

# 1 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/test.h" 1



       



__attribute__((device)) float x_pixels_frac = (float) 0.50;
__attribute__((device)) float y_pixels_frac = (float) 0.50;
__attribute__((device)) bool print_on = false;


__attribute__((device)) void printRayInfo(auto LP, int2 pixelID, auto ray, auto payload, const char* Tag){


int x_pixel = LP.frameSize.x*x_pixels_frac;
int y_pixel = LP.frameSize.y*y_pixels_frac;


if(pixelID.x == x_pixel && pixelID.y ==y_pixel && print_on){
 printf("\n### %-*s ",25, Tag);
 printf(" Pixel[%d, %d]", pixelID.x, pixelID.y);
 printf(" Origin(%f, %f, %f)" ,ray.origin.x, ray.origin.y, ray.origin.z);
 printf(" Direction(%f, %f, %f)",ray.direction.x, ray.direction.y, ray.direction.z);
 printf(" Raytime: %f", ray.time);
 printf(" tHit: %f", payload.tHit);
 printf("\n");
 }
}


__attribute__((device)) void printRayInfo(auto LP, int2 pixelID, auto ray, auto payload, const char* Tag, float parameter){


int x_pixel = LP.frameSize.x*x_pixels_frac;
int y_pixel = LP.frameSize.y*y_pixels_frac;


if(pixelID.x == x_pixel && pixelID.y ==y_pixel && print_on){
 printf("\n### %-*s ",25, Tag);
 printf(" Pixel[%d, %d]", pixelID.x, pixelID.y);
 printf(" Origin(%f, %f, %f)" ,ray.origin.x, ray.origin.y, ray.origin.z);
 printf(" Direction(%f, %f, %f)",ray.direction.x, ray.direction.y, ray.direction.z);
 printf(" Raytime: %f", ray.time);
 printf(" tHit: %f", payload.tHit);
 printf(" Value: %f", parameter);
 printf("\n");
 }
}


__attribute__((device)) void printRayInfo(auto LP, int2 pixelID, auto ray, auto payload, const char* Tag, float3 vector){


int x_pixel = LP.frameSize.x*x_pixels_frac;
int y_pixel = LP.frameSize.y*y_pixels_frac;


if(pixelID.x == x_pixel && pixelID.y ==y_pixel && print_on){
 printf("\n### %-*s ",25, Tag);
 printf(" Pixel[%d, %d]", pixelID.x, pixelID.y);
 printf(" Origin(%f, %f, %f)" ,ray.origin.x, ray.origin.y, ray.origin.z);
 printf(" Direction(%f, %f, %f)",ray.direction.x, ray.direction.y, ray.direction.z);
 printf(" Raytime: %f", ray.time);
 printf(" tHit: %f", payload.tHit);
 printf(" Vector(%f,%f,%f)", vector.x, vector.y, vector.z);
 printf("\n");
 }
}
# 80 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/test.h"
__attribute__((device)) void computeSinesAndCosecants(float3 cosines, float3 *sines, float3 *cosecants) {
    sines->x = sqrt(1 - cosines.x * cosines.x);
    sines->y = sqrt(1 - cosines.y * cosines.y);
    sines->z = sqrt(1 - cosines.z * cosines.z);

    cosecants->x = 1 / sines->x;
    cosecants->y = 1 / sines->y;
    cosecants->z = 1 / sines->z;
}


__attribute__((device)) void computeVectorSum(float3 cos_alp_be_ga, float3 sin_alp_be_ga, float3 cos_HG, float3 sin_HG,
                      float3 *cos_alp_be_ga_1, float3 *sin_alp_be_ga_1) {
    cos_alp_be_ga_1->x = cos_alp_be_ga.x * cos_HG.x - sin_alp_be_ga.x * sin_HG.x;
    cos_alp_be_ga_1->y = cos_alp_be_ga.y * cos_HG.y - sin_alp_be_ga.y * sin_HG.y;
    cos_alp_be_ga_1->z = cos_alp_be_ga.z * cos_HG.z - sin_alp_be_ga.z * sin_HG.z;

    sin_alp_be_ga_1->x = sin_alp_be_ga.x * cos_HG.x + cos_alp_be_ga.x * sin_HG.x;
    sin_alp_be_ga_1->y = sin_alp_be_ga.y * cos_HG.y + cos_alp_be_ga.y * sin_HG.y;
    sin_alp_be_ga_1->z = sin_alp_be_ga.z * cos_HG.z + cos_alp_be_ga.z * sin_HG.z;
}

__attribute__((device)) void computeDeviatedVectors(
    float3* w_alpha,
    float3* w_beta,
    float3* w_gamma,
    float3* w_i,
    float3 cos_alp_be_ga_1,
    float3 sin_alp_be_ga_1,
    float3 cos_alp_be_ga,
    float3 sin_alp_be_ga,
    float3 csc_alp_be_ga
    ){
        w_alpha->x=cos_alp_be_ga_1.x;
        w_alpha->y=sin_alp_be_ga_1.x*csc_alp_be_ga.x*cos_alp_be_ga.y;
        w_alpha->z=sin_alp_be_ga_1.x*csc_alp_be_ga.x*cos_alp_be_ga.z;

        w_beta->x=sin_alp_be_ga_1.y*csc_alp_be_ga.y*cos_alp_be_ga.x;
        w_beta->y=cos_alp_be_ga_1.y;
        w_beta->z=sin_alp_be_ga_1.y*csc_alp_be_ga.y*cos_alp_be_ga.z;

        w_gamma->x=sin_alp_be_ga_1.z*csc_alp_be_ga.z*cos_alp_be_ga.x;
        w_gamma->y=sin_alp_be_ga_1.z*csc_alp_be_ga.z*cos_alp_be_ga.y;
        w_gamma->z=cos_alp_be_ga_1.z;

        w_i->x=w_alpha->x + w_beta->x + w_gamma->x;
        w_i->y=w_alpha->y + w_beta->y + w_gamma->y;
        w_i->z=w_alpha->z + w_beta->z + w_gamma->z;

    }

__attribute__((device)) float3 DeviatedVector(
    float3 w_o,
    float3 cos_HG,
    float *dot_w_o_w_i
    ){
        w_o = normalize(w_o);


        float3 sin_HG, csc_HG;
        computeSinesAndCosecants(cos_HG, &sin_HG, &csc_HG);


        float3 cos_alp_be_ga = w_o;
        float3 sin_alp_be_ga, csc_alp_be_ga;
        computeSinesAndCosecants(cos_alp_be_ga, &sin_alp_be_ga, &csc_alp_be_ga);


        float3 cos_alp_be_ga_1, sin_alp_be_ga_1;
        computeVectorSum(cos_alp_be_ga, sin_alp_be_ga, cos_HG, sin_HG, &cos_alp_be_ga_1, &sin_alp_be_ga_1);

        float3 w_alpha={0,0,0};
        float3 w_beta={0,0,0};
        float3 w_gamma={0,0,0};
        float3 w_i;

        computeDeviatedVectors(
            &w_alpha,
            &w_beta,
            &w_gamma,
            &w_i,
            cos_alp_be_ga_1,
            sin_alp_be_ga_1,
            cos_alp_be_ga,
            sin_alp_be_ga,
            csc_alp_be_ga);

        w_i = normalize(w_i);
        *dot_w_o_w_i = w_i.x*w_o.x + w_i.y*w_o.y + w_i.z*w_o.z;
    return w_i;
    }
# 15 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2

# 1 "/beegfs/teran_parrales/NVISII/include/nvisii/utilities/procedural_sky.h" 1
       
# 15 "/beegfs/teran_parrales/NVISII/include/nvisii/utilities/procedural_sky.h"
using namespace glm;

inline __attribute__((host)) __attribute__((device))
float Scale(float inCos)
{
 float x = 1.0f - inCos;
 return 0.25f * exp(-0.00287f + x*(0.459f + x*(3.83f + x*(-6.80f + x*5.25f))));
}

inline __attribute__((host)) __attribute__((device))
vec3 ProceduralSkybox(
    vec3 rd,
    vec3 sunPos,
    vec3 skyTint = vec3(.5f, .5f, .5f),
    float atmosphereThickness = 1.0f,
    float saturation = 1.0f
)
{







    const vec3 ScatteringWavelength = vec3(.65f, .57f, .475f);
    const vec3 ScatteringWavelengthRange = vec3(.15f, .15f, .15f);
    const float kOuterRadius = 1.025f;
    const float kOuterRadius2 = 1.025f*1.025f;
    const float kInnerRadius = 1.0f;
    const float kInnerRadius2 = 1.0f;
    const float kCameraHeight = 0.0001f;
    const float kHDSundiskIntensityFactor = 15.0f;
    const float kSunScale = 400.0f * 20.0f;
    const float kKmESun = 0.0010f * 20.0f;
    const float kKm4PI = 0.0010f * 4.0f * 3.14159265f;
    const float kScale = 1.0 / (1.025f - 1.0f);
    const float kScaleDepth = 0.25f;
    const float kScaleOverScaleDepth = (1.0f / (1.025f - 1.0f)) / 0.25f;
    const float kSamples = 2.0f;

    vec3 kSkyTintInGammaSpace = skyTint;
    vec3 kScatteringWavelength = mix(ScatteringWavelength-ScatteringWavelengthRange,ScatteringWavelength+ScatteringWavelengthRange,vec3(1.f,1.f,1.f) - kSkyTintInGammaSpace);
    vec3 kInvWavelength = 1.0f / (pow(kScatteringWavelength, vec3(4.0f)));
    float kKrESun = (mix(0.0f, 0.0025f, pow(atmosphereThickness,2.5f))) * 20.0f;
    float kKr4PI = (mix(0.0f, 0.0025f, pow(atmosphereThickness,2.5f))) * 4.0f * 3.14159265f;
    vec3 cameraPos = vec3(0.f,kInnerRadius + kCameraHeight,0.f);
    vec3 eyeRay = rd;
    eyeRay.y = abs(eyeRay.y);
    float _far = 0.0f;
    vec3 cIn, cOut;

    _far = sqrt(kOuterRadius2 + kInnerRadius2 * eyeRay.y * eyeRay.y - kInnerRadius2) - kInnerRadius * eyeRay.y;
    vec3 pos = cameraPos + _far * eyeRay;
    float height = kInnerRadius + kCameraHeight;
    float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));
    float startAngle = dot(eyeRay, cameraPos) / height;
    float startOffset = depth*Scale(startAngle);
    float sampleLength = _far / kSamples;
    float scaledLength = sampleLength * kScale;
    vec3 sampleRay = eyeRay * sampleLength;
    vec3 samplePoint = cameraPos + sampleRay * 0.5f;
    vec3 frontColor = vec3(0.0f, 0.0f, 0.0f);
    for (int i=0; i<2; i++)
    {
        float height = length(samplePoint);
        float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));
        float lightAngle = dot(normalize(sunPos), samplePoint) / height;
        float cameraAngle = dot(eyeRay, samplePoint) / height;
        float scatter = (startOffset + depth*(Scale(lightAngle) - Scale(cameraAngle)));
        vec3 attenuate = exp(-glm::clamp(scatter, 0.0f, 50.0f) * (kInvWavelength * kKr4PI + kKm4PI));
        frontColor += attenuate * (depth * scaledLength);
        samplePoint += sampleRay;
    }
    cIn = frontColor * (kInvWavelength * kKrESun);
    cOut = frontColor * kKmESun;

    vec3 skyColor = (cIn * (0.75f + 0.75f * dot(normalize(sunPos), -eyeRay) * dot(normalize(sunPos), -eyeRay)));
    skyColor = pow(skyColor, vec3(1.0f / 2.2f));

    vec3 W = vec3(0.2125f, 0.7154f, 0.0721f);
    vec3 intensity = vec3(dot(skyColor, W));
    skyColor = glm::mix(intensity, skyColor, saturation);


    vec3 color = skyColor;
    return color;
}
# 17 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/matrix_interpolation.hpp" 1
# 14 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/matrix_interpolation.hpp"
       
# 27 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/matrix_interpolation.hpp"
namespace glm
{





 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) void axisAngle(
  mat<4, 4, T, Q> const& Mat, vec<3, T, Q> & Axis, T & Angle);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> axisAngleMatrix(
  vec<3, T, Q> const& Axis, T const Angle);



 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> extractMatrixRotation(
  mat<4, 4, T, Q> const& Mat);




 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) mat<4, 4, T, Q> interpolate(
  mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2, T const Delta);


}

# 1 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/matrix_interpolation.inl" 1




namespace glm
{
 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline void axisAngle(mat<4, 4, T, Q> const& m, vec<3, T, Q> & axis, T& angle)
 {
  T epsilon = static_cast<T>(0.01);
  T epsilon2 = static_cast<T>(0.1);

  if((abs(m[1][0] - m[0][1]) < epsilon) && (abs(m[2][0] - m[0][2]) < epsilon) && (abs(m[2][1] - m[1][2]) < epsilon))
  {
   if ((abs(m[1][0] + m[0][1]) < epsilon2) && (abs(m[2][0] + m[0][2]) < epsilon2) && (abs(m[2][1] + m[1][2]) < epsilon2) && (abs(m[0][0] + m[1][1] + m[2][2] - static_cast<T>(3.0)) < epsilon2))
   {
    angle = static_cast<T>(0.0);
    axis.x = static_cast<T>(1.0);
    axis.y = static_cast<T>(0.0);
    axis.z = static_cast<T>(0.0);
    return;
   }
   angle = static_cast<T>(3.1415926535897932384626433832795);
   T xx = (m[0][0] + static_cast<T>(1.0)) * static_cast<T>(0.5);
   T yy = (m[1][1] + static_cast<T>(1.0)) * static_cast<T>(0.5);
   T zz = (m[2][2] + static_cast<T>(1.0)) * static_cast<T>(0.5);
   T xy = (m[1][0] + m[0][1]) * static_cast<T>(0.25);
   T xz = (m[2][0] + m[0][2]) * static_cast<T>(0.25);
   T yz = (m[2][1] + m[1][2]) * static_cast<T>(0.25);
   if((xx > yy) && (xx > zz))
   {
    if(xx < epsilon)
    {
     axis.x = static_cast<T>(0.0);
     axis.y = static_cast<T>(0.7071);
     axis.z = static_cast<T>(0.7071);
    }
    else
    {
     axis.x = sqrt(xx);
     axis.y = xy / axis.x;
     axis.z = xz / axis.x;
    }
   }
   else if (yy > zz)
   {
    if(yy < epsilon)
    {
     axis.x = static_cast<T>(0.7071);
     axis.y = static_cast<T>(0.0);
     axis.z = static_cast<T>(0.7071);
    }
    else
    {
     axis.y = sqrt(yy);
     axis.x = xy / axis.y;
     axis.z = yz / axis.y;
    }
   }
   else
   {
    if (zz < epsilon)
    {
     axis.x = static_cast<T>(0.7071);
     axis.y = static_cast<T>(0.7071);
     axis.z = static_cast<T>(0.0);
    }
    else
    {
     axis.z = sqrt(zz);
     axis.x = xz / axis.z;
     axis.y = yz / axis.z;
    }
   }
   return;
  }
  T s = sqrt((m[2][1] - m[1][2]) * (m[2][1] - m[1][2]) + (m[2][0] - m[0][2]) * (m[2][0] - m[0][2]) + (m[1][0] - m[0][1]) * (m[1][0] - m[0][1]));
  if (glm::abs(s) < T(0.001))
   s = static_cast<T>(1);
  T const angleCos = (m[0][0] + m[1][1] + m[2][2] - static_cast<T>(1)) * static_cast<T>(0.5);
  if(angleCos - static_cast<T>(1) < epsilon)
   angle = pi<T>() * static_cast<T>(0.25);
  else
   angle = acos(angleCos);
  axis.x = (m[1][2] - m[2][1]) / s;
  axis.y = (m[2][0] - m[0][2]) / s;
  axis.z = (m[0][1] - m[1][0]) / s;
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> axisAngleMatrix(vec<3, T, Q> const& axis, T const angle)
 {
  T c = cos(angle);
  T s = sin(angle);
  T t = static_cast<T>(1) - c;
  vec<3, T, Q> n = normalize(axis);

  return mat<4, 4, T, Q>(
   t * n.x * n.x + c, t * n.x * n.y + n.z * s, t * n.x * n.z - n.y * s, static_cast<T>(0.0),
   t * n.x * n.y - n.z * s, t * n.y * n.y + c, t * n.y * n.z + n.x * s, static_cast<T>(0.0),
   t * n.x * n.z + n.y * s, t * n.y * n.z - n.x * s, t * n.z * n.z + c, static_cast<T>(0.0),
   static_cast<T>(0.0), static_cast<T>(0.0), static_cast<T>(0.0), static_cast<T>(1.0));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> extractMatrixRotation(mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0][0], m[0][1], m[0][2], static_cast<T>(0.0),
   m[1][0], m[1][1], m[1][2], static_cast<T>(0.0),
   m[2][0], m[2][1], m[2][2], static_cast<T>(0.0),
   static_cast<T>(0.0), static_cast<T>(0.0), static_cast<T>(0.0), static_cast<T>(1.0));
 }

 template<typename T, qualifier Q>
 __attribute__((device)) __attribute__((host)) inline mat<4, 4, T, Q> interpolate(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2, T const delta)
 {
  mat<4, 4, T, Q> m1rot = extractMatrixRotation(m1);
  mat<4, 4, T, Q> dltRotation = m2 * transpose(m1rot);
  vec<3, T, Q> dltAxis;
  T dltAngle;
  axisAngle(dltRotation, dltAxis, dltAngle);
  mat<4, 4, T, Q> out = axisAngleMatrix(dltAxis, dltAngle * delta) * m1rot;
  out[3][0] = m1[3][0] + delta * (m2[3][0] - m1[3][0]);
  out[3][1] = m1[3][1] + delta * (m2[3][1] - m1[3][1]);
  out[3][2] = m1[3][2] + delta * (m2[3][2] - m1[3][2]);
  return out;
 }
}
# 61 "/beegfs/teran_parrales/NVISII/externals/glm/glm/gtx/matrix_interpolation.hpp" 2
# 19 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 2

typedef owl::common::LCG<4> Random;

extern "C" __attribute__((constant)) LaunchParams optixLaunchParams;

struct RayPayload {
    int instanceID = -1;
    int primitiveID = -1;
    float2 barycentrics;


    float3 objectSpaceRayOrigin;
    float3 objectSpaceRayDirection;
    float t0;
    float t1;
    int eventID = -1;
    float3 gradient;
    float3 mp;
    float density;
    float g_asy_parameter;

    float tHit = -1.f;
    float localToWorld[12];
    float localToWorldT0[12];
    float localToWorldT1[12];
    LCGRand rng;
};

__attribute__((device))
vec2 toUV(vec3 n)
{
    n.z = -n.z;
    n.x = -n.x;
    vec2 uv;

    uv.x = approx_atan2f(float(-n.x), float(n.y));
    uv.x = (uv.x + 
# 55 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                  3.14159265358979323846 
# 55 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                       / 2.0f) / (
# 55 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                  3.14159265358979323846 
# 55 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                       * 2.0f) + 
# 55 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                                 3.14159265358979323846 
# 55 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                                      * (28.670f / 360.0f);

    uv.y = ::clamp(float(acosf(n.z) / 
# 57 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                     3.14159265358979323846
# 57 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                         ), .001f, .999f);

    return uv;
}


__attribute__((device))
vec3 toPolar(vec2 uv)
{
    float theta = 2.0 * 
# 66 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                       3.14159265358979323846 
# 66 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                            * uv.x + - 
# 66 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                       3.14159265358979323846 
# 66 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                            / 2.0;
    float phi = 
# 67 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
               3.14159265358979323846 
# 67 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                    * uv.y;

    vec3 n;
    n.x = __cosf(theta) * __sinf(phi);
    n.y = __sinf(theta) * __sinf(phi);
    n.z = __cosf(phi);

    n.z = -n.z;
    n.x = -n.x;
    return n;
}

__attribute__((device))
cudaTextureObject_t getEnvironmentTexture()
{
    auto &LP = optixLaunchParams;
    cudaTextureObject_t tex = 0;
    if (LP.environmentMapID >= 0) {
        if (LP.textureObjects.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 85); asm("trap;");} if (LP.environmentMapID >= LP.textureObjects.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 85, LP.environmentMapID, uint32_t(LP.textureObjects.count)); asm("trap;");} tex = ((cudaTextureObject_t*)LP.textureObjects.data)[LP.environmentMapID];;
        return tex;
    } else if ((LP.environmentMapID == -2) && (LP.proceduralSkyTexture != 0)) {
        return LP.proceduralSkyTexture;
    }
    return tex;
}

inline __attribute__((device))
float3 missColor(const float3 n_dir, cudaTextureObject_t &tex)
{
    auto &LP = optixLaunchParams;
    vec3 rayDir = LP.environmentMapRotation * make_vec3(n_dir);
    if (tex)
    {
        vec2 tc = toUV(vec3(rayDir.x, rayDir.y, rayDir.z));
        float4 texColor = tex2D<float4>(tex, tc.x,tc.y);
        return make_float3(texColor);
    }

    if (glm::any(glm::greaterThanEqual(LP.domeLightColor, glm::vec3(0.f)))) return make_float3(LP.domeLightColor);
    float t = 0.5f*(rayDir.z + 1.0f);
    float3 c = (1.0f - t) * make_float3(pow(vec3(1.0f), vec3(2.2f))) + t * make_float3( pow(vec3(0.5f, 0.7f, 1.0f), vec3(2.2f)) );
    return c;
}

inline __attribute__((device))
float3 missColor(const owl::Ray &ray, cudaTextureObject_t &tex)
{
    return missColor(ray.direction, tex);
}


extern "C" __attribute__((global)) void __miss__miss()
{
}

extern "C" __attribute__((global)) void __closesthit__TriangleMesh()
{
    auto &LP = optixLaunchParams;
    RayPayload &prd = owl::getPRD<RayPayload>();
    prd.instanceID = optixGetInstanceIndex();
    prd.tHit = optixGetRayTmax();
    prd.barycentrics = optixGetTriangleBarycentrics();
    prd.primitiveID = optixGetPrimitiveIndex();
# 145 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
    optixGetObjectToWorldTransformMatrix(prd.localToWorld);



    if (LP.renderDataMode == RenderDataFlags::NONE) return;

    OptixTraversableHandle handle = optixGetTransformListHandle(prd.instanceID);
    float4 trf00, trf01, trf02;
    float4 trf10, trf11, trf12;

    optix_impl::optixGetInterpolatedTransformationFromHandle( trf00, trf01, trf02, handle, 0.f, true );
    optix_impl::optixGetInterpolatedTransformationFromHandle( trf10, trf11, trf12, handle, 1.f, true );
    memcpy(&prd.localToWorldT0[0], &trf00, sizeof(trf00));
    memcpy(&prd.localToWorldT0[4], &trf01, sizeof(trf01));
    memcpy(&prd.localToWorldT0[8], &trf02, sizeof(trf02));
    memcpy(&prd.localToWorldT1[0], &trf10, sizeof(trf10));
    memcpy(&prd.localToWorldT1[4], &trf11, sizeof(trf11));
    memcpy(&prd.localToWorldT1[8], &trf12, sizeof(trf12));
}

extern "C" __attribute__((global)) void __closesthit__ShadowRay()
{
    RayPayload &prd = owl::getPRD<RayPayload>();
    prd.instanceID = optixGetInstanceIndex();
    prd.tHit = optixGetRayTmax();
}
# 182 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
template<typename AccT>
__attribute__((device))
void SampleDeltaTracking(
    LCGRand &rng,
    AccT& acc,
    float majorant_extinction,
    float linear_attenuation_unit,
    float absorption_,
    float scattering_,
    vec3 x,
    vec3 w,
    float d,
    float &t,
    int &event,
    bool debug = false
) {
    float rand1 = lcg_randomf(rng);
    float rand2 = lcg_randomf(rng);


    t = (-log(1.0f - rand1) / majorant_extinction) * linear_attenuation_unit;


    if (t >= d) {
     event = 0;
        t = d;
        return;
    }


    x = x + t * w;
    auto coord_pos = nanovdb::Coord::Floor( nanovdb::Vec3f(x.x, x.y, x.z) );
    float densityValue = acc.getValue(coord_pos);

    float absorption = densityValue * absorption_;
    float scattering = densityValue * scattering_;
    float extinction = absorption + scattering;

    float null_collision = majorant_extinction - extinction;


    absorption = absorption / majorant_extinction;
    scattering = scattering / majorant_extinction;
    null_collision = null_collision / majorant_extinction;



    if (rand2 < absorption)
    {
     event = 1;
        return;
    }


    else if (rand2 < (absorption + scattering)) {

        event = 2;
        return;
    }


    else {
        event = 3;
        return;
    }
}

extern "C" __attribute__((global)) void __closesthit__VolumeMesh()
{
    auto &LP = optixLaunchParams;
    RayPayload &prd = owl::getPRD<RayPayload>();
    optixGetObjectToWorldTransformMatrix(prd.localToWorld);



    if (LP.renderDataMode == RenderDataFlags::NONE) return;

    OptixTraversableHandle handle = optixGetTransformListHandle(prd.instanceID);
    float4 trf00, trf01, trf02;
    float4 trf10, trf11, trf12;

    optix_impl::optixGetInterpolatedTransformationFromHandle( trf00, trf01, trf02, handle, 0.f, true );
    optix_impl::optixGetInterpolatedTransformationFromHandle( trf10, trf11, trf12, handle, 1.f, true );
    memcpy(&prd.localToWorldT0[0], &trf00, sizeof(trf00));
    memcpy(&prd.localToWorldT0[4], &trf01, sizeof(trf01));
    memcpy(&prd.localToWorldT0[8], &trf02, sizeof(trf02));
    memcpy(&prd.localToWorldT1[0], &trf10, sizeof(trf10));
    memcpy(&prd.localToWorldT1[4], &trf11, sizeof(trf11));
    memcpy(&prd.localToWorldT1[8], &trf12, sizeof(trf12));
}

extern "C" __attribute__((global)) void __closesthit__VolumeShadowRay()
{
}

extern "C" __attribute__((global)) void __intersection__VolumeIntersection()
{
    auto &LP = optixLaunchParams;
    const auto &self = owl::getProgramData<VolumeGeomData>();
    RayPayload &prd = owl::getPRD<RayPayload>();
    float3 origin = optixGetObjectRayOrigin();


    float3 direction = optixGetObjectRayDirection();

    float3 lb = make_float3(self.bbmin.x, self.bbmin.y, self.bbmin.z);
    float3 rt = make_float3(self.bbmax.x, self.bbmax.y, self.bbmax.z);


    float3 dirfrac;


    dirfrac.x = 1.0f / direction.x;
    dirfrac.y = 1.0f / direction.y;
    dirfrac.z = 1.0f / direction.z;



    float t1 = (lb.x - origin.x)*dirfrac.x;
    float t2 = (rt.x - origin.x)*dirfrac.x;
    float t3 = (lb.y - origin.y)*dirfrac.y;
    float t4 = (rt.y - origin.y)*dirfrac.y;
    float t5 = (lb.z - origin.z)*dirfrac.z;
    float t6 = (rt.z - origin.z)*dirfrac.z;

    float thit0 = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float thit1 = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));


    if (thit1 < 0) { return; }


    if (thit0 >= thit1) { return; }


    thit0 = max(thit0, optixGetRayTmin());


    if (LP.volumes.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 320); asm("trap;");} if (self.volumeID >= LP.volumes.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 320, self.volumeID, uint32_t(LP.volumes.count)); asm("trap;");} VolumeStruct volume = ((VolumeStruct*)LP.volumes.data)[self.volumeID];;
    uint8_t *hdl = (uint8_t*)LP.volumeHandles.get(self.volumeID, 321).data;
    const auto grid = reinterpret_cast<const nanovdb::FloatGrid*>(hdl);
    const auto& tree = grid->tree();
    auto acc = tree.getAccessor();
    auto nvdbSampler = nanovdb::SampleFromVoxels<nanovdb::DefaultReadAccessor<float>,
                                1, false>(acc);

    float majorant_extinction = acc.root().valueMax(); float minorant_extinction = acc.root().valueMin();
    float gradient_factor = volume.gradient_factor;
    float linear_attenuation_unit = volume.scale;
    float absorption = volume.absorption;
    float scattering = volume.scattering;

    auto bbox = acc.root().bbox();
    auto mx = bbox.max();
    auto mn = bbox.min();
    float3 offset = make_float3(glm::vec3(mn[0], mn[1], mn[2]) +
                (glm::vec3(mx[0], mx[1], mx[2]) -
                glm::vec3(mn[0], mn[1], mn[2])) * .5f);


    float t = thit0;
    int event;
    bool hitVolume = false;
    float unit = volume.scale / length(direction);

    for (int i = 0; i < 1000; ++i) {

        t = t - (log(1.0f - lcg_randomf(prd.rng)) / majorant_extinction) * unit;


        if (t >= thit1) return;


        float3 x = offset + origin + t * direction;


        float densityValue = nvdbSampler(nanovdb::Vec3f(x.x, x.y, x.z));

        float a = densityValue * absorption;
        float s = densityValue * scattering;
        float e = a + s;
        float n = majorant_extinction - e;

        a = a / majorant_extinction;
        s = s / majorant_extinction;
        n = n / majorant_extinction;

        float event = lcg_randomf(prd.rng);

        if (event < (a + s)) {
            if (optixReportIntersection(t, 0)) {
                auto g = nvdbSampler.gradient(nanovdb::Vec3f(x.x, x.y, x.z));
                prd.objectSpaceRayOrigin = origin;
                prd.objectSpaceRayDirection = direction;
                prd.eventID = (event < a) ? 1 : 2;
                prd.instanceID = optixGetInstanceIndex();
                prd.tHit = t;
                prd.mp = x - offset;
                prd.gradient = make_float3(g[0], g[1], g[2]);
                prd.density = densityValue;
  prd.g_asy_parameter = 2.0f*( (prd.density-minorant_extinction) / (majorant_extinction-minorant_extinction) )- 1.0f; prd.g_asy_parameter =0.0f;
  prd.g_asy_parameter = volume.g_parameter;

            }
            return;
        }


        else {
            event = 3;
            continue;
        }
    }
}

inline __attribute__((device)) void __boundsFunc__VolumeBounds(const void *geomData, owl::common::box3f &bounds, const int32_t primID); extern "C" __attribute__((global)) void __boundsFuncKernel__VolumeBounds(const void *geomData, owl::common::box3f *const boundsArray, const uint32_t numPrims) { uint32_t blockIndex = blockIdx.x + blockIdx.y * gridDim.x + blockIdx.z * gridDim.x * gridDim.y; uint32_t primID = threadIdx.x + blockDim.x*threadIdx.y + blockDim.x*blockDim.y*blockIndex; if (primID < numPrims) { __boundsFunc__VolumeBounds(geomData,boundsArray[primID],primID); } } inline __attribute__((device)) void __boundsFunc__VolumeBounds(
    const void *geomData,
    owl::common::box3f &primBounds,
    const int primID)
{
    const VolumeGeomData &self = *(const VolumeGeomData*)geomData;
    primBounds = owl::common::box3f();
    primBounds.lower.x = self.bbmin.x;
    primBounds.lower.y = self.bbmin.y;
    primBounds.lower.z = self.bbmin.z;
    primBounds.upper.x = self.bbmax.x;
    primBounds.upper.y = self.bbmax.y;
    primBounds.upper.z = self.bbmax.z;
}

inline __attribute__((device))
bool loadCamera(EntityStruct &cameraEntity, CameraStruct &camera, TransformStruct &transform)
{
    auto &LP = optixLaunchParams;
    cameraEntity = LP.cameraEntity;
    if (!cameraEntity.initialized) return false;
    if ((cameraEntity.transform_id < 0) || (cameraEntity.transform_id >= LP.transforms.count)) return false;
    if ((cameraEntity.camera_id < 0) || (cameraEntity.camera_id >= LP.cameras.count)) return false;
    if (LP.cameras.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 420); asm("trap;");} if (cameraEntity.camera_id >= LP.cameras.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 420, cameraEntity.camera_id, uint32_t(LP.cameras.count)); asm("trap;");} camera = ((CameraStruct*)LP.cameras.data)[cameraEntity.camera_id];;
    if (LP.transforms.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 421); asm("trap;");} if (cameraEntity.transform_id >= LP.transforms.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 421, cameraEntity.transform_id, uint32_t(LP.transforms.count)); asm("trap;");} transform = ((TransformStruct*)LP.transforms.data)[cameraEntity.transform_id];;
    return true;
}

inline __attribute__((device))
float3 sampleTexture(int32_t textureId, float2 texCoord, float3 defaultVal) {
    auto &LP = optixLaunchParams;
    if (textureId < 0 || textureId >= (LP.textures.count + LP.materials.count * 19)) return defaultVal;
    if (LP.textureObjects.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 429); asm("trap;");} if (textureId >= LP.textureObjects.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 429, textureId, uint32_t(LP.textureObjects.count)); asm("trap;");} cudaTextureObject_t tex = ((cudaTextureObject_t*)LP.textureObjects.data)[textureId];;
    if (!tex) return defaultVal;
    if (LP.textures.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 431); asm("trap;");} if (textureId >= LP.textures.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 431, textureId, uint32_t(LP.textures.count)); asm("trap;");} TextureStruct texInfo = ((TextureStruct*)LP.textures.data)[textureId];;
    texCoord.x = texCoord.x / texInfo.scale.x;
    texCoord.y = texCoord.y / texInfo.scale.y;
    return make_float3(tex2D<float4>(tex, texCoord.x, texCoord.y));
}

inline __attribute__((device))
float sampleTexture(int32_t textureId, float2 texCoord, int8_t channel, float defaultVal) {
    auto &LP = optixLaunchParams;
    if (textureId < 0 || textureId >= (LP.textures.count + LP.materials.count * 19)) return defaultVal;
    if (LP.textureObjects.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 441); asm("trap;");} if (textureId >= LP.textureObjects.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 441, textureId, uint32_t(LP.textureObjects.count)); asm("trap;");} cudaTextureObject_t tex = ((cudaTextureObject_t*)LP.textureObjects.data)[textureId];;
    if (!tex) return defaultVal;
    if (LP.textures.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 443); asm("trap;");} if (textureId >= LP.textures.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 443, textureId, uint32_t(LP.textures.count)); asm("trap;");} TextureStruct texInfo = ((TextureStruct*)LP.textures.data)[textureId];;
    texCoord.x = texCoord.x / texInfo.scale.x;
    texCoord.y = texCoord.y / texInfo.scale.y;
    if (channel == 0) return tex2D<float4>(tex, texCoord.x, texCoord.y).x;
    if (channel == 1) return tex2D<float4>(tex, texCoord.x, texCoord.y).y;
    if (channel == 2) return tex2D<float4>(tex, texCoord.x, texCoord.y).z;
    if (channel == 3) return tex2D<float4>(tex, texCoord.x, texCoord.y).w;
    return defaultVal;
}

__attribute__((device))
void loadMeshTriIndices(int meshID, int numIndices, int primitiveID, int3 &triIndices)
{
    auto &LP = optixLaunchParams;
    if (LP.indexLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 457); asm("trap;");} if (meshID >= LP.indexLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 457, meshID, uint32_t(LP.indexLists.count)); asm("trap;");} Buffer<int3> indices = ((Buffer<int3>*)LP.indexLists.data)[meshID];;
    if (indices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 458); asm("trap;");} if (primitiveID >= indices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 458, primitiveID, uint32_t(indices.count)); asm("trap;");} triIndices = ((int3*)indices.data)[primitiveID];;
}

__attribute__((device))
void loadMeshVertexData(int meshID, int numVertices, int3 indices, float2 barycentrics, float3 &position, float3 &geometricNormal)
{
    auto &LP = optixLaunchParams;
    if (LP.vertexLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 465); asm("trap;");} if (meshID >= LP.vertexLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 465, meshID, uint32_t(LP.vertexLists.count)); asm("trap;");} Buffer<float3> vertices = ((Buffer<float3>*)LP.vertexLists.data)[meshID];;
    if (vertices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 466); asm("trap;");} if (indices.x >= vertices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 466, indices.x, uint32_t(vertices.count)); asm("trap;");} const float3 A = ((float3*)vertices.data)[indices.x];;
    if (vertices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 467); asm("trap;");} if (indices.y >= vertices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 467, indices.y, uint32_t(vertices.count)); asm("trap;");} const float3 B = ((float3*)vertices.data)[indices.y];;
    if (vertices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 468); asm("trap;");} if (indices.z >= vertices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 468, indices.z, uint32_t(vertices.count)); asm("trap;");} const float3 C = ((float3*)vertices.data)[indices.z];;
    position = A * (1.f - (barycentrics.x + barycentrics.y)) + B * barycentrics.x + C * barycentrics.y;
    geometricNormal = normalize(cross(B-A,C-A));
}

__attribute__((device))
void loadMeshUVData(int meshID, int numTexCoords, int3 indices, float2 barycentrics, float2 &uv)
{
    auto &LP = optixLaunchParams;
    if (LP.texCoordLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 477); asm("trap;");} if (meshID >= LP.texCoordLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 477, meshID, uint32_t(LP.texCoordLists.count)); asm("trap;");} Buffer<float2> texCoords = ((Buffer<float2>*)LP.texCoordLists.data)[meshID];;
    if (texCoords.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 478); asm("trap;");} if (indices.x >= texCoords.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 478, indices.x, uint32_t(texCoords.count)); asm("trap;");} const float2 A = ((float2*)texCoords.data)[indices.x];;
    if (texCoords.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 479); asm("trap;");} if (indices.y >= texCoords.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 479, indices.y, uint32_t(texCoords.count)); asm("trap;");} const float2 B = ((float2*)texCoords.data)[indices.y];;
    if (texCoords.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 480); asm("trap;");} if (indices.z >= texCoords.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 480, indices.z, uint32_t(texCoords.count)); asm("trap;");} const float2 C = ((float2*)texCoords.data)[indices.z];;
    uv = A * (1.f - (barycentrics.x + barycentrics.y)) + B * barycentrics.x + C * barycentrics.y;
}

__attribute__((device))
void loadMeshNormalData(int meshID, int numNormals, int3 indices, float2 barycentrics, float3 &normal)
{
    auto &LP = optixLaunchParams;
    if (LP.normalLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 488); asm("trap;");} if (meshID >= LP.normalLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 488, meshID, uint32_t(LP.normalLists.count)); asm("trap;");} Buffer<float4> normals = ((Buffer<float4>*)LP.normalLists.data)[meshID];;
    if (normals.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 489); asm("trap;");} if (indices.x >= normals.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 489, indices.x, uint32_t(normals.count)); asm("trap;");} const float4 A = ((float4*)normals.data)[indices.x];;
    if (normals.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 490); asm("trap;");} if (indices.y >= normals.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 490, indices.y, uint32_t(normals.count)); asm("trap;");} const float4 B = ((float4*)normals.data)[indices.y];;
    if (normals.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 491); asm("trap;");} if (indices.z >= normals.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 491, indices.z, uint32_t(normals.count)); asm("trap;");} const float4 C = ((float4*)normals.data)[indices.z];;
    normal = make_float3(A) * (1.f - (barycentrics.x + barycentrics.y)) + make_float3(B) * barycentrics.x + make_float3(C) * barycentrics.y;
}

__attribute__((device))
void loadMeshTangentData(int meshID, int numTangents, int3 indices, float2 barycentrics, float3 &tangent)
{
    auto &LP = optixLaunchParams;
    if (LP.tangentLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 499); asm("trap;");} if (meshID >= LP.tangentLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 499, meshID, uint32_t(LP.tangentLists.count)); asm("trap;");} Buffer<float4> tangents = ((Buffer<float4>*)LP.tangentLists.data)[meshID];;
    if (tangents.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 500); asm("trap;");} if (indices.x >= tangents.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 500, indices.x, uint32_t(tangents.count)); asm("trap;");} const float4 A = ((float4*)tangents.data)[indices.x];;
    if (tangents.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 501); asm("trap;");} if (indices.y >= tangents.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 501, indices.y, uint32_t(tangents.count)); asm("trap;");} const float4 B = ((float4*)tangents.data)[indices.y];;
    if (tangents.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 502); asm("trap;");} if (indices.z >= tangents.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 502, indices.z, uint32_t(tangents.count)); asm("trap;");} const float4 C = ((float4*)tangents.data)[indices.z];;
    tangent = make_float3(A) * (1.f - (barycentrics.x + barycentrics.y)) + make_float3(B) * barycentrics.x + make_float3(C) * barycentrics.y;
}

__attribute__((device))
void loadDisneyMaterial(const MaterialStruct &p, float2 uv, DisneyMaterial &mat, float roughnessMinimum) {
    mat.base_color = sampleTexture(p.base_color_texture_id, uv, make_float3(.8f, .8f, .8f));
    mat.metallic = sampleTexture(p.metallic_texture_id, uv, p.metallic_texture_channel, .0f);
    mat.specular = sampleTexture(p.specular_texture_id, uv, p.specular_texture_channel, .5f);
    mat.roughness = sampleTexture(p.roughness_texture_id, uv, p.roughness_texture_channel, .5f);
    mat.specular_tint = sampleTexture(p.specular_tint_texture_id, uv, p.specular_tint_texture_channel, 0.f);
    mat.anisotropy = sampleTexture(p.anisotropic_texture_id, uv, p.anisotropic_texture_channel, 0.f);
    mat.sheen = sampleTexture(p.sheen_texture_id, uv, p.sheen_texture_channel, 0.f);
    mat.sheen_tint = sampleTexture(p.sheen_tint_texture_id, uv, p.sheen_tint_texture_channel, 0.5f);
    mat.clearcoat = sampleTexture(p.clearcoat_texture_id, uv, p.clearcoat_texture_channel, 0.f);
    float clearcoat_roughness = sampleTexture(p.clearcoat_roughness_texture_id, uv, p.clearcoat_roughness_texture_channel, 0.3f);
    mat.ior = sampleTexture(p.ior_texture_id, uv, p.ior_texture_channel, 1.45f);
    mat.specular_transmission = sampleTexture(p.transmission_texture_id, uv, p.transmission_texture_channel, 0.f);
    mat.flatness = sampleTexture(p.subsurface_texture_id, uv, p.subsurface_texture_channel, 0.f);
    mat.subsurface_color = sampleTexture(p.subsurface_color_texture_id, uv, make_float3(0.8f, 0.8f, 0.8f));
    mat.transmission_roughness = sampleTexture(p.transmission_roughness_texture_id, uv, p.transmission_roughness_texture_channel, 0.f);
    mat.alpha = sampleTexture(p.alpha_texture_id, uv, p.alpha_texture_channel, 1.f);

    mat.transmission_roughness = max(max(mat.transmission_roughness, .04f), roughnessMinimum);
    mat.roughness = max(max(mat.roughness, .04f), roughnessMinimum);
    clearcoat_roughness = max(clearcoat_roughness, roughnessMinimum);
    mat.clearcoat_gloss = 1.0 - clearcoat_roughness * clearcoat_roughness;
}

__attribute__((device))
float sampleTime(float xi) {
    auto &LP = optixLaunchParams;
    return LP.timeSamplingInterval[0] +
           (LP.timeSamplingInterval[1] -
            LP.timeSamplingInterval[0]) * xi;
}

inline __attribute__((device))
owl::Ray generateRay(const CameraStruct &camera, const TransformStruct &transform, int2 pixelID, float2 frameSize, LCGRand &rng, float time)
{
    auto &LP = optixLaunchParams;

    glm::quat r0 = glm::quat_cast(LP.viewT0);
    glm::quat r1 = glm::quat_cast(LP.viewT1);
    glm::vec4 p0 = glm::column(LP.viewT0, 3);
    glm::vec4 p1 = glm::column(LP.viewT1, 3);

    glm::vec4 pos = glm::mix(p0, p1, time);
    glm::quat rot = (glm::all(glm::equal(r0, r1))) ? r0 : glm::slerp(r0, r1, time);
    glm::mat4 camLocalToWorld = glm::mat4_cast(rot);
    camLocalToWorld = glm::column(camLocalToWorld, 3, pos);

    mat4 projinv = glm::inverse(LP.proj);
    mat4 viewinv = glm::inverse(camLocalToWorld);
    vec2 aa = vec2(LP.xPixelSamplingInterval[0], LP.yPixelSamplingInterval[0])
            + (vec2(LP.xPixelSamplingInterval[1], LP.yPixelSamplingInterval[1])
            - vec2(LP.xPixelSamplingInterval[0], LP.yPixelSamplingInterval[0])
            ) * vec2(lcg_randomf(rng),lcg_randomf(rng));

    vec2 inUV = (vec2(pixelID.x, pixelID.y) + aa) / make_vec2(frameSize);
    vec3 right = normalize(glm::column(viewinv, 0));
    vec3 up = normalize(glm::column(viewinv, 1));
    vec3 origin = glm::column(viewinv, 3);

    float cameraLensRadius = camera.apertureDiameter;

    vec3 p(0.f);
    if (cameraLensRadius > 0.0) {
        do {
            p = 2.0f*vec3(lcg_randomf(rng),lcg_randomf(rng),0.f) - vec3(1.f,1.f,0.f);
        } while (dot(p,p) >= 1.0f);
    }

    vec3 rd = cameraLensRadius * p;
    vec3 lens_offset = (right * rd.x) / float(frameSize.x) + (up * rd.y) / float(frameSize.y);

    origin = origin + lens_offset;
    vec2 dir = inUV * 2.f - 1.f; dir.y *= -1.f;
    vec4 t = (projinv * vec4(dir.x, dir.y, -1.f, 1.f));
    vec3 target = vec3(t) / float(t.w);
    vec3 direction = normalize(vec3(viewinv * vec4(target, 0.f))) * camera.focalDistance;
    direction = normalize(direction - lens_offset);

    owl::Ray ray;
    ray.tmin = .001f;
    ray.tmax = 1e20f;
    ray.origin = make_float3(origin) ;
    ray.direction = make_float3(direction);

    return ray;
}

__attribute__((device))
void initializeRenderData(float3 &renderData)
{
    auto &LP = optixLaunchParams;

    if (LP.renderDataMode == RenderDataFlags::NONE) {
        renderData = make_float3(0.0f);
    }
    else if (LP.renderDataMode == RenderDataFlags::DEPTH) {
        renderData = make_float3(-3.40282346638528859811704183484516925e+38F);
    }
    else if (LP.renderDataMode == RenderDataFlags::POSITION) {
        renderData = make_float3(-3.40282346638528859811704183484516925e+38F);
    }
    else if (LP.renderDataMode == RenderDataFlags::NORMAL) {
        renderData = make_float3(0.0f);
    }
    else if (LP.renderDataMode == RenderDataFlags::TANGENT) {
        renderData = make_float3(0.0f);
    }
    else if (LP.renderDataMode == RenderDataFlags::SCREEN_SPACE_NORMAL) {
        renderData = make_float3(0.0f);
    }
    else if (LP.renderDataMode == RenderDataFlags::ENTITY_ID) {
        renderData = make_float3(3.40282346638528859811704183484516925e+38F);
    }
    else if (LP.renderDataMode == RenderDataFlags::BASE_COLOR) {
        renderData = make_float3(0.0, 0.0, 0.0);
    }
    else if (LP.renderDataMode == RenderDataFlags::TEXTURE_COORDINATES) {
        renderData = make_float3(0.0, 0.0, 0.0);
    }
    else if (LP.renderDataMode == RenderDataFlags::DIFFUSE_MOTION_VECTORS) {
        renderData = make_float3(0.0, 0.0, -1.0);
    }
    else if (LP.renderDataMode == RenderDataFlags::HEATMAP) {
        renderData = make_float3(0.0, 0.0, 0.0);
    }
}

__attribute__((device))
void saveLightingColorRenderData (
    float3 &renderData, int bounce,
    float3 w_n, float3 w_o, float3 w_i,
    DisneyMaterial &mat
)
{
    auto &LP = optixLaunchParams;
    if (LP.renderDataMode == RenderDataFlags::NONE) return;
    if (bounce != LP.renderDataBounce) return;



    if (LP.renderDataMode == RenderDataFlags::DIFFUSE_COLOR) {
        renderData = disney_diffuse_color(mat, w_n, w_o, w_i, normalize(w_o + w_i));
    }
    else if (LP.renderDataMode == RenderDataFlags::GLOSSY_COLOR) {
        renderData = disney_microfacet_reflection_color(mat, w_n, w_o, w_i, normalize(w_o + w_i));
    }
    else if (LP.renderDataMode == RenderDataFlags::TRANSMISSION_COLOR) {
        renderData = disney_microfacet_transmission_color(mat, w_n, w_o, w_i, normalize(w_o + w_i));
    }
}

__attribute__((device))
void saveLightingIrradianceRenderData(
    float3 &renderData, int bounce,
    float3 dillum, float3 iillum,
    int sampledBsdf)
{
    auto &LP = optixLaunchParams;
    if (LP.renderDataMode == RenderDataFlags::NONE) return;
    if (bounce != LP.renderDataBounce) return;



    if (LP.renderDataMode == RenderDataFlags::DIFFUSE_DIRECT_LIGHTING) {
        renderData = dillum;
    }
    else if (LP.renderDataMode == RenderDataFlags::DIFFUSE_INDIRECT_LIGHTING) {
        renderData = iillum;
    }
    else if (LP.renderDataMode == RenderDataFlags::GLOSSY_DIRECT_LIGHTING) {
        renderData = dillum;
    }
    else if (LP.renderDataMode == RenderDataFlags::GLOSSY_INDIRECT_LIGHTING) {
        renderData = iillum;
    }
    else if (LP.renderDataMode == RenderDataFlags::TRANSMISSION_DIRECT_LIGHTING) {
        renderData = dillum;
    }
    else if (LP.renderDataMode == RenderDataFlags::TRANSMISSION_INDIRECT_LIGHTING) {
        renderData = iillum;
    }
}

__attribute__((device))
void saveMissRenderData(
    float3 &renderData,
    int bounce,
    float3 mvec)
{
    auto &LP = optixLaunchParams;
    if (LP.renderDataMode == RenderDataFlags::NONE) return;
    if (bounce != LP.renderDataBounce) return;

    if (LP.renderDataMode == RenderDataFlags::DIFFUSE_MOTION_VECTORS) {
        renderData = mvec;
    }
}


__attribute__((device))
void saveGeometricRenderData(
    float3 &renderData,
    int bounce, float depth,
    float3 w_p, float3 w_n, float3 w_x, float3 w_o, float2 uv,
    int entity_id, float3 diffuse_mvec, float time,
    DisneyMaterial &mat)
{
    auto &LP = optixLaunchParams;
    if (LP.renderDataMode == RenderDataFlags::NONE) return;
    if (bounce != LP.renderDataBounce) return;

    if (LP.renderDataMode == RenderDataFlags::DEPTH) {
        renderData = make_float3(depth);
    }
    else if (LP.renderDataMode == RenderDataFlags::POSITION) {
        renderData = w_p;
    }
    else if (LP.renderDataMode == RenderDataFlags::NORMAL) {
        renderData = w_n;
    }
    else if (LP.renderDataMode == RenderDataFlags::TANGENT) {
        renderData = w_x;
    }
    else if (LP.renderDataMode == RenderDataFlags::SCREEN_SPACE_NORMAL) {
        glm::quat r0 = glm::quat_cast(LP.viewT0);
        glm::quat r1 = glm::quat_cast(LP.viewT1);
        glm::quat rot = (glm::all(glm::equal(r0, r1))) ? r0 : glm::slerp(r0, r1, time);
        vec3 tmp = normalize(glm::mat3_cast(rot) * make_vec3(w_n));
        tmp = normalize(vec3(LP.proj * vec4(tmp, 0.f)));
        renderData.x = tmp.x;
        renderData.y = tmp.y;
        renderData.z = tmp.z;
    }
    else if (LP.renderDataMode == RenderDataFlags::ENTITY_ID) {
        renderData = make_float3(float(entity_id));
    }
    else if (LP.renderDataMode == RenderDataFlags::DIFFUSE_MOTION_VECTORS) {
        renderData = diffuse_mvec;
    }
    else if (LP.renderDataMode == RenderDataFlags::BASE_COLOR) {
        renderData = mat.base_color;
    }
    else if (LP.renderDataMode == RenderDataFlags::TEXTURE_COORDINATES) {
        renderData = make_float3(uv.x, uv.y, 0.0);
    }
    else if (LP.renderDataMode == RenderDataFlags::RAY_DIRECTION) {
        renderData = -w_o;
    }
}

__attribute__((device))
void saveHeatmapRenderData(
    float3 &renderData,
    int bounce,
    uint64_t start_clock
)
{
    auto &LP = optixLaunchParams;
    if (LP.renderDataMode != RenderDataFlags::HEATMAP) return;


    uint64_t absClock = clock()-start_clock;
    float relClock = absClock / 10000000.f;
    relClock = min(relClock, 1.f);
    renderData = make_float3(relClock);
}

__attribute__((device))
void saveDeviceAssignment(
    float3 &renderData,
    int bounce,
    uint32_t deviceIndex
)
{
    auto &LP = optixLaunchParams;
    if (LP.renderDataMode != RenderDataFlags::DEVICE_ID) return;
    renderData = make_float3(deviceIndex);
}

__attribute__((device))
bool debugging() {

    return false;

    auto &LP = optixLaunchParams;
    auto pixelID = ivec2(owl::getLaunchIndex()[0], owl::getLaunchIndex()[1]);
    return glm::all(glm::equal(pixelID, ivec2(LP.frameSize.x / 2, LP.frameSize.y / 2)));
}

extern "C" __attribute__((global)) void __raygen__rayGen()
{
    const RayGenData &self = owl::getProgramData<RayGenData>();
    auto &LP = optixLaunchParams;
    auto launchIndex = optixGetLaunchIndex().x;
    auto launchDim = optixGetLaunchDimensions().x;
    auto pixelID = make_int2(launchIndex % LP.frameSize.x, launchIndex / LP.frameSize.x);


    if (LP.assignmentBuffer.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 805); asm("trap;");} if (self.deviceIndex >= LP.assignmentBuffer.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 805, self.deviceIndex, uint32_t(LP.assignmentBuffer.count)); asm("trap;");} float start = ((float*)LP.assignmentBuffer.data)[self.deviceIndex];;
    if (LP.assignmentBuffer.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 806); asm("trap;");} if (self.deviceIndex + 1 >= LP.assignmentBuffer.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 806, self.deviceIndex + 1, uint32_t(LP.assignmentBuffer.count)); asm("trap;");} float stop = ((float*)LP.assignmentBuffer.data)[self.deviceIndex + 1];;
    start *= (LP.frameSize.x * LP.frameSize.y);
    stop *= (LP.frameSize.x * LP.frameSize.y);





    if( pixelID.x > LP.frameSize.x-1 || pixelID.y > LP.frameSize.y-1 ) return;
    if( (launchIndex < start) || (stop <= launchIndex) ) return;


    cudaTextureObject_t envTex = getEnvironmentTexture();
    bool debug = (pixelID.x == int(LP.frameSize.x / 2) && pixelID.y == int(LP.frameSize.y / 2));
    float tmax = 1e20f;

    auto dims = ivec2(LP.frameSize.x, LP.frameSize.x);
    uint64_t start_clock = clock();
    int numLights = LP.numLightEntities;
    int numLightSamples = LP.numLightSamples;
    bool enableDomeSampling = LP.enableDomeSampling;

    LCGRand rng = get_rng(LP.frameID + LP.seed * 10007, make_uint2(pixelID.x, pixelID.y), make_uint2(dims.x, dims.y));
    float time = sampleTime(lcg_randomf(rng));


    owl::Ray ray;
    EntityStruct camera_entity;
    TransformStruct camera_transform;
    CameraStruct camera;
    if (!loadCamera(camera_entity, camera, camera_transform)) {
        auto fbOfs = pixelID.x+LP.frameSize.x * ((LP.frameSize.y - 1) - pixelID.y);
        LP.frameBuffer[fbOfs] = vec4(lcg_randomf(rng), lcg_randomf(rng), lcg_randomf(rng), 1.f);
        return;
    }


    ray = generateRay(camera, camera_transform, pixelID, make_float2(LP.frameSize), rng, time);
    ray.tmax = tmax;

    float3 accum_illum = make_float3(0.f);
    float3 pathThroughput = make_float3(1.f);
    float3 renderData = make_float3(0.f);
    float3 primaryAlbedo = make_float3(0.f);
    float3 primaryNormal = make_float3(0.f);
    initializeRenderData(renderData);

    uint8_t depth = 0;
    uint8_t diffuseDepth = 0;
    uint8_t glossyDepth = 0;
    uint8_t transparencyDepth = 0;
    uint8_t transmissionDepth = 0;
    uint8_t volumeDepth = 0;
    int sampledBsdf = -1;
    bool useBRDF = true;


    float3 directIllum = make_float3(0.f);
    float3 illum = make_float3(0.f);

    RayPayload payload;
    payload.tHit = -1.f;
    ray.time = time;
    ray.visibilityMask = (1<<0);
    owl::traceRay( LP.IAS,
                                         ray,
                            payload,
                    OPTIX_RAY_FLAG_DISABLE_ANYHIT);


    do {
        float alpha = 0.f;
 printRayInfo(LP, pixelID, ray, payload, "Loop Ray");

        if (payload.tHit <= 0.f) {

            if (depth == 0) {
                float3 col = missColor(ray, envTex);
                illum = illum + pathThroughput * (col * LP.domeLightIntensity);
                directIllum = illum;
                primaryAlbedo = col;
            }
            else if (enableDomeSampling)
                illum = illum + pathThroughput * (missColor(ray, envTex) * LP.domeLightIntensity * pow(2.f, LP.domeLightExposure));

            const float envDist = 10000.0f;

            float3 mvec;

            float3 pFar = ray.origin + ray.direction * envDist;

            vec4 tmp1 = LP.proj * LP.viewT0 * make_vec4(pFar, 1.0f);
            float3 pt0 = make_float3(tmp1 / tmp1.w) * .5f;
            vec4 tmp2 = LP.proj * LP.viewT1 * make_vec4(pFar, 1.0f);
            float3 pt1 = make_float3(tmp2 / tmp2.w) * .5f;
            mvec = pt1 - pt0;
            saveMissRenderData(renderData, depth, mvec);
            break;
        }



        if (LP.instanceToEntity.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 908); asm("trap;");} if (payload.instanceID >= LP.instanceToEntity.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 908, payload.instanceID, uint32_t(LP.instanceToEntity.count)); asm("trap;");} int entityID = ((int*)LP.instanceToEntity.data)[payload.instanceID];;
        if (LP.entities.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 909); asm("trap;");} if (entityID >= LP.entities.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 909, entityID, uint32_t(LP.entities.count)); asm("trap;");} EntityStruct entity = ((EntityStruct*)LP.entities.data)[entityID];;
        if (LP.transforms.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 910); asm("trap;");} if (entity.transform_id >= LP.transforms.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 910, entity.transform_id, uint32_t(LP.transforms.count)); asm("trap;");} TransformStruct transform = ((TransformStruct*)LP.transforms.data)[entity.transform_id];;

        bool isVolume = (entity.volume_id != -1);
        MeshStruct mesh;
        VolumeStruct volume;
        if (!isVolume) { if (LP.meshes.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 915); asm("trap;");} if (entity.mesh_id >= LP.meshes.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 915, entity.mesh_id, uint32_t(LP.meshes.count)); asm("trap;");} mesh = ((MeshStruct*)LP.meshes.data)[entity.mesh_id];; }
        else { if (LP.volumes.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 916); asm("trap;");} if (entity.volume_id >= LP.volumes.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 916, entity.volume_id, uint32_t(LP.volumes.count)); asm("trap;");} volume = ((VolumeStruct*)LP.volumes.data)[entity.volume_id];; }


        const float3 w_o = -ray.direction;
        float3 hit_p = ray.origin + payload.tHit * ray.direction; printRayInfo(LP, pixelID, ray, payload,"HitPoint", hit_p);


        float3 mp, p, v_x, v_y, v_z, v_gz, v_bz;
        float2 uv;
        float3 diffuseMotion;
        if (isVolume) {
            v_x = v_y = make_float3(0.f);
            v_z = v_gz = normalize(payload.gradient);
            if (any(isnan(make_vec3(v_z)))) v_z = v_gz = make_float3(0.f);
            mp = payload.mp;
            uv = make_float2(payload.density, length(payload.gradient));
        }
        else {
            int3 indices;
            loadMeshTriIndices(entity.mesh_id, mesh.numTris, payload.primitiveID, indices);
            loadMeshVertexData(entity.mesh_id, mesh.numVerts, indices, payload.barycentrics, mp, v_gz);
            loadMeshUVData(entity.mesh_id, mesh.numVerts, indices, payload.barycentrics, uv);
            loadMeshNormalData(entity.mesh_id, mesh.numVerts, indices, payload.barycentrics, v_z);
            loadMeshTangentData(entity.mesh_id, mesh.numVerts, indices, payload.barycentrics, v_x);
        }


        DisneyMaterial mat; MaterialStruct entityMaterial;
        if (entity.material_id >= 0 && entity.material_id < LP.materials.count) {
            if (LP.materials.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 945); asm("trap;");} if (entity.material_id >= LP.materials.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 945, entity.material_id, uint32_t(LP.materials.count)); asm("trap;");} entityMaterial = ((MaterialStruct*)LP.materials.data)[entity.material_id];;
            loadDisneyMaterial(entityMaterial, uv, mat, .04f);
        }


        {
            glm::mat4 xfm = to_mat4(payload.localToWorld);
            p = make_float3(xfm * make_vec4(mp, 1.0f));
            hit_p = p;
            glm::mat3 nxfm = transpose(glm::inverse(glm::mat3(xfm)));
            v_gz = make_float3(normalize(nxfm * make_vec3(v_gz)));
            v_z = make_float3(normalize(nxfm * make_vec3(v_z)));
            v_x = make_float3(normalize(nxfm * make_vec3(v_x)));
            v_y = cross(v_z, v_x);


            if (LP.renderDataMode != RenderDataFlags::NONE) {
                glm::mat4 xfmt0 = to_mat4(payload.localToWorldT0);
                glm::mat4 xfmt1 = to_mat4(payload.localToWorldT1);
                vec4 tmp1 = LP.proj * LP.viewT0 * xfmt0 * make_vec4(mp, 1.0f);
                vec4 tmp2 = LP.proj * LP.viewT1 * xfmt1 * make_vec4(mp, 1.0f);
                float3 pt0 = make_float3(tmp1 / tmp1.w) * .5f;
                float3 pt1 = make_float3(tmp2 / tmp2.w) * .5f;
                diffuseMotion = pt1 - pt0;
            } else {
                diffuseMotion = make_float3(0.f, 0.f, 0.f);
            }
        }


        if (
            all(lessThan(abs(make_vec3(v_x)), vec3(0.0001f))) ||
            all(lessThan(abs(make_vec3(v_y)), vec3(0.0001f))) ||
            any(isnan(make_vec3(v_x))) ||
            any(isnan(make_vec3(v_y)))
        ) {
            ortho_basis(v_x, v_y, v_z);
        }


        {
            glm::mat3 tbn;
            tbn = glm::column(tbn, 0, make_vec3(v_x) );
            tbn = glm::column(tbn, 1, make_vec3(v_y) );
            tbn = glm::column(tbn, 2, make_vec3(v_z) );
            float3 dN;
            if (entity.light_id >= 0 && entity.light_id < LP.lights.count) {
                dN = make_float3(0.5f, .5f, 1.f);
            } else {
                dN = sampleTexture(entityMaterial.normal_map_texture_id, uv, make_float3(0.5f, .5f, 0.f));
                if (LP.textures.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 995); asm("trap;");} if (entityMaterial.normal_map_texture_id >= LP.textures.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 995, entityMaterial.normal_map_texture_id, uint32_t(LP.textures.count)); asm("trap;");} TextureStruct tex = ((TextureStruct*)LP.textures.data)[entityMaterial.normal_map_texture_id];;




            }

            dN = normalize( (dN * make_float3(2.0f)) - make_float3(1.f) );
            v_z = make_float3(tbn * make_vec3(dN));


            if (dot(v_z, v_gz) < 0.f) {
                v_z = -v_z;
            }

            v_bz = v_z;
        }







        if ((mat.specular_transmission == 0.f) && (entity.light_id == -1)) {
            if (dot(w_o, v_gz) < 0.f) {
                v_z = -v_z;
                v_gz = -v_gz;
            }


            float3 r = reflect(-w_o, v_z);
            float a = dot(v_gz, r);
            v_bz = v_z;
            if (a < 0.f) {
                float b = max(0.001f, dot(v_z, v_gz));
                v_bz = normalize(w_o + normalize(r - v_z * a / b));
            }
        }

        if (any(isnan(make_vec3(v_z)))) {


            v_z = v_x = v_y = make_float3(0.f);
        }


        saveGeometricRenderData(renderData, depth, payload.tHit, hit_p, v_z, v_x, w_o, uv, entityID, diffuseMotion, time, mat);
        if (depth == 0) {
            primaryAlbedo = mat.base_color;
            primaryNormal = v_z;
        }


        if ((entity.light_id == -1) && (mat.alpha < 1.f)) {
            float alpha_rnd = lcg_randomf(rng);

            if (alpha_rnd > mat.alpha) {
                ray.origin = ray.origin + ray.direction * (payload.tHit + 0.0001f);
                payload.tHit = -1.f;
                ray.time = time;

                owl::traceRay( LP.IAS, ray, payload, OPTIX_RAY_FLAG_DISABLE_ANYHIT);
                ++depth;
                transparencyDepth++;printRayInfo(LP, pixelID, ray, payload, "Transparent");
                continue;
            }
        }




        if (entity.light_id >= 0 && entity.light_id < LP.lights.count) {
            float dotNWi = max(dot(ray.direction, v_z), 0.f);
            if ((dotNWi > 0.0001f) && (depth != 0)) break;
            if (LP.lights.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1070); asm("trap;");} if (entity.light_id >= LP.lights.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1070, entity.light_id, uint32_t(LP.lights.count)); asm("trap;");} LightStruct entityLight = ((LightStruct*)LP.lights.data)[entity.light_id];;
            float3 lightEmission;
            if (entityLight.color_texture_id == -1) lightEmission = make_float3(entityLight.r, entityLight.g, entityLight.b);
            else lightEmission = sampleTexture(entityLight.color_texture_id, uv, make_float3(0.f, 0.f, 0.f));
            float dist = payload.tHit;
            lightEmission = (lightEmission * entityLight.intensity);
            if (depth != 0) lightEmission = (lightEmission * pow(2.f, entityLight.exposure)) / max((dist * dist), 1.f);
            float3 contribution = pathThroughput * lightEmission;
            illum = illum + contribution;
            if (depth == 0) directIllum = illum;
            break;
        }


        int32_t sampledLightID = -2;
        float lightPDF = 0.f;
        float3 irradiance = make_float3(0.f);


        if (isVolume) {
            float opacity = mat.alpha;
            float grad_len = uv.y;
            float p_brdf = opacity * (1.f - exp(-25.f * pow(volume.gradient_factor, 3.f) * grad_len)); p_brdf=0.0f;
            float pdf;
            float rand_brdf = lcg_randomf(rng);

            if (rand_brdf < p_brdf) {
                useBRDF = true;
            } else {
                useBRDF = false;
            }
        }


        float3 w_i;
        float bsdfPDF;
        float3 bsdf;
        if (useBRDF) {
            sample_disney_brdf(
                mat, rng, v_gz, v_z, v_bz, v_x, v_y, w_o,
                w_i, bsdfPDF, sampledBsdf, bsdf); printRayInfo(LP, pixelID, ray, payload,"Disney wi",w_i);
        } else {

            if (payload.eventID == 2) {

                float rand1 = lcg_randomf(rng);
                float rand2 = lcg_randomf(rng);
                float rand3 = lcg_randomf(rng);
# 1131 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
  float apg = payload.g_asy_parameter;
  float cos_alpha = 2.0f * rand1 - 1.0f;
  float cos_beta = 2.0f * rand2 - 1.0f;
  float cos_gamma = 2.0f * rand3 - 1.0f;
  if (apg != 0.00) {
   cos_alpha = (1.0f/(2.0f*apg))*(1.0f+apg*apg-( (1.0f-apg*apg) / (1.0f-apg+2.0f*apg*rand1) )*( (1.0f-apg*apg) / (1.0f-apg+2.0f*apg*rand1) ));
   cos_beta = (1.0f/(2.0f*apg))*(1.0f+apg*apg-( (1.0f-apg*apg) / (1.0f-apg+2.0f*apg*rand2) )*( (1.0f-apg*apg) / (1.0f-apg+2.0f*apg*rand2) ));
   cos_gamma = (1.0f/(2.0f*apg))*(1.0f+apg*apg-( (1.0f-apg*apg) / (1.0f-apg+2.0f*apg*rand3) )*( (1.0f-apg*apg) / (1.0f-apg+2.0f*apg*rand3) ));}
  float3 cos_HG = make_float3( cos_alpha, cos_beta, cos_gamma);
  float cos_theta_wo_wi = 0.0f;
  w_i = DeviatedVector(w_o, cos_HG, &cos_theta_wo_wi);
  printRayInfo(LP, pixelID, ray, payload, "wo", w_o);
  printRayInfo(LP, pixelID, ray, payload, "cos_alpa_beta_gamma", cos_HG);
  printRayInfo(LP, pixelID, ray, payload, "wi", w_i);
  printRayInfo(LP, pixelID, ray, payload, "cos_thet_wo_wi", cos_theta_wo_wi);
  printRayInfo(LP, pixelID, ray, payload, "g_parameter", apg);
                float cos_phi = cos_theta_wo_wi;
  bsdfPDF = (1.0f-apg*apg) / ( (4.0 * 
# 1148 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                     3.14159265358979323846
# 1148 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                         )*(1+apg*apg-2.0f*apg*cos_phi)*sqrt(1+apg*apg-2.0f*apg*cos_phi) );
                bsdf = make_float3( bsdfPDF );
                printRayInfo(LP, pixelID, ray, payload,"HenyeyGreensteinAngle",w_i);
            }


            if (payload.eventID == 1) {
                bsdfPDF = (1.0f) / (4.0 * 
# 1155 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                         3.14159265358979323846
# 1155 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                             );
                bsdf = make_float3( 1.0f / (4.0 * 
# 1156 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                                 3.14159265358979323846
# 1156 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                                     ) );
                w_i = -w_o;
            }


            bsdf = bsdf * mat.base_color;
        }



        if (sampledBsdf == 3 && transmissionDepth >= LP.maxTransmissionDepth) {
            ray.origin = ray.origin + ray.direction * (payload.tHit + 0.0001f); printRayInfo(LP, pixelID, ray, payload, "Bounces");
            payload.tHit = -1.f;
            ray.time = time;

            owl::traceRay( LP.IAS, ray, payload, OPTIX_RAY_FLAG_DISABLE_ANYHIT);
            printRayInfo(LP, pixelID, ray, payload, "After Bounces");

            ++depth;
            transparencyDepth++;
            continue;
        }


        const uint32_t occlusion_flags = OPTIX_RAY_FLAG_DISABLE_ANYHIT | OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT;

        uint32_t randmax = (enableDomeSampling) ? numLights + 1 : numLights;
        uint32_t randomID = uint32_t(min(lcg_randomf(rng) * randmax, float(randmax-1)));
        float dotNWi = 0.f;
        float3 l_bsdf = make_float3(0.f);
        float3 lightEmission = make_float3(0.f);
        float3 lightDir = make_float3(0.f);
        float lightDistance = 1e20f;
        float falloff = 2.0f;
        int numTris = 0;


        if (randomID == numLights) {
            sampledLightID = -1;
            if (
                (LP.environmentMapWidth != 0) && (LP.environmentMapHeight != 0) &&
                (LP.environmentMapRows != nullptr) && (LP.environmentMapCols != nullptr)
            )
            {



                float rx = lcg_randomf(rng);
                float ry = lcg_randomf(rng);
                float* rows = LP.environmentMapRows;
                float* cols = LP.environmentMapCols;
                int width = LP.environmentMapWidth;
                int height = LP.environmentMapHeight;
                float invjacobian = width * height / float(4 * 
# 1209 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                                              3.14159265358979323846
# 1209 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                                                  );
                float row_pdf, col_pdf;
                unsigned x, y;
                ry = sample_cdf(rows, height, ry, &y, &row_pdf);
                y = max(min(y, height - 1), 0);
                rx = sample_cdf(cols + y * width, width, rx, &x, &col_pdf);
                lightDir = make_float3(toPolar(vec2((x ) / float(width), (y )/float(height))));
                lightDir = glm::inverse(LP.environmentMapRotation) * lightDir;
                lightPDF = row_pdf * col_pdf * invjacobian;
            }
            else
            {
                glm::mat3 tbn;
                tbn = glm::column(tbn, 0, make_vec3(v_x) );
                tbn = glm::column(tbn, 1, make_vec3(v_y) );
                tbn = glm::column(tbn, 2, make_vec3(v_z) );
                const float3 hemi_dir = (cos_sample_hemisphere(make_float2(lcg_randomf(rng), lcg_randomf(rng))));
                lightDir = make_float3(tbn * make_vec3(hemi_dir));
                lightPDF = 1.f / float(2.0 * 
# 1227 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                            3.14159265358979323846
# 1227 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                                );
            }

            numTris = 1.f;
            lightEmission = (missColor(lightDir, envTex) * LP.domeLightIntensity * pow(2.f, LP.domeLightExposure));
        }

        else
        {

            if (numLights == 0) continue;
            if (LP.lightEntities.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1238); asm("trap;");} if (randomID >= LP.lightEntities.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1238, randomID, uint32_t(LP.lightEntities.count)); asm("trap;");} sampledLightID = ((int*)LP.lightEntities.data)[randomID];;
            if (LP.entities.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1239); asm("trap;");} if (sampledLightID >= LP.entities.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1239, sampledLightID, uint32_t(LP.entities.count)); asm("trap;");} EntityStruct light_entity = ((EntityStruct*)LP.entities.data)[sampledLightID];;
            if (LP.lights.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1240); asm("trap;");} if (light_entity.light_id >= LP.lights.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1240, light_entity.light_id, uint32_t(LP.lights.count)); asm("trap;");} LightStruct light_light = ((LightStruct*)LP.lights.data)[light_entity.light_id];;
            if (LP.transforms.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1241); asm("trap;");} if (light_entity.transform_id >= LP.transforms.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1241, light_entity.transform_id, uint32_t(LP.transforms.count)); asm("trap;");} TransformStruct transform = ((TransformStruct*)LP.transforms.data)[light_entity.transform_id];;

            auto &ltw = transform.localToWorld;
            float3 dir; float2 uv;
            float3 pos = hit_p;


            if ((light_entity.mesh_id < 0) || (light_entity.mesh_id >= LP.meshes.count)) {
                numTris = 1.f;
                float3 tmp = make_float3(ltw[3]) - pos;
                lightDistance = length(tmp);
                dir = tmp / lightDistance;
                lightPDF = PdfAtoW(1.f/(4.f * 
# 1253 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                             3.14159265358979323846
# 1253 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                                 ), lightDistance * lightDistance, 1.f);
                uv = make_float2(0.f, 0.f);
            }

            else {
                if (LP.meshes.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1258); asm("trap;");} if (light_entity.mesh_id >= LP.meshes.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1258, light_entity.mesh_id, uint32_t(LP.meshes.count)); asm("trap;");} MeshStruct mesh = ((MeshStruct*)LP.meshes.data)[light_entity.mesh_id];;
                uint32_t random_tri_id = uint32_t(min(lcg_randomf(rng) * mesh.numTris, float(mesh.numTris - 1)));
                if (LP.indexLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1260); asm("trap;");} if (light_entity.mesh_id >= LP.indexLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1260, light_entity.mesh_id, uint32_t(LP.indexLists.count)); asm("trap;");} Buffer<int3> indices = ((Buffer<int3>*)LP.indexLists.data)[light_entity.mesh_id];;
                if (LP.vertexLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1261); asm("trap;");} if (light_entity.mesh_id >= LP.vertexLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1261, light_entity.mesh_id, uint32_t(LP.vertexLists.count)); asm("trap;");} Buffer<float3> vertices = ((Buffer<float3>*)LP.vertexLists.data)[light_entity.mesh_id];;
                if (LP.normalLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1262); asm("trap;");} if (light_entity.mesh_id >= LP.normalLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1262, light_entity.mesh_id, uint32_t(LP.normalLists.count)); asm("trap;");} Buffer<float4> normals = ((Buffer<float4>*)LP.normalLists.data)[light_entity.mesh_id];;
                if (LP.texCoordLists.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1263); asm("trap;");} if (light_entity.mesh_id >= LP.texCoordLists.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1263, light_entity.mesh_id, uint32_t(LP.texCoordLists.count)); asm("trap;");} Buffer<float2> texCoords = ((Buffer<float2>*)LP.texCoordLists.data)[light_entity.mesh_id];;
                if (indices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1264); asm("trap;");} if (random_tri_id >= indices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1264, random_tri_id, uint32_t(indices.count)); asm("trap;");} int3 triIndex = ((int3*)indices.data)[random_tri_id];;
                if (normals.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1265); asm("trap;");} if (triIndex.x >= normals.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1265, triIndex.x, uint32_t(normals.count)); asm("trap;");} float3 n1 = ((float3*)normals.data)[triIndex.x];;
                if (normals.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1266); asm("trap;");} if (triIndex.y >= normals.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1266, triIndex.y, uint32_t(normals.count)); asm("trap;");} float3 n2 = ((float3*)normals.data)[triIndex.y];;
                if (normals.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1267); asm("trap;");} if (triIndex.z >= normals.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1267, triIndex.z, uint32_t(normals.count)); asm("trap;");} float3 n3 = ((float3*)normals.data)[triIndex.z];;
                if (vertices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1268); asm("trap;");} if (triIndex.x >= vertices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1268, triIndex.x, uint32_t(vertices.count)); asm("trap;");} float3 v1 = ((float3*)vertices.data)[triIndex.x];;
                if (vertices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1269); asm("trap;");} if (triIndex.y >= vertices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1269, triIndex.y, uint32_t(vertices.count)); asm("trap;");} float3 v2 = ((float3*)vertices.data)[triIndex.y];;
                if (vertices.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1270); asm("trap;");} if (triIndex.z >= vertices.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1270, triIndex.z, uint32_t(vertices.count)); asm("trap;");} float3 v3 = ((float3*)vertices.data)[triIndex.z];;
                if (texCoords.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1271); asm("trap;");} if (triIndex.x >= texCoords.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1271, triIndex.x, uint32_t(texCoords.count)); asm("trap;");} float2 uv1 = ((float2*)texCoords.data)[triIndex.x];;
                if (texCoords.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1272); asm("trap;");} if (triIndex.y >= texCoords.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1272, triIndex.y, uint32_t(texCoords.count)); asm("trap;");} float2 uv2 = ((float2*)texCoords.data)[triIndex.y];;
                if (texCoords.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1273); asm("trap;");} if (triIndex.z >= texCoords.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1273, triIndex.z, uint32_t(texCoords.count)); asm("trap;");} float2 uv3 = ((float2*)texCoords.data)[triIndex.z];;

                n1 = make_float3(ltw * make_float4(n1, 0.0f));
                n2 = make_float3(ltw * make_float4(n2, 0.0f));
                n3 = make_float3(ltw * make_float4(n3, 0.0f));
                v1 = make_float3(ltw * make_float4(v1, 1.0f));
                v2 = make_float3(ltw * make_float4(v2, 1.0f));
                v3 = make_float3(ltw * make_float4(v3, 1.0f));
                sampleTriangle(pos, n1, n2, n3, v1, v2, v3, uv1, uv2, uv3,
                    lcg_randomf(rng), lcg_randomf(rng), dir, lightDistance, lightPDF, uv,
                                     false, light_light.use_surface_area);
                numTris = mesh.numTris;
            }printRayInfo(LP, pixelID, ray, payload,"SampleTriLightPDF",lightPDF);

            falloff = light_light.falloff;
            lightDir = make_float3(dir.x, dir.y, dir.z);
            if (light_light.color_texture_id == -1) lightEmission = make_float3(light_light.r, light_light.g, light_light.b) * (light_light.intensity * pow(2.f, light_light.exposure));
            else lightEmission = sampleTexture(light_light.color_texture_id, uv, make_float3(0.f, 0.f, 0.f)) * (light_light.intensity * pow(2.f, light_light.exposure));
        }
printRayInfo(LP, pixelID, ray, payload,"V_z",v_z);
        if (useBRDF) {
            disney_brdf(
                mat, v_gz, v_z, v_bz, v_x, v_y,
                w_o, lightDir, normalize(w_o + lightDir), l_bsdf
            );
            dotNWi = max(dot(lightDir, v_z), 0.f);




        } else {

            l_bsdf = make_float3(1.f / (4.0 * 
# 1305 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu" 3 4
                                             3.14159265358979323846
# 1305 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
                                                 )) * mat.base_color;
            dotNWi = 1.f*max(dot(lightDir, ray.direction), 0.f);
        }
        lightPDF *= (1.f / float(numLights + 1.f)) * (1.f / float(numTris));printRayInfo(LP, pixelID, ray, payload,"LightPDF",lightPDF);printRayInfo(LP, pixelID, ray, payload,"LightDir",lightDir);printRayInfo(LP, pixelID, ray, payload,"dotNWi",dotNWi);
        if ((lightPDF > 0.0) && (dotNWi > 0.0001f)) {
            RayPayload payload; payload.instanceID = -2;
            RayPayload volPayload = payload;
            owl::RayT< 1, 1> ray;
            ray.tmin = 0.0001f * 10.f; ray.tmax = lightDistance + 0.0001f;
            ray.origin = hit_p; ray.direction = lightDir;
            ray.time = time;
            ray.visibilityMask = (1<<5);
            owl::traceRay( LP.IAS, ray, payload, occlusion_flags);
            ray.tmax = (payload.instanceID == -2) ? ray.tmax : payload.tHit;
            bool visible;
            if (randomID == numLights) {

                visible = (payload.instanceID == -2);
            } else {

                int surfEntity;
                if (payload.instanceID == -2) surfEntity = -1;
                else { if (LP.instanceToEntity.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1327); asm("trap;");} if (payload.instanceID >= LP.instanceToEntity.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1327, payload.instanceID, uint32_t(LP.instanceToEntity.count)); asm("trap;");} surfEntity = ((int*)LP.instanceToEntity.data)[payload.instanceID];; }
                visible = (payload.instanceID == -2 || surfEntity == sampledLightID);
            }
            if (visible) {printRayInfo(LP, pixelID, ray, payload, "Visible Trace");
                if (randomID != numLights) lightEmission = lightEmission / max(pow(payload.tHit, falloff),1.f);
                float w = power_heuristic(1.f, lightPDF, 1.f, bsdfPDF);
                float3 Li = (lightEmission * w) / lightPDF;
                irradiance = irradiance + (l_bsdf * Li);
            }
        }

                                                      printRayInfo(LP, pixelID, ray, payload, "Saving, see wi", w_i);
        saveLightingColorRenderData(renderData, depth, v_z, w_o, w_i, mat);


        if (bsdfPDF < 0.0001f || all_zero(bsdf)) {
            float3 contribution = pathThroughput * irradiance;
            illum = illum + contribution;
            break;
        }
    printRayInfo(LP, pixelID, ray, payload,"Before direction change");

        ray.origin = hit_p;
        ray.direction = w_i;
        ray.tmin = 0.0001f;
        payload.instanceID = -1;
        payload.tHit = -1.f;
        ray.time = sampleTime(lcg_randomf(rng));
        if (isVolume) ray.visibilityMask = (1<<4);
        else if (sampledBsdf == 3) ray.visibilityMask = (1<<3);
        else if (sampledBsdf == 0) ray.visibilityMask = (1<<1);
        else if (sampledBsdf == 1) ray.visibilityMask = (1<<2);
        else if (sampledBsdf == 2) ray.visibilityMask = (1<<2);
        owl::traceRay(LP.IAS, ray, payload, OPTIX_RAY_FLAG_DISABLE_ANYHIT);printRayInfo(LP, pixelID, ray, payload,"Traced direction change");


        bool hitLight = false;
        if (lightPDF > 0.0001f)
        { printRayInfo(LP, pixelID, ray, payload,"dotWi_v_gz", v_gz);
            float dotNWi = (useBRDF) ? max(dot(ray.direction, v_gz), 0.f) : 1.f;
         printRayInfo(LP, pixelID, ray, payload,"After dotNWi", dotNWi);

            if ((payload.instanceID == -1) && (sampledLightID == -1) && enableDomeSampling) {

                float w = power_heuristic(1.f, bsdfPDF, 1.f, lightPDF);
                float3 lightEmission = missColor(ray, envTex) * LP.domeLightIntensity * pow(2.f, LP.domeLightExposure);
                float3 Li = (lightEmission * w) / bsdfPDF;

                if (dotNWi > 0.f) {
                    irradiance = irradiance + (bsdf * Li);
                }
                hitLight = true;
            }


            else if (payload.instanceID != -1) {
                if (LP.instanceToEntity.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1383); asm("trap;");} if (payload.instanceID >= LP.instanceToEntity.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1383, payload.instanceID, uint32_t(LP.instanceToEntity.count)); asm("trap;");} int entityID = ((int*)LP.instanceToEntity.data)[payload.instanceID];;
                bool visible = (entityID == sampledLightID);

                if (visible) {
                    int3 indices; float3 p; float3 lv_gz; float2 uv;
                    if (LP.entities.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1388); asm("trap;");} if (sampledLightID >= LP.entities.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1388, sampledLightID, uint32_t(LP.entities.count)); asm("trap;");} EntityStruct light_entity = ((EntityStruct*)LP.entities.data)[sampledLightID];;
                    if (LP.meshes.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1389); asm("trap;");} if (light_entity.mesh_id >= LP.meshes.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1389, light_entity.mesh_id, uint32_t(LP.meshes.count)); asm("trap;");} MeshStruct light_mesh = ((MeshStruct*)LP.meshes.data)[light_entity.mesh_id];;
                    if (LP.lights.data == nullptr) {::printf("Device Side Error on Line %d: buffer was nullptr.\n", 1390); asm("trap;");} if (light_entity.light_id >= LP.lights.count) {::printf("Device Side Error on Line %d: out of bounds access (address: %d, size %d).\n", 1390, light_entity.light_id, uint32_t(LP.lights.count)); asm("trap;");} LightStruct light_light = ((LightStruct*)LP.lights.data)[light_entity.light_id];;
                    loadMeshTriIndices(light_entity.mesh_id, light_mesh.numTris, payload.primitiveID, indices);
                    loadMeshUVData(light_entity.mesh_id, light_mesh.numVerts, indices, payload.barycentrics, uv);

                    float dist = payload.tHit;

                    float3 lightEmission;
                    if (light_light.color_texture_id == -1) lightEmission = make_float3(light_light.r, light_light.g, light_light.b) * (light_light.intensity * pow(2.f, light_light.exposure));
                    else lightEmission = sampleTexture(light_light.color_texture_id, uv, make_float3(0.f, 0.f, 0.f)) * (light_light.intensity * pow(2.f, light_light.exposure));
                    lightEmission = lightEmission / max(pow(dist, light_light.falloff), 1.f);

                    if (dotNWi > 0.0001f)
                    {
                        float w = power_heuristic(1.f, bsdfPDF, 1.f, lightPDF);
                        float3 Li = (lightEmission * w) / bsdfPDF;
                        irradiance = irradiance + (bsdf * Li);
                    }
                    hitLight = true;
                }
            }
        }


        float3 contribution = pathThroughput * irradiance;
        illum = illum + contribution;
        pathThroughput = (pathThroughput * bsdf) / bsdfPDF;
        if (depth == 0) directIllum = illum;


        if (hitLight) break;



        float pmax = max(pathThroughput.x, max(pathThroughput.y, pathThroughput.z));
        if (lcg_randomf(rng) > pmax) {
            break;
        }
# 1436 "/beegfs/teran_parrales/NVISII/src/nvisii/devicecode/path_tracer.cu"
        ++depth;
        if (!useBRDF) volumeDepth++;
        else if (sampledBsdf == 0) diffuseDepth++;
        else if (sampledBsdf == 1) glossyDepth++;
        else if (sampledBsdf == 2) glossyDepth++;
        else if (sampledBsdf == 3) transmissionDepth++;




        if (transmissionDepth >= LP.maxTransmissionDepth) continue;printRayInfo(LP, pixelID, ray, payload, "Loop End");
    } while (


        (!(sampledBsdf == 0 && diffuseDepth > (LP.maxDiffuseDepth - (depth - 1)))) &&
        (!(sampledBsdf == 1 && glossyDepth > LP.maxGlossyDepth - (depth - 1)) ) &&
        (!(sampledBsdf == 2 && glossyDepth > LP.maxGlossyDepth - (depth - 1)) ) &&
        (!(useBRDF == false && volumeDepth > LP.maxVolumeDepth - (depth - 1))) &&
        (!(transparencyDepth > LP.maxTransparencyDepth - (depth - 1)))

    );


    saveHeatmapRenderData(renderData, depth, start_clock);


    saveDeviceAssignment(renderData, depth, self.deviceIndex);


    glm::vec3 gillum = vec3(illum.x, illum.y, illum.z);
    glm::vec3 dillum = vec3(directIllum.x, directIllum.y, directIllum.z);
    glm::vec3 iillum = gillum - dillum;






    if (LP.indirectClamp > 0.f)
        iillum = clamp(iillum, vec3(0.f), vec3(LP.indirectClamp));
    if (LP.directClamp > 0.f)
        dillum = clamp(dillum, vec3(0.f), vec3(LP.directClamp));

    gillum = dillum + iillum;


    if (glm::any(glm::isnan(gillum))) gillum = vec3(0.f);
    if (glm::any(glm::isinf(gillum))) gillum = vec3(0.f);
    illum = make_float3(gillum.r, gillum.g, gillum.b);


    accum_illum = illum;


    auto fbOfs = pixelID.x+LP.frameSize.x * ((LP.frameSize.y - 1) - pixelID.y);
    float4* accumPtr = (float4*) LP.accumPtr;
    float4* fbPtr = (float4*) LP.frameBuffer;
    float4* normalPtr = (float4*) LP.normalBuffer;
    float4* albedoPtr = (float4*) LP.albedoBuffer;

    float4 prev_color = accumPtr[fbOfs];
    float4 prev_normal = normalPtr[fbOfs];
    float4 prev_albedo = albedoPtr[fbOfs];
    float4 accum_color;

    if (LP.renderDataMode == RenderDataFlags::NONE)
    {
        accum_color = make_float4((accum_illum + float(LP.frameID) * make_float3(prev_color)) / float(LP.frameID + 1), 1.0f);
    }
    else {

        accum_illum = make_float3(renderData.x, renderData.y, renderData.z);
        if (isnan(renderData.x) || isnan(renderData.y) || isnan(renderData.z) ||
            isinf(renderData.x) || isinf(renderData.y) || isinf(renderData.z) ||
            isnan(prev_color.x) || isnan(prev_color.y) || isnan(prev_color.z) ||
            isinf(prev_color.x) || isinf(prev_color.y) || isinf(prev_color.z)) {
            accum_illum = make_float3(0.f, 0.f, 0.f);
            prev_color = make_float4(0.f, 0.f, 0.f, 1.f);
        }
        accum_color = make_float4((accum_illum + float(LP.frameID) * make_float3(prev_color)) / float(LP.frameID + 1), 1.0f);




    }



    vec4 oldAlbedo = make_vec4(prev_albedo);
    vec4 oldNormal = make_vec4(prev_normal);
    if (any(isnan(oldAlbedo))) oldAlbedo = vec4(0.f);
    if (any(isnan(oldNormal))) oldNormal = vec4(0.f);
    vec4 newAlbedo = vec4(primaryAlbedo.x, primaryAlbedo.y, primaryAlbedo.z, 1.f);
    vec4 accumAlbedo = (newAlbedo + float(LP.frameID) * oldAlbedo) / float(LP.frameID + 1);
    vec4 newNormal = vec4(make_vec3(primaryNormal), 1.f);
    if (!all(equal(make_vec3(primaryNormal), vec3(0.f, 0.f, 0.f)))) {
        glm::quat r0 = glm::quat_cast(LP.viewT0);
        glm::quat r1 = glm::quat_cast(LP.viewT1);
        glm::quat rot = (glm::all(glm::equal(r0, r1))) ? r0 : glm::slerp(r0, r1, time);
        vec3 tmp = normalize(glm::mat3_cast(rot) * make_vec3(primaryNormal));
        tmp = normalize(vec3(LP.proj * vec4(tmp, 0.f)));
        newNormal = vec4(tmp, 1.f);
    }
    vec4 accumNormal = (newNormal + float(LP.frameID) * oldNormal) / float(LP.frameID + 1);


    accumPtr[fbOfs] = accum_color;
    fbPtr[fbOfs] = accum_color;
    albedoPtr[fbOfs] = make_float4(accumAlbedo);
    normalPtr[fbOfs] = make_float4(accumNormal);
}
